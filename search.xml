<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统概述(第一部分)</title>
      <link href="/2022/04/05/operating_system1/"/>
      <url>/2022/04/05/operating_system1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统——第一章-系统概述"><a href="#操作系统——第一章-系统概述" class="headerlink" title="操作系统——第一章: 系统概述"></a>操作系统——第一章: 系统概述</h1><h2 id="1-1-基本概念（定义）"><a href="#1-1-基本概念（定义）" class="headerlink" title="1.1 基本概念（定义）"></a>1.1 基本概念（定义）</h2><ul><li>操作系统（operating system，os）是系统资源的<strong>管理者</strong>，管理<strong>软件、硬件资源</strong>，给用户和其他软件方便的接口和环境，是一个<strong>系统软件</strong>。</li></ul><h2 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2  操作系统特征"></a>1.2  操作系统特征</h2><h3 id="1-并发（concurrence）"><a href="#1-并发（concurrence）" class="headerlink" title="1. 并发（concurrence）"></a>1. 并发（concurrence）</h3><p>微观上交替进行，宏观上同时执行。（操作系统和程序并发是一起诞生的）</p><ul><li>重点：<ul><li>单核CPU：同一时刻只能执行一个程序，各个程序只能<strong>并发</strong>执行。</li><li>多核CPU：同一时刻可以同时执行多个程序，多个程序可以<strong>并行</strong>执行。</li></ul></li></ul><h3 id="2-共享（sharing）"><a href="#2-共享（sharing）" class="headerlink" title="2. 共享（sharing）"></a>2. 共享（sharing）</h3><p>系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>互斥：系统中某些资源，虽然可以给多进程使用，但一个时间段内只允许一个进程访问该资源。</p><p>同时：系统中某些资源，允许一个时间段内由多个进程 “同时” 对他们进行访问。（微观上可能是交替的）</p><pre class="mermaid">graph LRA(两种资源共享方式) -->B(互斥共享方式)    B -->C(一个时间段内只允许一个进程访问该资源)    A -->D(同时共享模式)    D -->E(一个时间段内由多个进程 同时 对他们进行访问)    F[sharing]</pre><p><strong>注意</strong>：并发和共享是操作系统两个最基本特征，<strong>两者互为存在条件</strong>：</p><ol><li>资源共享是一程序并发为条件的。（若系统不允许程序并发执行，自然不存在资源共享问题）</li><li>若系统不能对资源共享进行有效管理，一定影响到程序的并发执行。</li></ol><h3 id="3-虚拟（virtual）"><a href="#3-虚拟（virtual）" class="headerlink" title="3. 虚拟（virtual）"></a>3. 虚拟（virtual）</h3><ul><li>可归纳为：<ul><li>时分复用技术：如处理器的分时共享（微观：处理机在微小时间段为各个进程服务，大时间分成小时间）</li><li>空分复用技术：如虚拟存储器</li></ul></li></ul><p>详见第三章</p><h3 id="4-异步（asynchronism）"><a href="#4-异步（asynchronism）" class="headerlink" title="4. 异步（asynchronism）"></a>4. 异步（asynchronism）</h3><p>并发的程序不是从头走到底的，是“走走停停”，如果进程正在占用资源，其他进程需要先被阻塞，等待资源释放。</p><h2 id="1-3-操作系统运行机制"><a href="#1-3-操作系统运行机制" class="headerlink" title="1.3 操作系统运行机制"></a>1.3 操作系统运行机制</h2><ul><li><p>实现操作系统，需要写<strong>内核程序</strong>，很多个内核程序组成**操作系统内核(kernel)**，简称内核，是整个操作系统最核心的部分。</p><ul><li>操作系统有个内核就足够了 (eg. Docker容器 -&gt; 仅需linux内核)</li><li>操作系统的功能未必都在内核中，如GUI图形化界面</li></ul></li><li><p>CPU设计的时候就划分了特权指令和非特权指令</p><ul><li>应用程序只能运行非特权指令（如加法减法）</li><li>内核程序可以运行特权指令（如内存清0指令，这条指令影响重大，只允许“管理者”——即操作系统内核来使用）。</li></ul></li><li><p>但是CPU运行的时候，只会把一条一条指令（二进制指令）送进去运行，怎么判断运行的程序是应用程序指令还是内核程序的指令？</p><p>此时我们把CPU划分成为两种状态，<strong>”内核态“</strong>，<strong>“用户态”</strong></p><ul><li><p>内核态：说明此时运行的是<code>内核程序</code>，<strong>可以执行特权指令</strong></p></li><li><p>用户态：说明此时运行的是<code>应用程序</code>，<strong>只能执行非特权指令</strong></p></li><li><p>CPU中的寄存器**程序状态字寄存器（PSW)**，其中有一个二进制位，1表示内核态，0表示用户态</p><p>当需要交换状态，修改PSW值即可</p></li></ul></li></ul><h2 id="1-4-中断和异常"><a href="#1-4-中断和异常" class="headerlink" title="1.4 中断和异常"></a>1.4 中断和异常</h2><ul><li>中断的作用：如果应用程序运行的时候，发生了中断，就会让cpu立即停止此时运行的应用程序，转而执行相应的内核程序。中断是让管理者（操作系统内核）夺回使用权的唯一途径，而中断，会使CPU由用户态转变为内核态</li></ul><pre class="mermaid">graph LRA(内核态 -> 用户态) -->B(用特权指令 修改PSW的值)C(用户态 -> 内核态) -->D(引发 中断 硬件自动完成 CPU状态转换过程 强行夺回CPU使用权)</pre><ul><li><p>中断的类型：</p><ul><li><p>内中断（也叫做 <strong>异常</strong>）：与当前执行指令有关，中断信号来源于CPU内部</p><p>有时候应用程序想请求操作系统内核的服务，此时会执行一条<strong>特殊的指令——陷入指令</strong>。该指令会引发一个内部中断信号。应用程序主动吧使用权归还给操作系统，希望操作系统提供某项服务。（先传入所需的参数，再调用陷入指令）</p><ul><li>而<strong>系统调用</strong>就是利用陷入指令来完成</li><li><strong>陷入指令并不是特权指令</strong>,陷入指令在用户态执行，执行后立刻引发一个<strong>内中断</strong>，使CPU进入内核态。</li></ul><p>异常分三个种类：</p><ul><li><p>陷阱、陷入（trap）：</p><p>由陷入指令引发，是应用程序故意引发的</p></li><li><p>故障（fault）：</p><p>由错误条件引起，可能被内核程序修复。内核程序修复后会把CPU使用权还给应用程序，让他继续执行下去。如：缺页故障</p></li><li><p>终止（abort）：</p><p>由致命错误引起，内核程序无法修复，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0，非法使用特权指令</p></li></ul></li><li><p>外中断（狭义上统称 <strong>中断</strong>）：与当前执行指令无关，中断信号来源于CPU外部</p><p>例子：时钟中断。由时钟部件（在cpu的外部）发来中断信号，实现程序并发的重要前提。</p><p>​            io设备提供中断信号。这些中断信号让操作系统可以很好的调度各个进程。</p><p>外部中断又分可屏蔽中断<strong>INTR</strong>和不可屏蔽中断<strong>NMI</strong></p></li></ul></li><li><p>中断机制的基本原理：</p></li></ul><p>不同类型的中断信号，需要用不同的中断处理程序来处理。查询<strong>中断向量表</strong>，以此来找到相应的中断处理程序在内存中存放的位置。</p><p>显然，中断处理程序一定是在内核态的，需要运行在内核态（涉及计算机组成原理）</p><h2 id="1-5-系统调用"><a href="#1-5-系统调用" class="headerlink" title="1.5 系统调用"></a>1.5 系统调用</h2><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单好用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p><pre class="mermaid">graph TDA[应用程序] --> system(系统调用)    A --> |高级语言| C(c库函数)    C --> system(系统调用)    system(系统调用) --> operating[操作系统]    F[系统调用与库函数的区别]</pre><pre class="mermaid">graph LRA(系统调用 按功能分类) -->B(设备管理 完成对设备的 请求/释放/启动 等功能)A -->C(文件管理 完成对文件的 读/写/创建/删除 等功能)A -->D(进程控制 完成进程的 创建/撤销/阻塞/唤醒 等功能)A -->E(进程通信 完成进程之间的 消息传送/信号传递 等功能)A -->F(内存管理 完成内存的 分配/回收 等功能)</pre><p>*拓展链接：<a href="https://www.cnblogs.com/wanghuaijun/p/6548633.html">linux提供了哪些系统调用</a></p><ul><li><p>凡是与共享资源有关的操作（如存储分配、IO操作、文件管理等），都必须通过系统调用的方式向<strong>操作系统内核</strong>提出服务请求。由内核代为完成，保证系统的稳定性与安全性。（也防止用户非法操作）</p></li><li><p>总结：</p><ul><li>陷入指令是在用户态执行，执行陷入指令后立即引发一个内中断，使CPU进入内核态。</li><li>发出系统调用的请求是在用户态，而对系统调用的相应处理是在内核态下进行。</li></ul></li><li><p>别名：<strong>内核态&#x3D;核心态&#x3D;管态</strong>    <strong>用户态&#x3D;目态</strong>  <strong>陷入指令&#x3D;trap指令&#x3D;访管指令</strong></p><ul><li>访管指令的基本功能是让程序拥有 “自愿进管” 的手段。从而引起访管中断。访管中断处理程序将按照系统调用的操作数和参数转到相应的例行子程序[^1]。完成服务功能后，退出中断，返回到用户程序断点继续执行。</li></ul><p>[^1]:例行程序 (routine)亦称例程.一种计算机程序.是与一项计算任务相对应的处理对象和处理规则的描述.可以是一个主程序的一部分或一个专用程序，也可包含若干个子程序.它一般在一个程序或多个程序中多次使用.例行程序和子程序常常存放在程序库中，通常存储在外存储器上.</p></li></ul><h2 id="1-6-操作系统的体系结构"><a href="#1-6-操作系统的体系结构" class="headerlink" title="1.6 操作系统的体系结构"></a>1.6 操作系统的体系结构</h2><h3 id="1-分层法"><a href="#1-分层法" class="headerlink" title="1 分层法"></a>1 分层法</h3><p>将操作系统分为若干层，最底层（层0）为硬件，最高层（层N）为用户接口。每层只能调用紧邻它的低层的功能与服务（单向依赖）</p><ul><li>优点：<ul><li>便于系统的调试和验证，简化了系统设计与实现。</li><li>易扩充、易维护：增加、修改或替换其中一层，只要不改变接口，就不会影响其它层。</li></ul></li><li>缺点：<ul><li>各层合理定义较难，依赖关系稳定之后，往往不够灵活。</li><li>效率较差，通常调用的时候需要自上而下地穿越多层，增加开销。</li></ul></li></ul><h3 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2 模块化"></a>2 模块化</h3><p>是将操作系统按功能分为若干个功能模块。每个模块具有某种功能，并规定好接口，使各个模块之间可以通信。然后细分下各个子模块，这种设计方法叫做<strong>模块-接口法</strong>。</p><p>划分模块的时候，如果分的太小，虽然可以降低模块本身的复杂性，但会使得模块之间的联系过多，造成系统比较混乱。如果模块分的过大，会增加模块内部复杂性。</p><p>而且，划分模块的时候，要充分考虑模块的独立性，独立性越高，各个模块之间交互就变少，系统结构也就越清晰。衡量模块的独立性主要有两个标准：</p><ul><li><p>内聚性：模块内部各个部分联系的紧密程度。内聚性越高，模块独立性越好。</p></li><li><p>耦合度：模块间相互联系和相互影响的程度。耦合性越高，模块独立性越好。</p></li><li><p>优点：</p><ul><li>提高了操作系统设计的正确性、可理解性、可维护性</li><li>增强了操作系统的课适应性</li><li>加速了操作系统的开发过程</li></ul></li><li><p>缺点：</p><ul><li>模块间的接口规定很难满足对接口的实际需求</li><li>各个模块规格的设计没有一个统一的好答案，没找到可靠的决定顺序</li></ul></li></ul><h3 id="3-内核架构"><a href="#3-内核架构" class="headerlink" title="3 内核架构"></a>3 内核架构</h3><p><strong>而操作系统从内核上分大致分为两点：</strong></p><ul><li>大内核&#x2F;单内核&#x2F;宏内核 <ul><li>操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码量庞大，结构混乱，难以维护</li><li>典型的大内核操作系统：Linux、Unix</li></ul></li><li>微内核<ul><li><p>只把最基本的功能留在内核</p></li><li><p>优点：内核功能少，结构清晰，方便维护</p></li><li><p>缺点：需要频繁地在内核态和用户态切换，容易降低CPU性能</p></li><li><p>典型的微内核操作系统：Windows NT</p></li><li><p>定义微内核结构OS的四个方面：</p><ul><li><p>足够小的内核</p></li><li><p>基于客户&#x2F;服务器模式</p></li><li><p>应用<strong>机制与策略分离</strong>原理</p><ul><li><p>机制是指实现某一功能的具体执行机构</p></li><li><p>策略是指在机制的基础上借助于某些参数和算法来实现该功能的优化，或者达到不同的功能目标。</p><p>传统OS中，将机制放在OS内核的较低层中，把策略放在内核的较高层。而微内核OS中，通常将机制放在微内核里，才能把内核做的很小</p></li></ul></li><li><p>采用面向对象技术</p><p>基于面向对象技术中的<strong>抽象</strong>与<strong>隐蔽</strong>原则，能控制系统的复杂性。进一步利用<strong>对象、封装、继承</strong>等概念还能确保系统运行的正确、可靠、易扩展性。也是因为如此，面向对象技术被广泛应用在操作系统的设计中。</p></li></ul></li></ul></li></ul><p>操作系统主要分两个板块：</p><ul><li><p>非内核功能：如GUI</p></li><li><p>内核功能：</p><ul><li><p>与硬件管理较紧密的模块</p><ul><li>时钟管理（利用时钟中断实现计时功能）</li><li>中断处理</li><li>原语（设备驱动、CPU切换等）<ul><li>是一种特殊程序</li><li>处于操作系统最底层，是最接近硬件的部分</li><li>这种程序具有原子性，运行必须一气呵成，不可被中断。</li><li>运行时间短，调用频繁</li></ul></li></ul></li><li><p>这些管理工作更多是对数据结构的操作，不会直接涉及硬件。</p><ul><li><p>把这部分功能也写进内核的内核叫大内核。反之，只有时钟，中断，原语的内核称之为微内核，其进程管理等等内容将运行在用户态，对性能有一定的影响。</p></li><li><p>进程管理、存储器管理、设备管理等功能</p></li></ul></li><li><p>这些内核功能，必须运行在内核态</p></li><li><p>微内核相比大内核，CPU运行状态的转换（psw）的次数会变多。CPU运行状态的转换是有成本的，消耗不少时间。频繁转换运行状态会降低系统性能</p></li></ul></li><li><p>Ubuntu、centos的开发团队主要是实现了非内核功能，而内核功能都是用了Linux内核。</p></li></ul><h2 id="1-7-操作系统的发展与分类"><a href="#1-7-操作系统的发展与分类" class="headerlink" title="1.7 操作系统的发展与分类"></a>1.7 操作系统的发展与分类</h2><h3 id="1-手工操作阶段"><a href="#1-手工操作阶段" class="headerlink" title="1 手工操作阶段"></a>1 手工操作阶段</h3><ul><li><p>纸带机打孔</p></li><li><p>缺点：用户独占全集，<a href="%E4%BA%BA%E9%9C%80%E8%A6%81%E5%BE%88%E9%95%BF%E6%97%B6%E9%97%B4%E5%86%99%E7%BA%B8%E5%B8%A6%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%94%E4%B8%80%E6%AC%A1%E5%8F%AA%E8%83%BD%E7%94%B1%E4%B8%80%E5%90%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E4%B8%8D%E5%85%81%E8%AE%B8%E5%A4%9A%E4%BA%BA%E4%BD%BF%E7%94%A8%EF%BC%9B%E8%80%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BE%88%E5%BF%AB%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%90%E8%A1%8C%E5%AE%8C%E7%BA%B8%E5%B8%A6%E4%BB%A3%E7%A0%81">^人机速度矛盾</a>导致资源利用率低。</p></li></ul><h3 id="2-单道批处理系统"><a href="#2-单道批处理系统" class="headerlink" title="2 单道批处理系统"></a>2 单道批处理系统</h3><ul><li>引入<strong>脱机输入&#x2F;输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序（操作系统的雏形）</strong>负责控制作业的输入输出，磁带读取熟读比纸带快很多</li><li>主要优点：缓解一定程度的人及速度矛盾，资源利用率有一定的提升</li><li>主要缺点：内存中仅能有一道程序运行，运行结束才能进行下一道（串行执行）。而<strong>CPU有大量的时间在空闲等待IO完成</strong>，资源利用率还是不高</li></ul><h3 id="3-多道批处理系统"><a href="#3-多道批处理系统" class="headerlink" title="3 多道批处理系统"></a>3 多道批处理系统</h3><ul><li><p>每次往内存中读取多道程序</p></li><li><p>操作系统正式诞生，支持多道程序并发运行</p></li><li><p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源，<strong>资源利用率大幅度提升</strong>，CPU和其他组员更能保持 “忙碌” 状态，系统吞吐量增大</p></li><li><p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业指挥就只能等待计算机处理完毕，中间不能控制自己的作业执行</p><p>如：无法调试程序，无法在程序运行中输入参数）</p></li></ul><h3 id="4-分时操作系统"><a href="#4-分时操作系统" class="headerlink" title="4 分时操作系统"></a>4 分时操作系统</h3><ul><li><p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可以通过终端与计算机进行交互</p></li><li><p>主要优点：用户请求可以被即时响应，<strong>解决人机交互的问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</p></li><li><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户&#x2F;作业都是公平的，循环地为每个用户&#x2F;作业服务一个时间片，不区分任务优先级&#x2F;紧急性。</p></li></ul><h3 id="5-实时操作系统"><a href="#5-实时操作系统" class="headerlink" title="5 实时操作系统"></a>5 实时操作系统</h3><ul><li><p>计算机接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p><ul><li>硬实时系统：必须在绝对严格的时间内完成任务<ul><li>如：自动驾驶系统</li></ul></li><li>软实时系统：能够接受偶尔的违反时间规定<ul><li>如：订票系统（实时更新票数）</li></ul></li></ul></li><li><p>主要优点：能够及时响应一些紧急任务，某些优先级高的任务不需要时间片排队。</p><h3 id="6-其他操作系统"><a href="#6-其他操作系统" class="headerlink" title="*6 其他操作系统"></a>*6 其他操作系统</h3></li><li><p>网络操作系统：实现网络中各种资源的共享（文件共享）和各个计算机之间的通信</p></li><li><p>分布式操作系统：特点是分布性、并行性，任何任务都可以分布在这些计算机上，并行协同地完成任务</p></li><li><p>个人操作系统：Windows、macOS等等</p></li></ul><h2 id="1-8-操作系统引导"><a href="#1-8-操作系统引导" class="headerlink" title="1.8 操作系统引导"></a>1.8 操作系统引导</h2><p>常见的操作系统引导流程如下</p><ul><li><p>激活CPU：</p><p>激活的CPU读取ROM<a href="%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%8C%E5%8D%B3%E4%BD%BF%E5%88%87%E6%96%AD%E7%94%B5%E6%BA%90%EF%BC%8C%E4%BF%A1%E6%81%AF%E4%B9%9F%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1%EF%BC%8C%E5%8F%88%E7%A7%B0%E4%B8%BA%E5%9B%BA%E5%AE%9A%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%82%E6%95%B4%E6%9C%BA%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%87%BA%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%83%8F%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%E8%83%BD%E5%BF%AB%E9%80%9F%E6%96%B9%E4%BE%BF%E5%9C%B0%E6%94%B9%E5%86%99%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9%E3%80%82">^ROM</a>中的boot程序，将指令寄存器置为BIOS<a href="%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F">^BIOS</a>的第一条指令，即开始执行BIOS的指令。</p></li><li><p>硬件自检：</p><p>启动BIOS程序之后，先进行硬件自检，检测是否故障。如有故障，用蜂鸣器发出不同含义的蜂鸣；如无故障，屏幕会开始显示cpu，内存，硬盘等等信息。</p></li><li><p>加载带有操作系统的硬盘：</p><p>BIOS在自检结束后，开始读取Boot Sequence(通过CMOS里存的启动顺序，或者通过与用户交互的方式)，把控制权交给排序第一位的设备。然后CPU将该存储设备的<strong>引导扇区</strong>的内容存至内存中。</p></li><li><p>加载主引导记录<strong>MBR</strong>：</p><p>硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现该盘不是可引导盘，就换下一个。若没有课引导盘，会导致死机。<strong>主引导记录MBR的作用就是告诉CPU去硬盘的哪个分区去寻找操作系统</strong>。</p></li><li><p>扫描硬盘分区表，并加载硬盘活动分区：</p><p>MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘的活动分区之后，开始加载硬盘的活动分区，将控制权交给活动分区。</p></li><li><p>加载分区引导记录PBR：</p><p>读取活动分区的第一个扇区，这个扇区称为**分区引导记录(PBR)**，其作用是寻找并激活分区根目录下，用于引导操作系统的程序（启动管理器）。</p></li><li><p>加载启动管理器：</p><p>分区引导记录搜索活动分区中的启动管理器，并加载它。</p></li><li><p>加载操作系统</p></li></ul><h2 id="1-9-虚拟机"><a href="#1-9-虚拟机" class="headerlink" title="1.9 虚拟机"></a>1.9 虚拟机</h2><p>虚拟机是一台逻辑计算机。通过隐藏特点计算平台的实际物理特性，为用户提供抽象、统一、模拟的计算环境。有两种虚拟方法。</p><h3 id="1-第一类虚拟管理程序"><a href="#1-第一类虚拟管理程序" class="headerlink" title="1 第一类虚拟管理程序"></a>1 第一类虚拟管理程序</h3><p>该虚拟机作为用户态执行，不允许使用特权指令。而虚拟机上的操作系统认为自己是在内核态（实际上不是），成为虚拟内核态。</p><p>在支持虚拟化的CPU上，执行特权指令时，，虚拟机管理程序会检测是虚拟机中的操作系统执行的还是虚拟机中的用户程序执行的。前者，会安排正常执行；否则，虚拟机管理程序会模拟真实硬件，面对用户，模拟执行特权指令时的行为。</p><h3 id="2-第二类虚拟管理程序"><a href="#2-第二类虚拟管理程序" class="headerlink" title="2 第二类虚拟管理程序"></a>2 第二类虚拟管理程序</h3><p>是一类与操作系统分配和调度资源的程序，很像一个普通的进程。。这一类仍然伪装成具有CPU和各种资源的完备计算机。VMware是首个在x86上的第二类虚拟管理程序。</p><p>刚开始启动的时候，这一类虚拟管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（宿主操作系统中的一个文件）。安装完成后即可运行。</p><p>有的说法，把第一类成为<strong>裸金属架构</strong>，第二类称为<strong>寄居架构</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈搭建Matery的一些流程</title>
      <link href="/2022/04/02/build-matery/"/>
      <url>/2022/04/02/build-matery/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈搭建matery的一些流程"><a href="#浅谈搭建matery的一些流程" class="headerlink" title="浅谈搭建matery的一些流程"></a>浅谈搭建matery的一些流程</h1><p>好不容易完善了该matery，发现自己并没有记录如何真正搭建的流程。</p><p>乘着刚搭建不久，来记录一下搭建<code>hexo-theme-matery</code>的一些流程</p><h2 id="0，介绍开发环境"><a href="#0，介绍开发环境" class="headerlink" title="0，介绍开发环境"></a>0，介绍开发环境</h2><ul><li><p>长年未更新的老Win10，以及更新过的vscode</p></li><li><p>这里建议参考以下几个链接一起看</p><ul><li><a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></li><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/">https://godweiyang.com/2018/04/13/hexo-blog/</a></li><li><a href="https://www.matemaster.cn/posts/52745.html">https://www.matemaster.cn/posts/52745.html</a></li></ul></li></ul><h2 id="1，搭建node-js等等初步工作环境"><a href="#1，搭建node-js等等初步工作环境" class="headerlink" title="1，搭建node.js等等初步工作环境"></a>1，搭建node.js等等初步工作环境</h2><p>先去官网下载<a href="https://nodejs.org/en/">node.js</a>，选择稳定版即可</p><p><img src="https://s2.loli.net/2022/04/03/dOYo2q4nPvJhrcl.png"></p><p>一路默认安装即可。装完会有两个组件，一个是node.js本身，一个是npm组件。</p><ul><li>自己新建一个文件夹，以后的网页代码全放在里面，我的是在d:&#x2F;tuoyou-hao</li><li>用vscode打开这个文件夹（或者你用命令行 cd 进去 也可以），在vscode打开终端，输入以下指令</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">&gt; node -vv16.14.2&gt; npm -v8.5.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于npm下载速度较慢，我们可以选用淘宝的源下载。我们用npm下载cnpm：</p><p><code> &gt; npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>下载完成后，输入<code>cnpm -v</code>检查一下，输出下列内容即为正常</p><p><img src="https://s2.loli.net/2022/04/03/WDuRxhQiZV1w9IN.png"></p><p>然后我们开始安装hexo</p><pre class="line-numbers language-none"><code class="language-none">&gt; cnpm install -g hexo-cli &gt; hexo -vINFO  Validating confighexo: 6.1.0hexo-cli: 4.3.0os: win32 10.0.17134node: 16.14.2v8: 9.4.146.24-node.20uv: 1.43.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1n+quiccldr: 40.0icu: 70.1tz: 2021a3unicode: 14.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV# 显示如上内容，hexo就是正常的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个文件夹里面 <code>hexo init</code></p><p>hexo会为你生成很多文件，然后下载并配置一个默认主题（在theme文件夹）</p><p>配置完成后，命令行输入<code>hexo s</code>即可在本地localhost:4000看到hexo给你生成的网页</p><p>进入\source\_posts文件夹底下，就是存放你的博客的地方，使用markdown格式编写。</p><p>确认完毕以后，先去申请一个新的GitHub仓库</p><p>会让你填写自己GitHub的地址。此时需要申请自己的GitHub，并将仓库命名为&lt;你的GitHub名字&gt;.github.io</p><ul><li><p>比如我的GitHub名字叫tuoyou-hao，创建的新仓库就叫做“tuoyou-hao.github.io”。<strong>必须符合该命名格式</strong>！</p><p>创建完该仓库即可，无需进行其他操作</p></li><li><p>去配置GitHub的ssh key，建立ssh链接，具体步骤参考：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account</a></p></li></ul><p>配置完毕后，执行该指令，下载GitHub推送工具</p><p><code>cnpm install --save hexo-deployer-git</code></p><p>然后修改根目录下<code>_config.yml</code>里头的配置，找到deploy选修</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git  repository: git@github.com:xxx&#x2F;xxx.github.io.git #填你的仓库名  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行hexo指令。命令行常用以下指令：</p><pre class="line-numbers language-none"><code class="language-none">hexo clean #清理本地生成文件hexo g  # 生成博客网页文件hexo s  # 本地预览博客hexo d  # 上传网页文件到github<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>hexo d完毕以后，进入你xxx.gihub.io网站，即可查看到你部署的网页（会有几分钟的延迟）</p><h2 id="2，配置matery"><a href="#2，配置matery" class="headerlink" title="2，配置matery"></a>2，配置matery</h2><ul><li><p>git clone该链接到themes文件夹：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p></li><li><p>并把根目录下<code>_config.yml</code>文件里的theme参数改成你clone的文件夹名字（我自己重命名叫matery，theme参数也要叫matery）</p></li><li><p>在matery主题文件夹里面也有一个<code>_config.yml</code>文件，还有一个<code>README_CN.md</code>文件，请你一定要认真仔细看那份文件，需要根据那份文件下载各种依赖。下载完成后，根据自己的需要去配置</p></li><li><p>配置完成就发布到自己的GitHub仓库吧</p></li></ul><h2 id="3，百度推送"><a href="#3，百度推送" class="headerlink" title="3，百度推送"></a>3，百度推送</h2><p>在百度推送上，建议参考：<a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1</a></p><p>登录该网站：<a href="https://ziyuan.baidu.com/">https://ziyuan.baidu.com/</a></p><p>登录成功后，在用户中心-&gt;站点管理-&gt;添加网站操作 </p><p>然后如何寻找token呢，token&#x3D;秘钥：</p><p><img src="https://s2.loli.net/2022/04/03/j4m8YTUfV29Dei3.jpg"></p><p>其中matery内置了推送功能，我们只需要写好参数即可。</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git  repository: git@github.com:xxx&#x2F;xxx.github.io.git  branch: master- type: baidu_url_submitter #记得在deploy下配置这一句baidu_url_submit:  count: 20 # 提交最新的一个链接  host: https:&#x2F;&#x2F;xxx.github.io # 在百度资源搜索平台中注册的域名  token: xxxxxxx # 请注意这是推送秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4，-配置评论控件"><a href="#4，-配置评论控件" class="headerlink" title="4， 配置评论控件"></a>4， 配置评论控件</h2><p>首先，在matery底下，将js底下的twikoo更新至最新版</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">js:twikoo: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;twikoo&#x2F;dist&#x2F;twikoo.all.min.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参考链接：<a href="https://twikoo.js.org/quick-start.html#%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2">https://twikoo.js.org/quick-start.html#%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2</a></p><ol><li><p>申请 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDB (opens new window)</a>账号</p></li><li><p>创建免费 MongoDB 数据库，区域推荐选择 <code>AWS / N. Virginia (us-east-1)</code></p></li><li><p>在 Clusters 页面点击 CONNECT，按步骤设置允许所有 IP 地址的连接（<a href="https://vercel.com/support/articles/how-to-allowlist-deployment-ip-address">为什么？ (opens new window)</a>），创建数据库用户，选择connect，一定要选择链接您的应用，那个数据库连接字符串才是我们需要的，请将连接字符串中的 <code>password</code> 修改为数据库密码</p><p><img src="https://s2.loli.net/2022/04/03/kLJfdnUmFrqZleC.png"></p><p><img src="https://s2.loli.net/2022/04/03/jmieJ9aAYcXLISO.png"></p></li><li><p>申请 <a href="https://vercel.com/signup">Vercel (opens new window)</a>账号</p></li><li><p>进入以下网址把 Twikoo 一键部署到 Vercel<br><a href="https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/dev/src/vercel-min">https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/dev/src/vercel-min</a></p></li><li><p>进入 Settings - Environment Variables，添加环境变量 <code>MONGODB_URI</code>，值为第 3 步的数据库连接字符串</p></li><li><p>进入 Overview，点击 Domains 下方的链接，如果环境配置正确，可以看到 “Twikoo 云函数运行正常” 的提示</p></li><li><p>Vercel Domains（包含 <code>https://</code> 前缀，例如 <code>https://xxx.vercel.app</code>）整个网址即为您的环境 id</p></li><li><p>把网址贴进主题的_config.yml里头对应的twikoo的envId，并启用twikoo功能。</p></li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">twikoo:  enable: true  visitor: true  envId: https:&#x2F;&#x2F;xxxx.app #搭建教程：https:&#x2F;&#x2F;twikoo.js.org&#x2F;quick-start.html  # region: ap-guangzhou # 环境地域，默认为 ap-shanghai  path: &#39;window.location.pathname&#39; # 自定义文章路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5，-配置图像上传"><a href="#5，-配置图像上传" class="headerlink" title="5， 配置图像上传"></a>5， 配置图像上传</h2><p>在写本篇博客的时候，当我推送上来的时候，意外的发现文章的图片迟迟读取不了，测试过以下指令，反而本地localhost也读取不了了<br><code>cnpm install https://github.com/CodeFalling/hexo-asset-image –save</code></p><p>由于我并非前端工作者，对这方面知识还是比较匮乏，你们可以参考这个教程的解决方法：<br><a href="https://www.cnblogs.com/hugochen1024/p/12570656.html">https://www.cnblogs.com/hugochen1024/p/12570656.html</a></p><p>我自己是注册<code>SM.MS</code>网站，链接：<a href="https://sm.ms/">https://sm.ms/</a><br>在该网站上传图片，网站会给你一个链接，导入该链接的图片即可。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速入门Makefile(新手向)</title>
      <link href="/2022/03/31/Makefile-quick-get-start/"/>
      <url>/2022/03/31/Makefile-quick-get-start/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门Makefile-新手向"><a href="#快速入门Makefile-新手向" class="headerlink" title="快速入门Makefile(新手向)"></a>快速入门Makefile(新手向)</h1><h2 id="1、什么是Makefile"><a href="#1、什么是Makefile" class="headerlink" title="1、什么是Makefile"></a>1、什么是Makefile</h2><p>​        特别是在 Unix 下的软件编译，如果你正在开发一个大型的工程，你就不能不自己写Makefile了。</p><p>​        因为，Makefile关系到了整个代码工程的编译规则。一个工程中的源文件不计数，按类型、功能、模块分别放在若干个目录中，Makefile定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行其他更加复杂的操作。Makefile就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。</p><p>​        Makefile带来的好处就是——“自动化编译”，一旦你写好了Makefile，只需要一个<code>make </code>命令，整个工程就会完全自动编译，极大的提高了软件开发效率。</p><p>​        在我还刚接触Makefile的时候，我常常苦恼于找不到易读好懂的Makefile教程。本篇仅仅快速描述一个简单的Makefile应该是什么样子的，介绍一些基本的指令和语法，便于快速熟悉相关的指令。</p><h2 id="2、Makefile的一些基本规则"><a href="#2、Makefile的一些基本规则" class="headerlink" title="2、Makefile的一些基本规则"></a>2、Makefile的一些基本规则</h2><ul><li>本篇将以C语言的源码为基础，默认使用gcc编译器，需要有相关的前置知识</li></ul><p>make 命令执行时，需要一个Makefile文件，以告诉 make 命令需要怎么样的去编译和链接程序。 文件名只能用makefile、Makefile或者GNUmakefile 。最常用的是<code>makefile</code>、<code>Makefile</code>。</p><p>(如果你非要使用别的名字来命名Makefile，需要使用指令make后加参数<code>-f</code>&#x2F;<code>--file</code>，如 <code>make -f your_makefile_name.md</code> )</p><ul><li>Makefile 的基本规则。<ul><li>如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。 </li><li>如果这个工程的某几个 C 文件被修改，那么我们只会编译被修改的 C 文件，并链接目标程序。 </li><li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件， 并链接目标程序。</li></ul></li></ul><h2 id="3、Makefile编写"><a href="#3、Makefile编写" class="headerlink" title="3、Makefile编写"></a>3、Makefile编写</h2><h3 id="3-1-来写一个最简单的Makefile"><a href="#3-1-来写一个最简单的Makefile" class="headerlink" title="3.1 来写一个最简单的Makefile"></a>3.1 来写一个最简单的Makefile</h3><p>我们来看这一段代码<code>a.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void main()&#123;printf(&quot;Hello World\n&quot;);&#125;&#x2F;&#x2F;a.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常简单。加入我们要在Linux下编译运行，应该要怎么做</p><p>是的，在shell中使用gcc编译，生成一个可执行的二进制文件。直接执行这个文件就会显示“Hello Worrld”</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc a.c -o a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我要在Makefile里面编译这个a.c的代码，应该怎么写？</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a:a.cgcc a.c -o a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你查阅过和Makefile相关的资料，你可能会看到这段文字</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">target ... : prerequisites ...              command              ...              ...  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 你可以对照上面编译a.c的Makefile代码来看。</p><ul><li><p>target 也就是目标文件，可以是 Object File，也可以是执行文件（比如a.c生成的 a 可执行文件）。还可以是一个标签，标签本章暂不介绍，后续的博客再做介绍。 </p></li><li><p>prerequisites 就是，要生成那个 target 所需要的文件或是目标。 (a 可执行文件的生成需要依赖于 a.c)</p></li><li><p>command 也就是 make 需要执行的命令。（任意的 Shell 命令，比如调用gcc）</p></li></ul><p>而介绍完基本语句，我们就得回头来看一下make的工作方式。</p><h3 id="3-2-make的工作方式"><a href="#3-2-make的工作方式" class="headerlink" title="3.2 make的工作方式"></a>3.2 make的工作方式</h3><p>这段文字放在这里我认为才有便于理解</p><p>在默认的方式下，也就是我们只输入 make 命令。那么：</p><ol><li><p>make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。 </p></li><li><p>如果找到，它会找文件中的第一个目标文件（target）</p><p>比如下面这段Makefile，如果我们需要先把 *.c 文件先编译成 *.o 文件，而不是一步到位的编译成可执行文件，可以将上面<code>gcc a.c -o a</code>的步骤拆分成以下两句：</p></li></ol><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a:a.ogcc a.o -o aa.o:a.cgcc -c a.c -o a.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Makefile会先找到 “a” 这个目标，并把这个文件作为最终的目标文件。其余的各项依赖文件得写在后面，也就是我们的要介绍的：</p><ol start="3"><li><p>如果 a 这个文件不存在，或是 a 所依赖的后面的 [*.o] 文件的文件修改时间要比 a 这个文件新，那么，他就会执行后面所定义的命令，以此生成 a 这个文件。 </p></li><li><p>如果 a 所依赖的 *.o 文件也存在，那么 make 会在当前文件中找目标为 *.o 文件的依赖性，如果找到则再根据那一个规则生成 *.o 文件。（有点像一个堆栈的过程） </p></li><li><p>当然，你的 C 文件和 H 文件等等依赖文件是存在的，于是 make 会生成 *.o 文件，然后再用 *.o  文件完成make 的终极任务，也就是生成执行文件 a 了。</p></li></ol><p>并且和上一次的单个语句编译不同，我们同时还能获得 a.o 的文件</p><h3 id="3-3-多个文件编译"><a href="#3-3-多个文件编译" class="headerlink" title="3.3 多个文件编译"></a>3.3 多个文件编译</h3><p>你现在有一个大工程代码的main代码，是一个计算器，假设你是这样编写的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int mul(int, int);int main()&#123;int a &#x3D; 2, b &#x3D; 1;printf(&quot;%d+%d&#x3D;%d\n&quot;, a, b, add(a, b));printf(&quot;%d-%d&#x3D;%d\n&quot;, a, b, sub(a, b));printf(&quot;%d*%d&#x3D;%d\n&quot;, a, b, mul(a, b));return 0;&#125;&#x2F;&#x2F;main.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，加法，减法，乘法的函数写在其他的文件里面：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int add(int a, int b)&#123;return a + b;&#125;&#x2F;&#x2F;add.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sub(int a, int b)&#123;return a - b;&#125;&#x2F;&#x2F;sub.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int mul(int a, int b)&#123;return a*b&#125;&#x2F;&#x2F;mul.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时我们Makefile就可以这么写：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cal:main.o add.o sub.o mul.ogcc main.o add.o sub.o mul.o -o calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>其中 cal 文件需要<code>main.o add.o sub.o mul.o</code>，而我们各个 *.o 文件需要由各自的 *.c 文件编译而成。</p><p>记住上面这段makefile的样子。我们接下来会介绍很多种方法，简化上面这段makefile。</p><p>比如我们还可以写成这种形式，便于统一管理：</p></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.ocal:main.o add.o sub.o mul.ogcc main.o add.o sub.o mul.o -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果后续我需要加入一个除法功能，或者还要加入其他计算功能，就需要不断地重写Makefile，岂不是很麻烦，于是我们引入：</p><h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h3><p>在makefile中，变量声明的时候需要赋初值。使用的时候在变量名前面加上<code>$</code>号。用小括号或大括号括起来</p><p>(如果你要使用真实的“$”字符，那么你需要用 “$$” 来表示)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.oobjects&#x3D;main.o add.o sub.o mul.ocal:$(objects)gcc main.o add.o sub.o mul.o -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面这个例子，我们把<code>main.o add.o sub.o mul.o</code>全部放在<code>objects</code>变量底下，使用的时候就可以用<code>$(objects)</code>把里面存的各种变量拿来编译了。变量是可以嵌套使用的，比如：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x &#x3D; y y &#x3D; z a :&#x3D; $($(x))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里 :&#x3D; 是赋值的意思，另一种用变量来定义变量的方法，和 &#x3D; 的区别就是，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。这里的 a 里头存的就是 z 。</p><p>有了变量这个好东西，我们就可以使用：</p><h3 id="3-5-通配符"><a href="#3-5-通配符" class="headerlink" title="3.5 通配符"></a>3.5 通配符</h3><p>我们为了让Makefile自己找被我们更新过的代码，我们可以写成如下形式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src &#x3D; $(wildcard *.c)obj &#x3D; $(patsubst %.c, %.o, $(src))ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.ocal:$(obj)gcc $(obj) -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>wildcard</code>，纸牌游戏中的 “百搭牌” ，计算机里称为 “通配符” 。会在当前目录自己搜索所有匹配 <code>*.c</code>的文件。（如果你需要使用到路径，碍于篇幅，需要自行了解notdir参数，用法为<code>file=$(notdir $(src))</code>）</li><li><code>patsubst</code>，模式字符串替换函数。<ul><li>里面的<code>%</code>是匹配符，假如说我们有<code>main.c add.c sub.c mul.c</code>这几个文件，使用<code>%</code>可以像使用for循环一样，挨个文件名遍历进去<code>*.c</code>里</li><li>后面<code>$(src)</code>表示：希望<code>patsubst</code>可以遍历哪些文件。我们就遍历当前目录<code>$(src)</code>底下的 *.c 文件</li></ul></li></ul><h3 id="3-6-更多便捷的书写方式"><a href="#3-6-更多便捷的书写方式" class="headerlink" title="3.6 更多便捷的书写方式"></a>3.6 更多便捷的书写方式</h3><p>如果我还想更改代码的名称，就需要自己重写makefile，未免有点太麻烦了。如果可以自己去寻找这些文件就好了。所以我们对上面的代码更新了一下，引入自动化变量，功能不变，写成如下形式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src &#x3D; $(wildcard *.c)obj &#x3D; $(patsubst %.c, %.o, $(src))ALL:calmain.o:main.cgcc -c $&lt; -o $@add.o:add.cgcc -c $&lt; -o $@sub.o:sub.cgcc -c $&lt; -o $@mul.o:mul.cgcc -c $&lt; -o $@cal:$(obj)gcc $^ -o $@clean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">符号</th><th align="center">解释</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">$@</td><td align="center">表示要生成的目标文件</td><td align="center">main.o:main.c中的main.o</td></tr><tr><td align="center">$^</td><td align="center">表示全部的依赖文件</td><td align="center">cal:$(obj)中的整个$(obj)</td></tr><tr><td align="center">$&lt;</td><td align="center">表示第一个依赖文件</td><td align="center">main.o:main.c中第一个依赖，也就是main.c</td></tr></tbody></table><p>还有很多其他的自动化变量，如$+,$*,$?等等，不在本篇博客详细解释，感兴趣的话可以自行查阅相关资料</p><p>上面这段代码还可以进一步简化。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src &#x3D; $(wildcard *.c)obj &#x3D; $(patsubst %.c, %.o, $(src))ALL:cal$(obj):%.o:%.cgcc -c $&lt; -o $@cal:$(obj)gcc $^ -o $@clean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的小伙伴会发现这两段代码多出来一个目标<code>clean</code>，如果你希望重新make一遍工程，那就需要先把生成的各项文件删除。用<code>make clean</code>指令就可以自己声明清理函数</p><p>如果你在想，我们又不打算生成clean目标文件，有没有别的书写方案？答案是有的，就需要用到标签中的 “伪目标“ <code>.PHONY</code>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">.PHONY : clean clean : -rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。)</p><p>当然，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。 </p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p><h3 id="3-7-引用文件"><a href="#3-7-引用文件" class="headerlink" title="3.7 引用文件"></a>3.7 引用文件</h3><p>如果我们整个工程的头文件全都在别的文件夹，比如说在<code>./inc</code>目录底下，我们有<code>add.h  mul.h  sub.h</code>三个头文件，应该怎么引用进来呢？</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src &#x3D; $(wildcard *.c)obj &#x3D; $(patsubst %.c, %.o, $(src))ALL:cal$(obj):%.o:%.cgcc -c $&lt; -o $@ -I inccal:$(obj)gcc $^ -o $@ -I incclean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，我们使用<code>-I/</code>或者<code>--include-dir</code>参数，就可以指定头文件所在位置了</p><p>事实上，不只是头文件，有其他的makefile文件，也可以用这个参数导入。make 就会在这个参数所指定的目录下去寻找。如果目录prefix&#x2F;include（一般是：&#x2F;usr&#x2F;local&#x2F;bin 或&#x2F;usr&#x2F;include）存在的话，make 也会去找。</p><p>如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make 不理那些无法读取的文件，而继续执行，你可以像上面的<code>clean</code>目标一样，在 include 前加一个减号“-”。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站的第一篇博客</title>
      <link href="/2022/03/21/first/"/>
      <url>/2022/03/21/first/</url>
      
        <content type="html"><![CDATA[<h1 id="建站以来第一篇博客"><a href="#建站以来第一篇博客" class="headerlink" title="建站以来第一篇博客"></a>建站以来第一篇博客</h1><p>大家好，这里是拓佑豪的博客网站，也是我的第一篇博客。<br>这篇博客没什么营养，留个纪念，也是为了代码调试的时候，可以看看效果<br>就，在这里聊聊几句，简单立个flag。后续会在这个博客网站发布一些技术类文章</p><h1 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h1><p>几年前就有设计自己博客的想法。奈何当时我接触到这方面资讯太少，我就在<code>华为云博客</code>上发了几篇关于OpenCV和Atlas 200DK的文章。但发现对文章归类和修改等等方面我用着不是很习惯，主要也是因为我没坐下来好好整理资料写博客，遂停更了好长一段时间。直到前段时间接触到<code>hexo</code>，对静态网站有了大致的了解，就计划从现在开始积累自己的博客，把文章分门别类整理好，来维护好这个博客网站。</p><h1 id="When？什么时候开始写的？"><a href="#When？什么时候开始写的？" class="headerlink" title="When？什么时候开始写的？"></a>When？什么时候开始写的？</h1><p>也没多久，2021年才开始。不过写博客这个计划我会持续坚持下去</p><h1 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h1><p>本博客主要整理和计算机相关的博客，内容偏向于人工智能方面，细分下来各种类别的文章可能多少都会有点。</p><h1 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h1><p>我会从简单的技术内容开始写起，包括重新整理以前写过的OpenCV类博客，把一些我认为讲的不够清晰的内容再梳理一遍。主要内容还是面向人工智能领域。</p><h1 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h1><p>写博客其实还蛮花时间的，尤其是在任务量多起来的时候。金钱的话就没有开销了，托管在GitHub上，连域名都没买。等博客有了一定的时间、积累的一定量的文章，或许那个时候我会买个域名。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
