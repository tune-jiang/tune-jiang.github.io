<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统概述(第一部分)</title>
      <link href="/2022/04/05/operating_system1/"/>
      <url>/2022/04/05/operating_system1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统——第一章-系统概述"><a href="#操作系统——第一章-系统概述" class="headerlink" title="操作系统——第一章: 系统概述"></a>操作系统——第一章: 系统概述</h1><h2 id="1-1-基本概念（定义）"><a href="#1-1-基本概念（定义）" class="headerlink" title="1.1 基本概念（定义）"></a>1.1 基本概念（定义）</h2><ul><li>操作系统（operating system，os）是系统资源的<strong>管理者</strong>，管理<strong>软件、硬件资源</strong>，给用户和其他软件方便的接口和环境，是一个<strong>系统软件</strong>。</li></ul><h2 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2  操作系统特征"></a>1.2  操作系统特征</h2><h3 id="1-并发（concurrence）"><a href="#1-并发（concurrence）" class="headerlink" title="1. 并发（concurrence）"></a>1. 并发（concurrence）</h3><p>微观上交替进行，宏观上同时执行。（操作系统和程序并发是一起诞生的）</p><ul><li>重点：<ul><li>单核CPU：同一时刻只能执行一个程序，各个程序只能<strong>并发</strong>执行。</li><li>多核CPU：同一时刻可以同时执行多个程序，多个程序可以<strong>并行</strong>执行。</li></ul></li></ul><h3 id="2-共享（sharing）"><a href="#2-共享（sharing）" class="headerlink" title="2. 共享（sharing）"></a>2. 共享（sharing）</h3><p>系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>互斥：系统中某些资源，虽然可以给多进程使用，但一个时间段内只允许一个进程访问该资源。</p><p>同时：系统中某些资源，允许一个时间段内由多个进程 “同时” 对他们进行访问。（微观上可能是交替的）</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">&#123;% mermaid %&#125;graph LRA(两种资源共享方式) --&gt;B(互斥共享方式)B --&gt;C(一个时间段内只允许一个进程访问该资源)A --&gt;D(同时共享模式)D --&gt;E(一个时间段内由多个进程 同时 对他们进行访问)    F[sharing]&#123;% endmermaid %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：并发和共享是操作系统两个最基本特征，<strong>两者互为存在条件</strong>：</p><ol><li>资源共享是一程序并发为条件的。（若系统不允许程序并发执行，自然不存在资源共享问题）</li><li>若系统不能对资源共享进行有效管理，一定影响到程序的并发执行。</li></ol><h3 id="3-虚拟（virtual）"><a href="#3-虚拟（virtual）" class="headerlink" title="3. 虚拟（virtual）"></a>3. 虚拟（virtual）</h3><ul><li>可归纳为：<ul><li>时分复用技术：如处理器的分时共享（微观：处理机在微小时间段为各个进程服务，大时间分成小时间）</li><li>空分复用技术：如虚拟存储器</li></ul></li></ul><p>详见第三章</p><h3 id="4-异步（asynchronism）"><a href="#4-异步（asynchronism）" class="headerlink" title="4. 异步（asynchronism）"></a>4. 异步（asynchronism）</h3><p>并发的程序不是从头走到底的，是“走走停停”，如果进程正在占用资源，其他进程需要先被阻塞，等待资源释放。</p><h2 id="1-3-操作系统运行机制"><a href="#1-3-操作系统运行机制" class="headerlink" title="1.3 操作系统运行机制"></a>1.3 操作系统运行机制</h2><ul><li><p>实现操作系统，需要写<strong>内核程序</strong>，很多个内核程序组成**操作系统内核(kernel)**，简称内核，是整个操作系统最核心的部分。</p><ul><li>操作系统有个内核就足够了 (eg. Docker容器 -&gt; 仅需linux内核)</li><li>操作系统的功能未必都在内核中，如GUI图形化界面</li></ul></li><li><p>CPU设计的时候就划分了特权指令和非特权指令</p><ul><li>应用程序只能运行非特权指令（如加法减法）</li><li>内核程序可以运行特权指令（如内存清0指令，这条指令影响重大，只允许“管理者”——即操作系统内核来使用）。</li></ul></li><li><p>但是CPU运行的时候，只会把一条一条指令（二进制指令）送进去运行，怎么判断运行的程序是应用程序指令还是内核程序的指令？</p><p>此时我们把CPU划分成为两种状态，<strong>”内核态“</strong>，<strong>“用户态”</strong></p><ul><li><p>内核态：说明此时运行的是<code>内核程序</code>，<strong>可以执行特权指令</strong></p></li><li><p>用户态：说明此时运行的是<code>应用程序</code>，<strong>只能执行非特权指令</strong></p></li><li><p>CPU中的寄存器**程序状态字寄存器（PSW)**，其中有一个二进制位，1表示内核态，0表示用户态</p><p>当需要交换状态，修改PSW值即可</p></li></ul></li></ul><h2 id="1-4-中断和异常"><a href="#1-4-中断和异常" class="headerlink" title="1.4 中断和异常"></a>1.4 中断和异常</h2><ul><li>中断的作用：如果应用程序运行的时候，发生了中断，就会让cpu立即停止此时运行的应用程序，转而执行相应的内核程序。中断是让管理者（操作系统内核）夺回使用权的唯一途径，而中断，会使CPU由用户态转变为内核态</li></ul><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA(内核态 -&gt; 用户态) --&gt;B(用特权指令 修改PSW的值)C(用户态 -&gt; 内核态) --&gt;D(引发 中断 硬件自动完成 CPU状态转换过程 强行夺回CPU使用权)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>中断的类型：</p><ul><li><p>内中断（也叫做 <strong>异常</strong>）：与当前执行指令有关，中断信号来源于CPU内部</p><p>有时候应用程序想请求操作系统内核的服务，此时会执行一条<strong>特殊的指令——陷入指令</strong>。该指令会引发一个内部中断信号。应用程序主动吧使用权归还给操作系统，希望操作系统提供某项服务。（先传入所需的参数，再调用陷入指令）</p><ul><li>而<strong>系统调用</strong>就是利用陷入指令来完成</li><li><strong>陷入指令并不是特权指令</strong>,陷入指令在用户态执行，执行后立刻引发一个<strong>内中断</strong>，使CPU进入内核态。</li></ul><p>异常分三个种类：</p><ul><li><p>陷阱、陷入（trap）：</p><p>由陷入指令引发，是应用程序故意引发的</p></li><li><p>故障（fault）：</p><p>由错误条件引起，可能被内核程序修复。内核程序修复后会把CPU使用权还给应用程序，让他继续执行下去。如：缺页故障</p></li><li><p>终止（abort）：</p><p>由致命错误引起，内核程序无法修复，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0，非法使用特权指令</p></li></ul></li><li><p>外中断（狭义上统称 <strong>中断</strong>）：与当前执行指令无关，中断信号来源于CPU外部</p><p>例子：时钟中断。由时钟部件（在cpu的外部）发来中断信号，实现程序并发的重要前提。</p><p>​            io设备提供中断信号。这些中断信号让操作系统可以很好的调度各个进程。</p></li></ul></li><li><p>中断机制的基本原理：</p></li></ul><p>不同类型的中断信号，需要用不同的中断处理程序来处理。查询<strong>中断向量表</strong>，以此来找到相应的中断处理程序在内存中存放的位置。</p><p>显然，中断处理程序一定是在内核态的，需要运行在内核态（涉及计算机组成原理）</p><h2 id="1-5-系统调用"><a href="#1-5-系统调用" class="headerlink" title="1.5 系统调用"></a>1.5 系统调用</h2><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单好用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph TDA[应用程序] --&gt; system(系统调用)    A --&gt; |高级语言| C(c库函数)    C --&gt; system(系统调用)    system(系统调用) --&gt; operating[操作系统]    F[系统调用与库函数的区别]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA(系统调用 按功能分类) --&gt;B(设备管理 完成对设备的 请求&#x2F;释放&#x2F;启动 等功能)A --&gt;C(文件管理 完成对文件的 读&#x2F;写&#x2F;创建&#x2F;删除 等功能)A --&gt;D(进程控制 完成进程的 创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒 等功能)A --&gt;E(进程通信 完成进程之间的 消息传送&#x2F;信号传递 等功能)A --&gt;F(内存管理 完成内存的 分配&#x2F;回收 等功能)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*拓展链接：<a href="https://www.cnblogs.com/wanghuaijun/p/6548633.html">linux提供了哪些系统调用</a></p><ul><li><p>凡是与共享资源有关的操作（如存储分配、IO操作、文件管理等），都必须通过系统调用的方式向<strong>操作系统内核</strong>提出服务请求。由内核代为完成，保证系统的稳定性与安全性。（也防止用户非法操作）</p></li><li><p>总结：</p><ul><li><p>陷入指令是在用户态执行，执行陷入指令后立即引发一个内中断，使CPU进入内核态。</p></li><li><p>发出系统调用的请求是在用户态，而对系统调用的相应处理是在内核态下进行。</p></li><li><p>别名：<strong>内核态&#x3D;核心态&#x3D;管态</strong>    <strong>用户态&#x3D;目态</strong>  <strong>陷入指令&#x3D;trap指令&#x3D;访管指令</strong></p></li></ul></li></ul><h2 id="1-6-操作系统的体系结构"><a href="#1-6-操作系统的体系结构" class="headerlink" title="1.6 操作系统的体系结构"></a>1.6 操作系统的体系结构</h2><p>大致分为两点：</p><ul><li>大内核&#x2F;单内核&#x2F;宏内核 <ul><li>操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码量庞大，结构混乱，难以维护</li><li>典型的大内核操作系统：Linux、Unix</li></ul></li><li>微内核<ul><li>只把最基本的功能留在内核</li><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在内核态和用户态切换，容易降低CPU性能</li><li>典型的微内核操作系统：Windows NT</li></ul></li></ul><p>操作系统主要分两个板块：</p><ul><li><p>非内核功能：如GUI</p></li><li><p>内核功能：</p><ul><li><p>与硬件管理较紧密的模块</p><ul><li>时钟管理（利用时钟中断实现计时功能）</li><li>中断处理</li><li>原语（设备驱动、CPU切换等）<ul><li>是一种特殊程序</li><li>处于操作系统最底层，是最接近硬件的部分</li><li>这种程序具有原子性，运行必须一气呵成，不可被中断。</li><li>运行时间短，调用频繁</li></ul></li></ul></li><li><p>这些管理工作更多是对数据结构的操作，不会直接涉及硬件。</p><p>！把这部分功能也写进内核的内核叫大内核。反之，只有时钟，中断，原语的内核称之为微内核，其进程管理等等内容将运行在用户态，对性能有一定的影响。</p><ul><li>进程管理、存储器管理、设备管理等功能</li></ul></li><li><p>这些内核功能，必须运行在内核态</p></li><li><p>微内核相比大内核，CPU运行状态的转换（psw）的次数会变多。CPU运行状态的转换是有成本的，消耗不少时间。频繁转换运行状态会降低系统性能</p></li></ul></li><li><p>Ubuntu、centos的开发团队主要是实现了非内核功能，而内核功能都是用了Linux内核。</p></li></ul><h2 id="1-7-操作系统的发展与分类"><a href="#1-7-操作系统的发展与分类" class="headerlink" title="1.7 操作系统的发展与分类"></a>1.7 操作系统的发展与分类</h2><h3 id="1-手工操作阶段"><a href="#1-手工操作阶段" class="headerlink" title="1 手工操作阶段"></a>1 手工操作阶段</h3><ul><li><p>纸带机打孔</p></li><li><p>缺点：用户独占全集，人机速度矛盾（人需要很长时间写纸带代码，且一次只能由一名程序员使用计算机，不允许多人使用；而计算机很快就可以运行完纸带代码）导致资源利用率低。</p></li></ul><h3 id="2-单道批处理系统"><a href="#2-单道批处理系统" class="headerlink" title="2 单道批处理系统"></a>2 单道批处理系统</h3><ul><li>引入<strong>脱机输入&#x2F;输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序（操作系统的雏形）</strong>负责控制作业的输入输出，磁带读取熟读比纸带快很多</li><li>主要优点：缓解一定程度的人及速度矛盾，资源利用率有一定的提升</li><li>主要缺点：内存中仅能有一道程序运行，运行结束才能进行下一道（串行执行）。而<strong>CPU有大量的时间在空闲等待IO完成</strong>，资源利用率还是不高</li></ul><h3 id="3-多道批处理系统"><a href="#3-多道批处理系统" class="headerlink" title="3 多道批处理系统"></a>3 多道批处理系统</h3><ul><li><p>每次往内存中读取多道程序</p></li><li><p>操作系统正式诞生，支持多道程序并发运行</p></li><li><p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源，<strong>资源利用率大幅度提升</strong>，CPU和其他组员更能保持 “忙碌” 状态，系统吞吐量增大</p></li><li><p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业指挥就只能等待计算机处理完毕，中间不能控制自己的作业执行</p><p>如：无法调试程序，无法在程序运行中输入参数）</p></li></ul><h3 id="4-分时操作系统"><a href="#4-分时操作系统" class="headerlink" title="4 分时操作系统"></a>4 分时操作系统</h3><ul><li><p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可以通过终端与计算机进行交互</p></li><li><p>主要优点：用户请求可以被即时响应，<strong>解决人机交互的问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</p></li><li><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户&#x2F;作业都是公平的，循环地为每个用户&#x2F;作业服务一个时间片，不区分任务优先级&#x2F;紧急性。</p></li></ul><h3 id="5-实时操作系统"><a href="#5-实时操作系统" class="headerlink" title="5 实时操作系统"></a>5 实时操作系统</h3><ul><li><p>计算机接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p><ul><li>硬实时系统：必须在绝对严格的时间内完成任务<ul><li>如：自动驾驶系统</li></ul></li><li>软实时系统：能够接受偶尔的违反时间规定<ul><li>如：订票系统（实时更新票数）</li></ul></li></ul></li><li><p>主要优点：能够及时响应一些紧急任务，某些优先级高的任务不需要时间片排队。</p><h3 id="6-其他操作系统"><a href="#6-其他操作系统" class="headerlink" title="*6 其他操作系统"></a>*6 其他操作系统</h3></li><li><p>网络操作系统：实现网络中各种资源的共享（文件共享）和各个计算机之间的通信</p></li><li><p>分布式操作系统：特点是分布性、并行性，任何任务都可以分布在这些计算机上，并行协同地完成任务</p></li><li><p>个人操作系统：Windows、macOS等等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈搭建Matery的一些流程</title>
      <link href="/2022/04/02/build-matery/"/>
      <url>/2022/04/02/build-matery/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈搭建matery的一些流程"><a href="#浅谈搭建matery的一些流程" class="headerlink" title="浅谈搭建matery的一些流程"></a>浅谈搭建matery的一些流程</h1><p>好不容易完善了该matery，发现自己并没有记录如何真正搭建的流程。</p><p>乘着刚搭建不久，来记录一下搭建<code>hexo-theme-matery</code>的一些流程</p><h2 id="0，介绍开发环境"><a href="#0，介绍开发环境" class="headerlink" title="0，介绍开发环境"></a>0，介绍开发环境</h2><ul><li><p>长年未更新的老Win10，以及更新过的vscode</p></li><li><p>这里建议参考以下几个链接一起看</p><ul><li><a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></li><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/">https://godweiyang.com/2018/04/13/hexo-blog/</a></li><li><a href="https://www.matemaster.cn/posts/52745.html">https://www.matemaster.cn/posts/52745.html</a></li></ul></li></ul><h2 id="1，搭建node-js等等初步工作环境"><a href="#1，搭建node-js等等初步工作环境" class="headerlink" title="1，搭建node.js等等初步工作环境"></a>1，搭建node.js等等初步工作环境</h2><p>先去官网下载<a href="https://nodejs.org/en/">node.js</a>，选择稳定版即可</p><p><img src="https://s2.loli.net/2022/04/03/dOYo2q4nPvJhrcl.png"></p><p>一路默认安装即可。装完会有两个组件，一个是node.js本身，一个是npm组件。</p><ul><li>自己新建一个文件夹，以后的网页代码全放在里面，我的是在d:&#x2F;tuoyou-hao</li><li>用vscode打开这个文件夹（或者你用命令行 cd 进去 也可以），在vscode打开终端，输入以下指令</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">&gt; node -vv16.14.2&gt; npm -v8.5.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于npm下载速度较慢，我们可以选用淘宝的源下载。我们用npm下载cnpm：</p><p><code> &gt; npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>下载完成后，输入<code>cnpm -v</code>检查一下，输出下列内容即为正常</p><p><img src="https://s2.loli.net/2022/04/03/WDuRxhQiZV1w9IN.png"></p><p>然后我们开始安装hexo</p><pre class="line-numbers language-none"><code class="language-none">&gt; cnpm install -g hexo-cli &gt; hexo -vINFO  Validating confighexo: 6.1.0hexo-cli: 4.3.0os: win32 10.0.17134node: 16.14.2v8: 9.4.146.24-node.20uv: 1.43.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1n+quiccldr: 40.0icu: 70.1tz: 2021a3unicode: 14.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV# 显示如上内容，hexo就是正常的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个文件夹里面 <code>hexo init</code></p><p>hexo会为你生成很多文件，然后下载并配置一个默认主题（在theme文件夹）</p><p>配置完成后，命令行输入<code>hexo s</code>即可在本地localhost:4000看到hexo给你生成的网页</p><p>进入\source\_posts文件夹底下，就是存放你的博客的地方，使用markdown格式编写。</p><p>确认完毕以后，先去申请一个新的GitHub仓库</p><p>会让你填写自己GitHub的地址。此时需要申请自己的GitHub，并将仓库命名为&lt;你的GitHub名字&gt;.github.io</p><ul><li><p>比如我的GitHub名字叫tuoyou-hao，创建的新仓库就叫做“tuoyou-hao.github.io”。<strong>必须符合该命名格式</strong>！</p><p>创建完该仓库即可，无需进行其他操作</p></li><li><p>去配置GitHub的ssh key，建立ssh链接，具体步骤参考：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account</a></p></li></ul><p>配置完毕后，执行该指令，下载GitHub推送工具</p><p><code>cnpm install --save hexo-deployer-git</code></p><p>然后修改根目录下<code>_config.yml</code>里头的配置，找到deploy选修</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git  repository: git@github.com:xxx&#x2F;xxx.github.io.git #填你的仓库名  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行hexo指令。命令行常用以下指令：</p><pre class="line-numbers language-none"><code class="language-none">hexo clean #清理本地生成文件hexo g  # 生成博客网页文件hexo s  # 本地预览博客hexo d  # 上传网页文件到github<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>hexo d完毕以后，进入你xxx.gihub.io网站，即可查看到你部署的网页（会有几分钟的延迟）</p><h2 id="2，配置matery"><a href="#2，配置matery" class="headerlink" title="2，配置matery"></a>2，配置matery</h2><ul><li><p>git clone该链接到themes文件夹：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p></li><li><p>并把根目录下<code>_config.yml</code>文件里的theme参数改成你clone的文件夹名字（我自己重命名叫matery，theme参数也要叫matery）</p></li><li><p>在matery主题文件夹里面也有一个<code>_config.yml</code>文件，还有一个<code>README_CN.md</code>文件，请你一定要认真仔细看那份文件，需要根据那份文件下载各种依赖。下载完成后，根据自己的需要去配置</p></li><li><p>配置完成就发布到自己的GitHub仓库吧</p></li></ul><h2 id="3，百度推送"><a href="#3，百度推送" class="headerlink" title="3，百度推送"></a>3，百度推送</h2><p>在百度推送上，建议参考：<a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1</a></p><p>登录该网站：<a href="https://ziyuan.baidu.com/">https://ziyuan.baidu.com/</a></p><p>登录成功后，在用户中心-&gt;站点管理-&gt;添加网站操作 </p><p>然后如何寻找token呢，token&#x3D;秘钥：</p><p><img src="https://s2.loli.net/2022/04/03/j4m8YTUfV29Dei3.jpg"></p><p>其中matery内置了推送功能，我们只需要写好参数即可。</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git  repository: git@github.com:xxx&#x2F;xxx.github.io.git  branch: master- type: baidu_url_submitter #记得在deploy下配置这一句baidu_url_submit:  count: 20 # 提交最新的一个链接  host: https:&#x2F;&#x2F;xxx.github.io # 在百度资源搜索平台中注册的域名  token: xxxxxxx # 请注意这是推送秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4，-配置评论控件"><a href="#4，-配置评论控件" class="headerlink" title="4， 配置评论控件"></a>4， 配置评论控件</h2><p>首先，在matery底下，将js底下的twikoo更新至最新版</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">js:twikoo: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;twikoo&#x2F;dist&#x2F;twikoo.all.min.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参考链接：<a href="https://twikoo.js.org/quick-start.html#%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2">https://twikoo.js.org/quick-start.html#%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2</a></p><ol><li><p>申请 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDB (opens new window)</a>账号</p></li><li><p>创建免费 MongoDB 数据库，区域推荐选择 <code>AWS / N. Virginia (us-east-1)</code></p></li><li><p>在 Clusters 页面点击 CONNECT，按步骤设置允许所有 IP 地址的连接（<a href="https://vercel.com/support/articles/how-to-allowlist-deployment-ip-address">为什么？ (opens new window)</a>），创建数据库用户，选择connect，一定要选择链接您的应用，那个数据库连接字符串才是我们需要的，请将连接字符串中的 <code>password</code> 修改为数据库密码</p><p><img src="https://s2.loli.net/2022/04/03/kLJfdnUmFrqZleC.png"></p><p><img src="https://s2.loli.net/2022/04/03/jmieJ9aAYcXLISO.png"></p></li><li><p>申请 <a href="https://vercel.com/signup">Vercel (opens new window)</a>账号</p></li><li><p>进入以下网址把 Twikoo 一键部署到 Vercel<br><a href="https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/dev/src/vercel-min">https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/dev/src/vercel-min</a></p></li><li><p>进入 Settings - Environment Variables，添加环境变量 <code>MONGODB_URI</code>，值为第 3 步的数据库连接字符串</p></li><li><p>进入 Overview，点击 Domains 下方的链接，如果环境配置正确，可以看到 “Twikoo 云函数运行正常” 的提示</p></li><li><p>Vercel Domains（包含 <code>https://</code> 前缀，例如 <code>https://xxx.vercel.app</code>）整个网址即为您的环境 id</p></li><li><p>把网址贴进主题的_config.yml里头对应的twikoo的envId，并启用twikoo功能。</p></li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">twikoo:  enable: true  visitor: true  envId: https:&#x2F;&#x2F;xxxx.app #搭建教程：https:&#x2F;&#x2F;twikoo.js.org&#x2F;quick-start.html  # region: ap-guangzhou # 环境地域，默认为 ap-shanghai  path: &#39;window.location.pathname&#39; # 自定义文章路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5，-配置图像上传"><a href="#5，-配置图像上传" class="headerlink" title="5， 配置图像上传"></a>5， 配置图像上传</h2><p>在写本篇博客的时候，当我推送上来的时候，意外的发现文章的图片迟迟读取不了，测试过以下指令，反而本地localhost也读取不了了<br><code>cnpm install https://github.com/CodeFalling/hexo-asset-image –save</code></p><p>由于我并非前端工作者，对这方面知识还是比较匮乏，你们可以参考这个教程的解决方法：<br><a href="https://www.cnblogs.com/hugochen1024/p/12570656.html">https://www.cnblogs.com/hugochen1024/p/12570656.html</a></p><p>我自己是注册<code>SM.MS</code>网站，链接：<a href="https://sm.ms/">https://sm.ms/</a><br>在该网站上传图片，网站会给你一个链接，导入该链接的图片即可。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速入门Makefile(新手向)</title>
      <link href="/2022/03/31/Makefile-quick-get-start/"/>
      <url>/2022/03/31/Makefile-quick-get-start/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门Makefile-新手向"><a href="#快速入门Makefile-新手向" class="headerlink" title="快速入门Makefile(新手向)"></a>快速入门Makefile(新手向)</h1><h2 id="1、什么是Makefile"><a href="#1、什么是Makefile" class="headerlink" title="1、什么是Makefile"></a>1、什么是Makefile</h2><p>​        特别是在 Unix 下的软件编译，如果你正在开发一个大型的工程，你就不能不自己写Makefile了。</p><p>​        因为，Makefile关系到了整个代码工程的编译规则。一个工程中的源文件不计数，按类型、功能、模块分别放在若干个目录中，Makefile定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行其他更加复杂的操作。Makefile就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。</p><p>​        Makefile带来的好处就是——“自动化编译”，一旦你写好了Makefile，只需要一个<code>make </code>命令，整个工程就会完全自动编译，极大的提高了软件开发效率。</p><p>​        在我还刚接触Makefile的时候，我常常苦恼于找不到易读好懂的Makefile教程。本篇仅仅快速描述一个简单的Makefile应该是什么样子的，介绍一些基本的指令和语法，便于快速熟悉相关的指令。</p><h2 id="2、Makefile的一些基本规则"><a href="#2、Makefile的一些基本规则" class="headerlink" title="2、Makefile的一些基本规则"></a>2、Makefile的一些基本规则</h2><ul><li>本篇将以C语言的源码为基础，默认使用gcc编译器，需要有相关的前置知识</li></ul><p>make 命令执行时，需要一个Makefile文件，以告诉 make 命令需要怎么样的去编译和链接程序。 文件名只能用makefile、Makefile或者GNUmakefile 。最常用的是<code>makefile</code>、<code>Makefile</code>。</p><p>(如果你非要使用别的名字来命名Makefile，需要使用指令make后加参数<code>-f</code>&#x2F;<code>--file</code>，如 <code>make -f your_makefile_name.md</code> )</p><ul><li>Makefile 的基本规则。<ul><li>如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。 </li><li>如果这个工程的某几个 C 文件被修改，那么我们只会编译被修改的 C 文件，并链接目标程序。 </li><li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件， 并链接目标程序。</li></ul></li></ul><h2 id="3、Makefile编写"><a href="#3、Makefile编写" class="headerlink" title="3、Makefile编写"></a>3、Makefile编写</h2><h3 id="3-1-来写一个最简单的Makefile"><a href="#3-1-来写一个最简单的Makefile" class="headerlink" title="3.1 来写一个最简单的Makefile"></a>3.1 来写一个最简单的Makefile</h3><p>我们来看这一段代码<code>a.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void main()&#123;printf(&quot;Hello World\n&quot;);&#125;&#x2F;&#x2F;a.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常简单。加入我们要在Linux下编译运行，应该要怎么做</p><p>是的，在shell中使用gcc编译，生成一个可执行的二进制文件。直接执行这个文件就会显示“Hello Worrld”</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc a.c -o a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我要在Makefile里面编译这个a.c的代码，应该怎么写？</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a:a.cgcc a.c -o a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你查阅过和Makefile相关的资料，你可能会看到这段文字</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">target ... : prerequisites ...              command              ...              ...  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 你可以对照上面编译a.c的Makefile代码来看。</p><ul><li><p>target 也就是目标文件，可以是 Object File，也可以是执行文件（比如a.c生成的 a 可执行文件）。还可以是一个标签，标签本章暂不介绍，后续的博客再做介绍。 </p></li><li><p>prerequisites 就是，要生成那个 target 所需要的文件或是目标。 (a 可执行文件的生成需要依赖于 a.c)</p></li><li><p>command 也就是 make 需要执行的命令。（任意的 Shell 命令，比如调用gcc）</p></li></ul><p>而介绍完基本语句，我们就得回头来看一下make的工作方式。</p><h3 id="3-2-make的工作方式"><a href="#3-2-make的工作方式" class="headerlink" title="3.2 make的工作方式"></a>3.2 make的工作方式</h3><p>这段文字放在这里我认为才有便于理解</p><p>在默认的方式下，也就是我们只输入 make 命令。那么：</p><ol><li><p>make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。 </p></li><li><p>如果找到，它会找文件中的第一个目标文件（target）</p><p>比如下面这段Makefile，如果我们需要先把 *.c 文件先编译成 *.o 文件，而不是一步到位的编译成可执行文件，可以将上面<code>gcc a.c -o a</code>的步骤拆分成以下两句：</p></li></ol><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a:a.ogcc a.o -o aa.o:a.cgcc -c a.c -o a.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Makefile会先找到 “a” 这个目标，并把这个文件作为最终的目标文件。其余的各项依赖文件得写在后面，也就是我们的要介绍的：</p><ol start="3"><li><p>如果 a 这个文件不存在，或是 a 所依赖的后面的 [*.o] 文件的文件修改时间要比 a 这个文件新，那么，他就会执行后面所定义的命令，以此生成 a 这个文件。 </p></li><li><p>如果 a 所依赖的 *.o 文件也存在，那么 make 会在当前文件中找目标为 *.o 文件的依赖性，如果找到则再根据那一个规则生成 *.o 文件。（有点像一个堆栈的过程） </p></li><li><p>当然，你的 C 文件和 H 文件等等依赖文件是存在的，于是 make 会生成 *.o 文件，然后再用 *.o  文件完成make 的终极任务，也就是生成执行文件 a 了。</p></li></ol><p>并且和上一次的单个语句编译不同，我们同时还能获得 a.o 的文件</p><h3 id="3-3-多个文件编译"><a href="#3-3-多个文件编译" class="headerlink" title="3.3 多个文件编译"></a>3.3 多个文件编译</h3><p>你现在有一个大工程代码的main代码，是一个计算器，假设你是这样编写的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int mul(int, int);int main()&#123;int a &#x3D; 2, b &#x3D; 1;printf(&quot;%d+%d&#x3D;%d\n&quot;, a, b, add(a, b));printf(&quot;%d-%d&#x3D;%d\n&quot;, a, b, sub(a, b));printf(&quot;%d*%d&#x3D;%d\n&quot;, a, b, mul(a, b));return 0;&#125;&#x2F;&#x2F;main.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，加法，减法，乘法的函数写在其他的文件里面：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int add(int a, int b)&#123;return a + b;&#125;&#x2F;&#x2F;add.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sub(int a, int b)&#123;return a - b;&#125;&#x2F;&#x2F;sub.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int mul(int a, int b)&#123;return a*b&#125;&#x2F;&#x2F;mul.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时我们Makefile就可以这么写：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cal:main.o add.o sub.o mul.ogcc main.o add.o sub.o mul.o -o calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>其中 cal 文件需要<code>main.o add.o sub.o mul.o</code>，而我们各个 *.o 文件需要由各自的 *.c 文件编译而成。</p><p>记住上面这段makefile的样子。我们接下来会介绍很多种方法，简化上面这段makefile。</p><p>比如我们还可以写成这种形式，便于统一管理：</p></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.ocal:main.o add.o sub.o mul.ogcc main.o add.o sub.o mul.o -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果后续我需要加入一个除法功能，或者还要加入其他计算功能，就需要不断地重写Makefile，岂不是很麻烦，于是我们引入：</p><h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h3><p>在makefile中，变量声明的时候需要赋初值。使用的时候在变量名前面加上<code>$</code>号。用小括号或大括号括起来</p><p>(如果你要使用真实的“$”字符，那么你需要用 “$$” 来表示)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.oobjects&#x3D;main.o add.o sub.o mul.ocal:$(objects)gcc main.o add.o sub.o mul.o -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面这个例子，我们把<code>main.o add.o sub.o mul.o</code>全部放在<code>objects</code>变量底下，使用的时候就可以用<code>$(objects)</code>把里面存的各种变量拿来编译了。变量是可以嵌套使用的，比如：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x &#x3D; y y &#x3D; z a :&#x3D; $($(x))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里 :&#x3D; 是赋值的意思，另一种用变量来定义变量的方法，和 &#x3D; 的区别就是，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。这里的 a 里头存的就是 z 。</p><p>有了变量这个好东西，我们就可以使用：</p><h3 id="3-5-通配符"><a href="#3-5-通配符" class="headerlink" title="3.5 通配符"></a>3.5 通配符</h3><p>我们为了让Makefile自己找被我们更新过的代码，我们可以写成如下形式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src &#x3D; $(wildcard *.c)obj &#x3D; $(patsubst %.c, %.o, $(src))ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.ocal:$(obj)gcc $(obj) -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>wildcard</code>，纸牌游戏中的 “百搭牌” ，计算机里称为 “通配符” 。会在当前目录自己搜索所有匹配 <code>*.c</code>的文件。（如果你需要使用到路径，碍于篇幅，需要自行了解notdir参数，用法为<code>file=$(notdir $(src))</code>）</li><li><code>patsubst</code>，模式字符串替换函数。<ul><li>里面的<code>%</code>是匹配符，假如说我们有<code>main.c add.c sub.c mul.c</code>这几个文件，使用<code>%</code>可以像使用for循环一样，挨个文件名遍历进去<code>*.c</code>里</li><li>后面<code>$(src)</code>表示：希望<code>patsubst</code>可以遍历哪些文件。我们就遍历当前目录<code>$(src)</code>底下的 *.c 文件</li></ul></li></ul><h3 id="3-6-更多便捷的书写方式"><a href="#3-6-更多便捷的书写方式" class="headerlink" title="3.6 更多便捷的书写方式"></a>3.6 更多便捷的书写方式</h3><p>如果我还想更改代码的名称，就需要自己重写makefile，未免有点太麻烦了。如果可以自己去寻找这些文件就好了。所以我们对上面的代码更新了一下，引入自动化变量，功能不变，写成如下形式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src &#x3D; $(wildcard *.c)obj &#x3D; $(patsubst %.c, %.o, $(src))ALL:calmain.o:main.cgcc -c $&lt; -o $@add.o:add.cgcc -c $&lt; -o $@sub.o:sub.cgcc -c $&lt; -o $@mul.o:mul.cgcc -c $&lt; -o $@cal:$(obj)gcc $^ -o $@clean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">符号</th><th align="center">解释</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">$@</td><td align="center">表示要生成的目标文件</td><td align="center">main.o:main.c中的main.o</td></tr><tr><td align="center">$^</td><td align="center">表示全部的依赖文件</td><td align="center">cal:$(obj)中的整个$(obj)</td></tr><tr><td align="center">$&lt;</td><td align="center">表示第一个依赖文件</td><td align="center">main.o:main.c中第一个依赖，也就是main.c</td></tr></tbody></table><p>还有很多其他的自动化变量，如$+,$*,$?等等，不在本篇博客详细解释，感兴趣的话可以自行查阅相关资料</p><p>上面这段代码还可以进一步简化。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src &#x3D; $(wildcard *.c)obj &#x3D; $(patsubst %.c, %.o, $(src))ALL:cal$(obj):%.o:%.cgcc -c $&lt; -o $@cal:$(obj)gcc $^ -o $@clean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的小伙伴会发现这两段代码多出来一个目标<code>clean</code>，如果你希望重新make一遍工程，那就需要先把生成的各项文件删除。用<code>make clean</code>指令就可以自己声明清理函数</p><p>如果你在想，我们又不打算生成clean目标文件，有没有别的书写方案？答案是有的，就需要用到标签中的 “伪目标“ <code>.PHONY</code>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">.PHONY : clean clean : -rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。)</p><p>当然，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。 </p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p><h3 id="3-7-引用文件"><a href="#3-7-引用文件" class="headerlink" title="3.7 引用文件"></a>3.7 引用文件</h3><p>如果我们整个工程的头文件全都在别的文件夹，比如说在<code>./inc</code>目录底下，我们有<code>add.h  mul.h  sub.h</code>三个头文件，应该怎么引用进来呢？</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src &#x3D; $(wildcard *.c)obj &#x3D; $(patsubst %.c, %.o, $(src))ALL:cal$(obj):%.o:%.cgcc -c $&lt; -o $@ -I inccal:$(obj)gcc $^ -o $@ -I incclean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，我们使用<code>-I/</code>或者<code>--include-dir</code>参数，就可以指定头文件所在位置了</p><p>事实上，不只是头文件，有其他的makefile文件，也可以用这个参数导入。make 就会在这个参数所指定的目录下去寻找。如果目录prefix&#x2F;include（一般是：&#x2F;usr&#x2F;local&#x2F;bin 或&#x2F;usr&#x2F;include）存在的话，make 也会去找。</p><p>如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make 不理那些无法读取的文件，而继续执行，你可以像上面的<code>clean</code>目标一样，在 include 前加一个减号“-”。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站的第一篇博客</title>
      <link href="/2022/03/21/first/"/>
      <url>/2022/03/21/first/</url>
      
        <content type="html"><![CDATA[<h1 id="建站以来第一篇博客"><a href="#建站以来第一篇博客" class="headerlink" title="建站以来第一篇博客"></a>建站以来第一篇博客</h1><p>大家好，这里是拓佑豪的博客网站，也是我的第一篇博客。<br>这篇博客没什么营养，留个纪念，也是为了代码调试的时候，可以看看效果<br>就，在这里聊聊几句，简单立个flag。后续会在这个博客网站发布一些技术类文章</p><h1 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h1><p>几年前就有设计自己博客的想法。奈何当时我接触到这方面资讯太少，我就在<code>华为云博客</code>上发了几篇关于OpenCV和Atlas 200DK的文章。但发现对文章归类和修改等等方面我用着不是很习惯，主要也是因为我没坐下来好好整理资料写博客，遂停更了好长一段时间。直到前段时间接触到<code>hexo</code>，对静态网站有了大致的了解，就计划从现在开始积累自己的博客，把文章分门别类整理好，来维护好这个博客网站。</p><h1 id="When？什么时候开始写的？"><a href="#When？什么时候开始写的？" class="headerlink" title="When？什么时候开始写的？"></a>When？什么时候开始写的？</h1><p>也没多久，2021年才开始。不过写博客这个计划我会持续坚持下去</p><h1 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h1><p>本博客主要整理和计算机相关的博客，内容偏向于人工智能方面，细分下来各种类别的文章可能多少都会有点。</p><h1 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h1><p>我会从简单的技术内容开始写起，包括重新整理以前写过的OpenCV类博客，把一些我认为讲的不够清晰的内容再梳理一遍。主要内容还是面向人工智能领域。</p><h1 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h1><p>写博客其实还蛮花时间的，尤其是在任务量多起来的时候。金钱的话就没有开销了，托管在GitHub上，连域名都没买。等博客有了一定的时间、积累的一定量的文章，或许那个时候我会买个域名。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
