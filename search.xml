<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在Win11配置WSL</title>
      <link href="/2022/07/15/wsl_init_Win11/"/>
      <url>/2022/07/15/wsl_init_Win11/</url>
      
        <content type="html"><![CDATA[<h1 id="Win11配置WSL"><a href="#Win11配置WSL" class="headerlink" title="Win11配置WSL"></a>Win11配置WSL</h1><blockquote><p>前言废话：</p><p>在电脑上需要LINUX开发的时候，由于虚拟机无法直接连接到电脑主机的显卡，无法在LINUX上进行CUDA编程。所以如果需要在该电脑进行LINUX的CUDA开发，配置一个wsl就显得十分重要。</p><p>本次配置是在一台（刚装过vs c++和CUDA的）全新的电脑上配置的，系统是win11。</p></blockquote><h2 id="1、电脑系统内的配置"><a href="#1、电脑系统内的配置" class="headerlink" title="1、电脑系统内的配置"></a>1、电脑系统内的配置</h2><p>有两种方法，大同小异，可自行选择<strong>其中一种方案</strong></p><h3 id="1-1-用控制面板"><a href="#1-1-用控制面板" class="headerlink" title="1.1 用控制面板"></a>1.1 用控制面板</h3><p>在 <code>控制面板-&gt;程序-&gt;启用或关闭 windows 功能</code> 中，开启 Windows 虚拟化、 Linux 子系统（WSL2)、Hyper-V </p><p><img src="https://s2.loli.net/2022/07/15/9KFs4paNYw8TS1n.png" alt="控制面板"></p><p><img src="https://s2.loli.net/2022/07/15/HpAB2xD8QvhJPVz.png" alt="勾选画框的部分"></p><p><strong>用管理员身份打开powershell</strong>，输入以下指令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">bcdedit /set hypervisorlaunchtype auto<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-用命令行"><a href="#1-2-用命令行" class="headerlink" title="1.2 用命令行"></a>1.2 用命令行</h3><p><strong>用管理员身份打开powershell</strong>，<code>分别</code>输入以下的指令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">bcdedit /set hypervisorlaunchtype AutoEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -AllEnable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform #需要重启系统，请注意按y让他重启Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果以上内容不能顺利运行，可以执行以下的指令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、下载linux子操作系统"><a href="#2、下载linux子操作系统" class="headerlink" title="2、下载linux子操作系统"></a>2、下载linux子操作系统</h2><p>打开<code>Microsoft Store</code>，里面有很多不同的linux操作系统，有debain，Ubuntu、kali等等，在搜索框输入自己需要的操作系统名，选择下载即可，这里使用大家都爱用的Ubuntu，版本20.04。</p><p><img src="https://s2.loli.net/2022/07/15/7dst9pbEokK8Pje.png" alt="选择需要的系统即可"></p><p>下载完成后，在<code>cmd</code>或者<code>powershell</code>输入<code>wsl</code>即可。初始化会让你注册用户名，设定密码等等。如果你一路操作下来都很顺利，本次安装到此结束。</p><p><strong>如果你出现了报错，希望在第四部分，我的踩坑解决方案可以帮助到你</strong></p><h2 id="3、查看子系统的文件"><a href="#3、查看子系统的文件" class="headerlink" title="3、查看子系统的文件"></a>3、查看子系统的文件</h2><p>使用<kbd>Win</kbd>+<kbd>r</kbd>调出运行界面框，输入<code>\\wsl$</code>即可打开wsl的文件管理器。</p><p>但我们的运行界面有时候要用别的功能，自然会希望可以在 “此电脑” 界面中直接可以打开了</p><p>我们用上面的方法打开目录后，点选上面的路径复制下来</p><p><img src="https://s2.loli.net/2022/07/15/DMaisbvZyXehnEQ.png" alt="复制wsl的路径"></p><p>然后返回此电脑的界面，右键菜单栏选择<code>添加一个网络位置</code></p><p><img src="https://s2.loli.net/2022/07/15/GrPVDuomldXac6h.png" alt="此电脑中右键菜单栏"></p><p>一路点选 “下一页”，然后他要你填写网络位置的时候，把刚刚的路径粘贴进去，点选 “下一页”继续。</p><p>然后就可以在此电脑界面中直接查看wsl文件了。</p><h2 id="4、踩坑记录"><a href="#4、踩坑记录" class="headerlink" title="4、踩坑记录"></a>4、踩坑记录</h2><p>我出现的报错内容大致如下：</p><p><img src="https://s2.loli.net/2022/07/15/CWFAgBcvGlOtbxu.png"></p><p>并且我初步配置的时候，是没有功能<code>Hyper-V </code>的，而且运行下面这条指令的话，会报错<strong>功能名称 Microsoft-Hyper-V 未知。</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-1-解决Microsoft-Hyper-V不存在"><a href="#4-1-解决Microsoft-Hyper-V不存在" class="headerlink" title="4.1 解决Microsoft-Hyper-V不存在"></a>4.1 解决Microsoft-Hyper-V不存在</h3><p>首先在电脑新建一个txt文件，把以下内容贴进去</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pushd "%~dp0"dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后保存，文件后缀名改成<code>.cmd</code>格式，然后运行他。</p><p>运行完毕，重新在管理员权限下的powershell中运行刚刚的Microsoft-Hyper-V指令即可</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-解决wsl启动时出现一堆？？？的问题"><a href="#4-2-解决wsl启动时出现一堆？？？的问题" class="headerlink" title="4.2 解决wsl启动时出现一堆？？？的问题"></a>4.2 解决wsl启动时出现一堆？？？的问题</h3><p>首先下载Windows Subsystem for Linux Update setup 官方版将WSL1升级到WSL2。</p><p>下载地址1：<a href="https://www.xitongzhijia.net/soft/244754.html">https://www.xitongzhijia.net/soft/244754.html</a> </p><p>下载地址2：<a href="https://www.aliyundrive.com/s/F297Y6SNpSf">https://www.aliyundrive.com/s/F297Y6SNpSf</a></p><p>下载完毕执行一下该msi程序。</p><p>然后重新跑一下以下代码：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">bcdedit /set hypervisorlaunchtype AutoEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -AllEnable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform #需要重启系统，请注意按y让他重启Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我在完成到这一步就解决问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 二、基本工具</title>
      <link href="/2022/07/13/ros-2-Basic-command-tools/"/>
      <url>/2022/07/13/ros-2-Basic-command-tools/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS-二：基本的命令行工具"><a href="#ROS-二：基本的命令行工具" class="headerlink" title="ROS 二：基本的命令行工具"></a>ROS 二：基本的命令行工具</h1><h2 id="一、启动ros小海龟仿真环境"><a href="#一、启动ros小海龟仿真环境" class="headerlink" title="一、启动ros小海龟仿真环境"></a>一、启动ros小海龟仿真环境</h2><p>我们打开linux的命令行，使用<code>roscore</code>先启动ROS Master</p><p>打开新的终端，使用<code>rosrun turtlesim turtlesim_node</code>，启动小海龟的界面（需要在linux图形化界面启动，命令行界面启动不了）</p><p>再打开一个新的终端，使用<code>rosrun turtlesim turtle_teleop_key</code>（可以使用键盘控制小海龟移动了）</p><ul><li>本篇基本指令都围绕海龟仿真器这项服务举例说明，其他功能大同小异</li></ul><img src="https://s2.loli.net/2022/07/11/G8vxbJjKug367XE.png" alt="turtlesim" style="zoom:60%;"><h2 id="二、ROS常用命令"><a href="#二、ROS常用命令" class="headerlink" title="二、ROS常用命令"></a>二、ROS常用命令</h2><p><img src="https://s2.loli.net/2022/07/11/hbjFekIxfODqS3E.png"></p><p><a href="http://www.clearpathrobotics.com/ros-cheat-sheet">高清链接</a></p><h3 id="2-1-rqt-graph"><a href="#2-1-rqt-graph" class="headerlink" title="2.1 rqt_graph"></a>2.1 rqt_graph</h3><p>ROS里面有一系列以<code>rqt</code>开头的工具，都是一些基于qt的可视化工具，可以直观地展示各种信息</p><p><img src="https://s2.loli.net/2022/07/11/LtdWq9euvbYGfAm.png" alt="rqt_graph"></p><p><code>rqt_graph</code>使用来显示系统的计算图的工具。对计算图不明白的可以看<a href="https://tuoyou-hao.github.io/2022/07/11/ros-1-Core-concepts/">ros计算图简介</a>。通过观察计算图可以观察整个系统的全貌。</p><p>从上图我们可以看到，上面有两个节点，<code>turtlesim</code>是我们小乌龟的节点，<code>teleop_turtle</code>是键盘的节点。<code>cmd_vel</code>节点之间通讯的话题。</p><h3 id="2-2-rosnode"><a href="#2-2-rosnode" class="headerlink" title="2.2 rosnode"></a>2.2 rosnode</h3><p>显示系统中所有节点线管信息的指令。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosnode is a command-line tool for printing information about ROS Nodes.Commands:        rosnode ping    test connectivity to node        rosnode list    list active nodes        rosnode info    print information about node        rosnode machine list nodes running on a particular machine or list machines        rosnode kill    kill a running node        rosnode cleanup purge registration information of unreachable nodes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>命令</th><th>详细说明</th></tr></thead><tbody><tr><td>rosnode ping [节点名]</td><td>测试链接指定节点</td></tr><tr><td>rosnode list</td><td>查看活动的节点列表</td></tr><tr><td>rosnode info [节点名]</td><td>查看指定节点的信息</td></tr><tr><td>rosnode machine [PC名称或IP]</td><td>查看该PC中运行的节点列表</td></tr><tr><td>rosnode kill [节点名]</td><td>停止指定节点的运行</td></tr><tr><td>rosnode cleanup</td><td>删除失连节点的注册信息</td></tr></tbody></table><p>这里只展示个别指令</p><h4 id="1、rosnode-list"><a href="#1、rosnode-list" class="headerlink" title="1、rosnode list"></a>1、rosnode list</h4><p>查看话题列表，把所有节点都列出来</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/rosout#启动roscore就会启动，获取ros日志信息/teleop_turtle/turtlesim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>rosout是在rqt里面不会显示的内容。只要启动roscore就会启动的一个话题，主要用于获取ros日志信息，提交给界面做显示，是ros默认的一个话题。</li></ul><h4 id="2、rosnode-info"><a href="#2、rosnode-info" class="headerlink" title="2、rosnode info"></a>2、rosnode info</h4><p>会展示对应节点的具体信息，语法是</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosnode info /节点名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如我启动<code>rosnode info /turtlesim</code>，会显示如下内容</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">--------------------------------------------------------------------------------Node [/turtlesim]Publications: #正在发布那些话题 * /rosout [rosgraph_msgs/Log] * /turtle1/color_sensor [turtlesim/Color] * /turtle1/pose [turtlesim/Pose]Subscriptions: #在订阅哪些话题 * /turtle1/cmd_vel [geometry_msgs/Twist]#读取键盘输入，移动小海龟Services: #提供的服务，可以用来完成一些配置 * /clear * /kill * /reset * /spawn * /turtle1/set_pen * /turtle1/teleport_absolute * /turtle1/teleport_relative * /turtlesim/get_loggers * /turtlesim/set_logger_level# 底层通信机制的相关信息contacting node http://huanyu-PC:39579/ ...Pid: 3914Connections: * topic: /rosout    * to: /rosout    * direction: outbound (52933 - 127.0.0.1:48044) [26]    * transport: TCPROS * topic: /turtle1/cmd_vel    * to: /teleop_turtle (http://huanyu-PC:38639/)    * direction: inbound (34866 - huanyu-PC:43907) [54]    * transport: TCPROS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3、rostopic"><a href="#2-3、rostopic" class="headerlink" title="2.3、rostopic"></a>2.3、rostopic</h3><p>会输出ros话题相关的信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rostopic is a command-line tool for printing information about ROS Topics.Commands:        rostopic bw     display bandwidth used by topic        rostopic delay  display delay of topic from timestamp in header        rostopic echo   print messages to screen        rostopic find   find topics by type        rostopic hz     display publishing rate of topic            rostopic info   print information about active topic        rostopic list   list active topics        rostopic pub    publish data to topic        rostopic type   print topic or field type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>命令</th><th>详细说明</th></tr></thead><tbody><tr><td>rostopic bw [话题名称]</td><td>显示指定话题的消息带宽（bandwidth）</td></tr><tr><td>rostopic delay [话题名称]</td><td>显示header中时间戳的延迟</td></tr><tr><td>rostopic echo [话题名称]</td><td>实时显示指定话题的消息内容</td></tr><tr><td>rostopic find [类型名称]</td><td>显示使用指定类型的消息的话题</td></tr><tr><td>rostopic type [话题名称]</td><td>显示指定话题的消息类型</td></tr><tr><td>rostopic hz [话题名称]</td><td>显示指定话题的消息数据发布周期</td></tr><tr><td>rostopic info [话题名称]</td><td>显示指定话题的信息</td></tr><tr><td>rostopic list</td><td>显示活动的话题目录</td></tr><tr><td>rostopic pub [话题名称] [消息类型] [参数]</td><td>在命令行，用指定的话题名称发布消息</td></tr><tr><td>rostopic type [话题名称]</td><td>打印主题或字段类型</td></tr></tbody></table><h4 id="1、rostopic-pub-发布话题消息"><a href="#1、rostopic-pub-发布话题消息" class="headerlink" title="1、rostopic pub 发布话题消息"></a>1、rostopic pub 发布话题消息</h4><p>在命令行配合<kbd>Tab</kbd>键，可以自动给你补全指令</p><p>我们在命令行发布<strong>一次</strong>消息给<code>turtlesim</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist "linear:  x: 2.0  y: 3.0  z: 5.0angular:  x: 7.0  y: 9.0  z: 11.0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 它就会自己跑<strong>一次</strong>上述的运动（因为pub只发布了一次消息）。linear是线速度，angular是角速度。</p><p>要想它循环发布，就需要加个频率参数<code>-r</code>，后面跟一个uint数，表示一秒发布几次。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist "linear:  x: 2.0  y: 3.0  z: 5.0angular:  x: 7.0  y: 9.0  z: 11.0" #每秒跑10次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4、rosmsg"><a href="#2-4、rosmsg" class="headerlink" title="2.4、rosmsg"></a>2.4、rosmsg</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosmsg is a command-line tool for displaying information about ROS Message types.Commands:        rosmsg show     Show message description        rosmsg info     Alias for rosmsg show        rosmsg list     List all messages        rosmsg md5      Display message md5sum        rosmsg package  List messages in a package        rosmsg packages List packages that contain messages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>命令</th><th>详细说明</th></tr></thead><tbody><tr><td>rosmsg show [消息名称]</td><td>显示消息的描述</td></tr><tr><td>rosmsg info [消息名称]</td><td>显示消息的信息</td></tr><tr><td>rosmsg list</td><td>列出所有消息</td></tr><tr><td>rosmsg md5 [消息名称]</td><td>显示 md5 加密后的消息</td></tr><tr><td>rosmsg package [消息名称]</td><td>显示某个功能包下的所有消息</td></tr><tr><td>rosmsg packages</td><td>列出包含消息的功能包</td></tr></tbody></table><p>比如我想打印<code>turtlesim</code>的消息数据结构，就按照如下指令：</p><p><code>rosmsg show geometry_msgs/Twist</code></p><p>会显示如下内容：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">geometry_msgs/Vector3 linear  float64 x  float64 y  float64 zgeometry_msgs/Vector3 angular  float64 x  float64 y  float64 z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5、rosservice"><a href="#2-5、rosservice" class="headerlink" title="2.5、rosservice"></a>2.5、rosservice</h3><p>命令行作为ros的 “客户端”，需要发送服务请求给这个海龟仿真器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Commands:        rosservice args print service arguments        rosservice call call the service with the provided args        rosservice find find services by service type        rosservice info print information about service        rosservice list list active services        rosservice type print service type        rosservice uri  print service ROSRPC uri<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>命令</th><th>详细说明</th></tr></thead><tbody><tr><td>rosservice args [服务名称]</td><td>打印服务参数</td></tr><tr><td>rosservice call [服务名称]</td><td>使用所提供的args调用服务</td></tr><tr><td>rosservice find [服务名称]</td><td>按服务类型查找服务</td></tr><tr><td>rosservice info [服务名称]</td><td>打印服务信息</td></tr><tr><td>rosservice list</td><td>显示服务列表</td></tr><tr><td>rosservice type [服务名称]</td><td>打印服务类型</td></tr><tr><td>rosservice uri [服务名称]</td><td>打印服务ROSRPC uri</td></tr></tbody></table><h4 id="1、rosservice-call-发布服务请求"><a href="#1、rosservice-call-发布服务请求" class="headerlink" title="1、rosservice call 发布服务请求"></a>1、rosservice call 发布服务请求</h4><p>比如我使用<code>rosservice list</code>查询<code>turtlesim</code>的服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/clear/kill/reset/rosout/get_loggers/rosout/set_logger_level/spawn#新建小海龟/teleop_turtle/get_loggers/teleop_turtle/set_logger_level/turtle1/set_pen/turtle1/teleport_absolute/turtle1/teleport_relative/turtlesim/get_loggers/turtlesim/set_logger_level<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<kbd>Tab</kbd>键辅助输入：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosservice call /spawn "x: 1.0 y: 1.0theta: 0.0name: 'turtle2'"   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即可成功调用服务，获得一只新的海龟。并返回值<code>name: "turtle2"</code></p><p>此时使用<code>rostopic list</code>就可以看到以下的输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/rosout/rosout_agg/turtle1/cmd_vel/turtle1/color_sensor/turtle1/pose/turtle2/cmd_vel/turtle2/color_sensor/turtle2/pose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到两个海龟的topic，并且可以用指令分开调用不同海龟。</p><h3 id="2-6-rosbag"><a href="#2-6-rosbag" class="headerlink" title="2.6 rosbag"></a>2.6 rosbag</h3><p>可以记录话题数据并保存下来</p><p>如果下次需要调用的时候可以直接复现出来之前保存到整个记录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Usage: rosbag &lt;subcommand&gt; [options] [args]A bag is a file format in ROS for storing ROS message data. The rosbag command can record, replay and manipulate bags.Available subcommands:   check        Determine whether a bag is playable in the current system, or if it can be migrated.   compress     Compress one or more bag files.   decompress   Decompress one or more bag files.   decrypt      Decrypt one or more bag files.   encrypt      Encrypt one or more bag files.   filter       Filter the contents of the bag.   fix          Repair the messages in a bag file so that it can be played in the current system.   help     info         Summarize the contents of one or more bag files.   play         Play back the contents of one or more bag files in a time-synchronized fashion.   record       Record a bag file with the contents of specified topics.   reindex      Reindexes one or more bag files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1、rosbag-record-话题记录"><a href="#1、rosbag-record-话题记录" class="headerlink" title="1、rosbag record 话题记录"></a>1、rosbag record 话题记录</h4><p><code>rosbag record -a -O cmd_record</code></p><p>系统会在当前目录下生成一个<code>cmd_record.bag</code>文件</p><ul><li><code>-a</code>是指把所有的话题都记录下来</li><li><code>-O</code>是指保存成一个<code>*.bag</code>文件，后面要跟上文件名</li></ul><p>当我们记录完毕之后，ctrl+c结束即可。</p><p>具体的其他参数介绍如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Usage: rosbag record TOPIC1 [TOPIC2 TOPIC3 ...]Record a bag file with the contents of specified topics.Options:  -h, --help            show this help message and exit  -a, --all             record all topics  -e, --regex           match topics using regular expressions  -p, --publish         publish a msg when the record begin  -x EXCLUDE_REGEX, --exclude=EXCLUDE_REGEX                        exclude topics matching the follow regular expression                        (subtracts from -a or regex)  -q, --quiet           suppress console output  -o PREFIX, --output-prefix=PREFIX                        prepend PREFIX to beginning of bag name (name will                        always end with date stamp)  -O NAME, --output-name=NAME                        record to bag with name NAME.bag  --split               split the bag when maximum size or duration is reached  --max-splits=MAX_SPLITS                        Keep a maximum of N bag files, when reaching the                        maximum erase the oldest one to keep a constant number                        of files.  --size=SIZE           record a bag of maximum size SIZE MB. (Default:                        infinite)  --duration=DURATION   record a bag of maximum duration DURATION in seconds,                        unless 'm', or 'h' is appended.  -b SIZE, --buffsize=SIZE                        use an internal buffer of SIZE MB (Default: 256, 0 =                        infinite)  --chunksize=SIZE      Advanced. Record to chunks of SIZE KB (Default: 768)  -l NUM, --limit=NUM   only record NUM messages on each topic  --node=NODE           record all topics subscribed to by a specific node  -j, --bz2             use BZ2 compression  --lz4                 use LZ4 compression  --tcpnodelay          Use the TCP_NODELAY transport hint when subscribing to                        topics.  --udp                 Use the UDP transport hint when subscribing to topics.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、rosbag-play-话题复现"><a href="#2、rosbag-play-话题复现" class="headerlink" title="2、rosbag play 话题复现"></a>2、rosbag play 话题复现</h4><p>记录完成后，用<code>rosbag play</code> 语句调用保存好的<code>*.bag</code>文件，即可复现之前记录的信息。</p><p><code>rosbag play cmd_record.bag</code></p><p>就可以在海龟仿真器看到之前记录的所有指令。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 一、核心概念</title>
      <link href="/2022/07/11/ros-1-Core-concepts/"/>
      <url>/2022/07/11/ros-1-Core-concepts/</url>
      
        <content type="html"><![CDATA[<h1>ROS 一：核心概念</h1><p>ros提供了一种松耦合分布式通信框架。这些框架可以抽象成一个节点图。</p><p>每一个功能都可以是一个节点，比如一个图像采集功能为一个节点、图像检测又是一个节点、slam导航功能也放在一个节点。**每一个具体的功能都是一个节点。**我们用一个椭圆形代表一个节点。</p><p>每个节点通过通讯连接，互相传输数据。我们用箭头表示桐乡数据的流向。</p><ul><li>由节点（椭圆形）和通讯的方向（椭圆形上的箭头）构成ros的<strong>计算图</strong>。</li></ul><p><img src="https://s2.loli.net/2022/07/09/XxaCtYVNp2WglAy.png" alt="计算图"></p><p>如下图，每一个node节点就是机器人完成某一个具体功能的进程</p><p><img src="https://s2.loli.net/2022/07/09/kHO5FbGp1zUIr36.png" alt=""></p><p>每一个node的编程语言可以是不一样的。比如可以使用python，c++等。只要有统一的通讯标准就可以完成整个机器人系统的搭建。</p><h2 id="1、节点与节点管理器">1、节点与节点管理器</h2><ul><li><p>节点（node）——执行单元</p><ul><li>是执行具体任务的<strong>进程</strong>，是独立的可执行文件。</li><li>不同节点可以使用不同的编程语言（常用python或c++），可以分布式运行在不同的主机。</li><li>节点在系统中的名称必须是唯一的。</li></ul></li><li><p>节点管理器（ROS Master）——控制中心</p><ul><li><p>为各个节点提供命名、注册服务。</p></li><li><p>跟踪、记录话题或者服务通信，辅助节点相互查找，建立连接，帮助各个节点之间传输数据。</p><p>节点之间互相不知道彼此之间的存在，都需要ROS Master来帮忙建立连接。</p></li><li><p>提供参数服务器，节点使用此服务器来存储、检索运行时的参数。（可以理解为全局的对象字典，会记录一些全局变量，给各个节点提供服务）</p></li></ul></li></ul><h2 id="2、话题通信">2、话题通信</h2><p>以下是ros通信的两种方式：</p><h3 id="2-1-话题（topic）——异步通信机制">2.1 话题（topic）——异步通信机制</h3><ul><li>节点之间用来传输数据的<strong>重要总线</strong>，是传输的<strong>管道</strong>。</li><li>使用<strong>发布/订阅</strong>模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以是不唯一的。</li><li>如下图，发布者（publisher）给订阅者（subscriber）的通讯是<strong>单向的数据传输</strong>。而通讯的通道就是<strong>话题（Topic）</strong>。</li></ul><p><img src="https://s2.loli.net/2022/07/09/kxgYaKVDbf85IhG.png" alt="话题模型（发布/订阅）"></p><ul><li>消息（message）——话题里头的 “数据”<ul><li>描述传输数据的详细定义就是消息。</li><li>具有一定的类型和数据结构，包括ROS提供的标准类型和用户自定义的类型</li><li>使用编程语言无关的<code>.msg</code>文件来定义消息，编译过程中会生成对应的代码文件。</li></ul></li><li>区分：<ul><li>话题：传输数据的管道。</li><li>消息：传输数据的详细定义。</li></ul></li></ul><blockquote><p>eg:</p><p><img src="https://s2.loli.net/2022/07/09/SpJtixCVerRqy5P.png" alt=""></p><p>在上图中，摄像头把获取到的数据给<code>CameraNode</code>，<code>CameraNode</code>把这些画面发布出去。</p><p><code>Image Processing Node</code>要处理图像数据，使用需要订阅<code>CameraNode</code>发布的数据。</p><p>在笔记本电脑（Laptop）区，笔记本电脑想要显示图像，<code>Image Display Node</code>也就需要订阅这个图像数据</p><p>所以在上图模型中：</p><ul><li>有一个图像数据Publisher，两个图像数据Subscriber，一个Topic（Image data Message），传输图像数据消息。</li></ul></blockquote><h3 id="2-2-服务（service）——同步通信机制">2.2 服务（service）——同步通信机制</h3><ul><li><p>使用客户端/服务器（C/S）模型，客户端发送请求数据，服务器完成处理后，返回应答数据。</p><p>是双向的数据传输</p></li><li><p>使用编程语言无关的<code>.srv</code>文件定义请求和应答数据结构，编译过程中生成对应的代码文件。</p></li></ul><img src="https://s2.loli.net/2022/07/09/1p7cytkFEh4RMAw.png" alt="ros-1-4.png" style="zoom:50%;"><h3 id="2-3-话题与服务的区别">2.3 话题与服务的区别</h3><table><thead><tr><th></th><th style="text-align:center">话题</th><th style="text-align:center">服务</th></tr></thead><tbody><tr><td>同步性</td><td style="text-align:center">异步</td><td style="text-align:center">同步</td></tr><tr><td>通信模型</td><td style="text-align:center">发布/订阅</td><td style="text-align:center">客户端/服务器</td></tr><tr><td>底层协议</td><td style="text-align:center">ROS TCP/ROS UDP</td><td style="text-align:center">ROS TCP/ROS UDP</td></tr><tr><td>反馈机制</td><td style="text-align:center">无</td><td style="text-align:center">有</td></tr><tr><td>缓冲区</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td>实时性</td><td style="text-align:center">弱</td><td style="text-align:center">强</td></tr><tr><td>节点关系</td><td style="text-align:center">多对多</td><td style="text-align:center">一对多（一个server）</td></tr><tr><td>适用场景</td><td style="text-align:center">数据传输</td><td style="text-align:center">逻辑处理</td></tr></tbody></table><h2 id="3、参数（Parameter）全局共享字典">3、参数（Parameter）全局共享字典</h2><ul><li>ROS Master里面的参数服务器。</li><li>可通过网络访问的共享、多变量<strong>字典</strong>，数据类型不唯一。</li><li>节点使用次服务器来存储&amp;检索运行时的参数。</li><li>适合存储静态、非二进制的配置参数，不适合存储动态配置的数据。</li></ul><blockquote><p>eg:</p><img src="https://s2.loli.net/2022/07/11/9WpPugflbYcUK51.png" style="zoom:67%;"><p>如上图，Talker存入<code>setParam</code>了一个参数<code>("foo",1)</code>到ROS Master</p><p>Listener需要调用<code>foo</code>底下的值，就发出一个请求<code>getParam</code></p><p>然后Listener就可以获得ROS Master返回的<code>("foo",1)</code></p><ul><li>观察可以发现，如果Listener只get一次参数，如果参数有变化的话，就没办法及时更新了，就不适合存储动态变化的数据。</li><li>如果需要实时更新参数，就需要用到ROS的高级功能 “动态参数配置”的功能。</li></ul></blockquote><h2 id="4、文件系统">4、文件系统</h2><ul><li><p>功能包（package）</p><p>ROS软件中的基本单元，包含了节点源码、配置文件、数据定义……</p><p>用于完成一些具体的功能，人脸识别、图像识别等等</p></li><li><p>功能包清单（package manifest）</p><p>记录了功能包的基本信息，包含了作者信息、许可信息、依赖选项、变异标志……</p></li><li><p>元功能包（meta package）</p><p>组织多个用于同一个目的的功能包</p><p>比如很多个图像识别的功能包组织成一个大工程，这个大工程就是元功能包。</p></li></ul><pre class="mermaid">graph TBA(文件系统) --&gt;B[元功能包]B --&gt;C[功能包]C --&gt;D1[功能包清单]C --&gt;D2[消息类型]C --&gt;D3[服务类型]C --&gt;D4[代码]C --&gt;D5[其他]</pre><p><img src="https://s2.loli.net/2022/07/11/ZRt6jPecizJA37I.png" alt=""></p><p>参考自: 古月居ros教程</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成概述（2.2存储系统）</title>
      <link href="/2022/06/03/computer_organization3-1/"/>
      <url>/2022/06/03/computer_organization3-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="计算机组成原理——2-2-存储系统"><a href="#计算机组成原理——2-2-存储系统" class="headerlink" title="计算机组成原理——2.2 存储系统"></a>计算机组成原理——2.2 存储系统</h1><h2 id="一、主存存储器与CPU的连接"><a href="#一、主存存储器与CPU的连接" class="headerlink" title="一、主存存储器与CPU的连接"></a>一、主存存储器与CPU的连接</h2><p><img src="https://s2.loli.net/2022/05/18/R41VbvF5dPNT2gX.jpg" alt="MDR和MAR都集成在CPU"></p><p>单个存储芯片的容量可能不是很大，往往需要通过存储器芯片拓展技术，把多个芯片集成在一个内存条上，然后由多个内存条+主板上的ROM芯片，组成计算机所需要的主存空间。</p><p>内存条插槽就是存储器总线。内存条通过总线与主板相连，然后链接到CPU。</p><p><img src="https://s2.loli.net/2022/05/14/Ke6lCakUjm5MNB1.png" alt="8x8位存储芯片原理图"></p><p>由于单个存储芯片的容量是有限的，在<strong>字数</strong>或者<strong>字长</strong>上与实际的存储器要求都有差距。因此，需要<strong>在字和位两个方面进行扩充</strong>。通常采用的方法如下：</p><ul><li>位拓展法：使数据总线宽度=存储芯片宽度（数据总线）</li><li>字拓展法：拓展主存字数（地址总线）</li><li>字位同时拓展</li></ul><h3 id="1、位扩展"><a href="#1、位扩展" class="headerlink" title="1、位扩展"></a>1、位扩展</h3><p>当 CPU的数据线数 与 存储芯片的数据位数 不相等时，就进行位扩展。（针对数据总线）</p><p><strong>用多个存储芯片扩充存储字长</strong></p><p>举个栗子：</p><blockquote><ul><li><p>有一个<code>8k*1位</code>的芯片，8k对应了2的13次方</p><p>   所以需要13根地址线表示地址，将其和CPU连接起来</p></li><li><p>假设现在数据总线有8位，那我们就可以链接八个这样的芯片</p><p>   每传进来一个八位的数据，就由这八块芯片，分别存储这八位数据的其中一位。</p></li><li><p>由上可知，<strong>地址总线、读写控制信号线（WE）、片选信号（CS），由这八个芯片共同使用。</strong></p></li></ul></blockquote><p><img src="https://s2.loli.net/2022/05/26/L3IHi4lEk7wpjcg.jpg" alt="位扩展连线图"></p><h3 id="2、字扩展法"><a href="#2、字扩展法" class="headerlink" title="2、字扩展法"></a>2、字扩展法</h3><p>当<strong>CPU的地址线数</strong>与<strong>存储芯片的地址位数</strong>不相等时，就进行字扩展。（针对数据总线）</p><p>该方法把多出来的地址引脚接到译码器上，用译码器区分不同的片选信号，由这些片选信号来启动不同的存储芯片。</p><p><strong>地址总线（部分）、数据总线、读写控制信号线（WE）由这些芯片共同使用。片选信号（CS）接上译码器使用</strong></p><p><img src="https://s2.loli.net/2022/05/26/Gx1MlHn3FYIibK6.jpg" alt="字拓展连接原理图"></p><h3 id="3、字位同时扩展"><a href="#3、字位同时扩展" class="headerlink" title="3、字位同时扩展"></a>3、字位同时扩展</h3><p>有了前面的理解，我们直接上原理图</p><p><img src="https://s2.loli.net/2022/05/26/yMlBZVcFHEQIh3N.jpg" alt="字位同时扩展原理图"></p><p>16k的存储，对应2的14次方。所以需要使用14条线来表示。</p><p>采用字位同时扩展时，各个芯片连接地址线的方式相同</p><p>但连接数据线的方式不同。且片选信号需要连接译码器。</p><h2 id="二、存储芯片的地址分配和片选"><a href="#二、存储芯片的地址分配和片选" class="headerlink" title="二、存储芯片的地址分配和片选"></a>二、存储芯片的地址分配和片选</h2><p>CPU选择存储芯片的操作叫做<strong>片选</strong>。</p><p>选中后，为选中的芯片按照地址码，选择相应的存储单元，用来存储数据。这个操作叫做<strong>字选</strong>。</p><p>片内的字选，通常是由CPU送出的N条低位地址线完成的。</p><p>地址线直接连到所有存储芯片的地址输入端</p><p>N由片内存储容量$ 2^{N} $决定。</p><p>片选信号的产生分为线选法，译码片选法</p><h3 id="1、线选法"><a href="#1、线选法" class="headerlink" title="1、线选法"></a>1、线选法</h3><p>使用专门的地址线直接链接（或者加个反相器），接到存储芯片上。</p><ul><li>由于是直接链接到存储芯片，当专用的地址线，**有两个及以上的片选信号发出时，会造成访问冲突。</li></ul><blockquote><ul><li>举个栗子，比如只有两个存储芯片，线选法就只能在专门的地址线，比如最高位两位，选择控制芯片.</li><li>如果此时最高位同时为00，或者11，就会导致访问数据出现问题</li><li>而且会导致存储地址不连续。00xxxxxx和11xxxxxx的地址就是不可用的，可以看出有一定的局限性</li></ul></blockquote><h3 id="2、译码片选法"><a href="#2、译码片选法" class="headerlink" title="2、译码片选法"></a>2、译码片选法</h3><p>就是使用译码器，用来产生片选信号。可以通俗的理解为，把8421码转成单独的一个个片选输出</p><p><img src="https://s2.loli.net/2022/05/28/Lv7K3xFkTDAd9P5.png" alt="译码器"></p><p>虽然在连接过程中，需要接入译码器芯片，但是n条线可以产生$ 2^{n}  $个片选信号，二千地址空间连续，实用性更高</p><h2 id="三、外存储器"><a href="#三、外存储器" class="headerlink" title="三、外存储器"></a>三、外存储器</h2><p>磁表面存储器，是指把某些磁性材料薄薄地涂在铝或者塑料表面上，作为记忆载体，一次存储信息。磁盘、磁带、磁鼓存储器都是磁表面存储器</p><h3 id="1、磁盘存储器"><a href="#1、磁盘存储器" class="headerlink" title="1、磁盘存储器"></a>1、磁盘存储器</h3><p>磁盘存储器的优点：</p><ul><li><p>存储容量大，位价格低。相同价位下，机械硬盘的存储容量会比固态硬盘的大</p></li><li><p>存储介质可以重复使用</p></li><li><p>记录信息可以长期保存而不丢失，可以脱机存档</p></li><li><p>非破坏性读出，读出时不需要再生</p></li></ul><p>缺点：</p><ul><li>存取速度慢</li><li>机械结构比较复杂</li><li>对工作环境要求比较高（容易受到强磁场的干扰）</li></ul><h4 id="1-磁盘设备的组成"><a href="#1-磁盘设备的组成" class="headerlink" title="1. 磁盘设备的组成"></a>1. 磁盘设备的组成</h4><p><img src="https://s2.loli.net/2022/05/28/G3pCskQSnj6VUPq.png" alt="磁盘存储器原理图"></p><p>由磁盘驱动器，磁盘控制器和盘片组成</p><ul><li>磁盘驱动器的核心部件是磁头和盘片。温彻斯特盘是一种可移动磁头，固定盘片的存储器</li><li>磁盘控制器，硬盘和主机的接口，常见的有<strong>IDE、SCSI、SATA</strong></li></ul><p><img src="https://s2.loli.net/2022/05/28/9gjawFxAcfXCMYo.png" alt="SCSI存储流程"></p><ul><li><p>存储区</p><ul><li>一块硬盘有很多个盘片，也就是记录面，每个记录面划分为若干个磁道，每条磁道划分为若干个扇区（也称为块）。扇区是磁盘读写的最小单位。<strong>磁盘按照块来存取</strong>。</li></ul><blockquote><ul><li><p><strong>磁头数-Heads</strong>：也就是记录面数，表示硬盘一共有多少个磁头。磁头用来读取、写入盘片的信息，一个记录面对应一个磁头</p></li><li><p><strong>柱面数-Cylinder</strong>：表示硬盘的每个盘片上有多少个磁道。这个名词可以理解为，有一叠盘片，这些盘片上，相同位置（编号）的磁道们构成一个圆柱的面</p><p>说柱面号的时候，就是指明某一条磁道</p></li><li><p><strong>扇区数-Sectors</strong>：表示每个磁道有多少个扇区<sup class="refplus-num"><a href="#ref-s">[1]</a></sup>。</p><ul id="refplus" style="display:none;"><li id="ref-s" data-num="1">[1]   扇区就是盘片的一部分扇形区域</li></ul><p></p></li></ul></blockquote><p><img src="https://s2.loli.net/2022/06/03/7NBJU6bEvWACmQ5.png" alt="盘片正反面都可以读写"></p></li></ul><h4 id="2-磁盘存储原理"><a href="#2-磁盘存储原理" class="headerlink" title="2. 磁盘存储原理"></a>2. 磁盘存储原理</h4><ul><li><strong>原理</strong>：磁头和磁性介质相对运动的时候，通过电磁转换完成读写操作</li><li><strong>编码方法</strong>：按照某种方案或者规律，把一连串的二进制信息变成存储介质上磁层中（磁层翻转状态）的序列，并让读写控制电路更容易、可靠地实现转换</li><li><strong>磁记录方式</strong>：通常采用调频方式（FM）和改进型调频（MFM）的记录方式</li></ul><h4 id="3-磁盘的性能指标"><a href="#3-磁盘的性能指标" class="headerlink" title="3. 磁盘的性能指标"></a>3. 磁盘的性能指标</h4><ul><li><p><strong>记录的密度</strong></p><p>是指盘片上，单位面积内记录的信息量。通常用道<strong>密度、位密度和面密度</strong>表示。</p><ul><li><p><strong>道密度</strong>：沿磁盘半径方向，单位长度上的磁道数</p></li><li><p><strong>位密度</strong>：磁道单位长度上，能记录的二进制代码位数</p></li><li><p><strong>面密度</strong>：位密度 x 道密度</p></li><li><p>补充：</p><ul><li><p>位密度：</p><p>越内侧的磁道位密度越大。越靠外越小</p><p>所以一个磁盘的存储性能受到最靠内侧磁道的制约</p><p>不难理解，因为在最短的一个扇区内的存储上限很低</p><p><img src="https://s2.loli.net/2022/06/03/rELCHz4uAwXSpaR.png" alt="越靠内磁道密度越大"></p></li><li><p>所以：磁盘所有磁道记录的信息量一定是相等的。并不是圆圈越大信息量越多。所以每个磁道的位密度都不相同（外圈长度更长）</p></li></ul></li></ul></li><li><p><strong>磁盘的容量</strong></p><ul><li><p>非格式化容量</p><p>磁记录表面可利用的磁化单元总数，由道密度和位密度计算来的</p><p>（磁盘在物理上总共可以存储多少的数据）</p></li><li><p>格式化容量</p><p>按照某种特定的记录格式，能够存储的信息总量</p><p>（会留出一部分空间用作其他用途。比如为了防止个别扇区损坏，影响整个磁盘的正常工作，会留出一部分备用扇区等等）</p></li></ul><p>非格式化空间大小 &gt; 格式化容量</p></li><li><p>平均存取时间</p><p>由：</p><blockquote><p>寻道时间（磁头移动到对应的磁道，花费的时间）</p><p>旋转延迟时间（磁头找到要读取的扇区，花费的时间）</p><p>传输时间（传输数据花费的时间）</p></blockquote><p>三个部分相加而成。</p><p>也就是，先找到磁道，再2找到对应的扇区位置，然后再写数据。</p><p>由于寻道和找扇区的距离<strong>远近不一</strong>，所以寻道时间通常取平均值，旋转延迟时间可以取<strong>转半圈花费的时间</strong>。</p><blockquote><p>因为我们要读取的扇区，在任何一个位置的概率都是相等的。按照概率计算数学期望的思想，平均来看，尧都区的扇区转到磁头臂的下方，其期望值接近转半圈的时间。</p></blockquote><p>补充：计算机发出读写命令也需要花时间，也就是磁盘控制器的延迟花费的时间</p></li><li><p>数据传输率</p><p>磁盘存储器在单位时间内，向主机传送数据的字节数。</p><blockquote><p>假设磁盘专属为 r转/秒，每条磁道的容量为 N字节，数据传输率计算方式如下（理论最大值）：<br>$$<br>D_r = rN<br>$$</p></blockquote></li></ul><h4 id="4-磁盘地址"><a href="#4-磁盘地址" class="headerlink" title="4. 磁盘地址"></a>4. 磁盘地址</h4><p>主机会向磁盘控制器发出一个寻址的信息。磁盘的地址一般如下表分布：</p><table><thead><tr><th>驱动器号</th><th>柱面（磁道）号</th><th>盘面号</th><th>扇区号</th></tr></thead><tbody><tr><td>一台电脑可以有多个磁盘</td><td>移动磁头臂来寻道</td><td>激活某个磁头</td><td>通过旋转，将特定扇区划过磁头下方</td></tr></tbody></table><p>假设系统有</p><ul><li>4个驱动器，每个驱动器带1个磁盘</li><li>每个磁盘有256个磁道、16个盘面</li><li>每个盘面分为16个扇区</li></ul><p>则每个扇区地址要18位数据表示</p><table><thead><tr><th>驱动器号</th><th>柱面（磁道）号</th><th>盘面号</th><th>扇区号</th></tr></thead><tbody><tr><td>占2位</td><td>占8位</td><td>占4位</td><td>占4位</td></tr></tbody></table><h4 id="5-硬盘的工作过程"><a href="#5-硬盘的工作过程" class="headerlink" title="5. 硬盘的工作过程"></a>5. 硬盘的工作过程</h4><p>硬盘主要操作为寻址、读盘、写盘。每个操作都对应一个控制字（控制命令）</p><p>硬盘工作的时候，先取控制字，再执行控制字</p><p>机械硬盘是机械式的部件，读写操作都是串行的，不能在同一个时刻又读又写，也不能在用一时刻读两组数据或写两组数据。</p><h3 id="2、磁盘阵列"><a href="#2、磁盘阵列" class="headerlink" title="2、磁盘阵列"></a>2、磁盘阵列</h3><p>RAID（Redundant Array of Inexpensive Disks。 <strong>廉价磁盘冗余阵列</strong> ）：指将多个独立的物理磁盘组成一个独立的逻辑盘。数据在多个物理盘上分割交叉存储、并行访问。具有更好的存储性能、可靠性、安全性。</p><ul><li>RAID0：无冗余和无校验的磁盘阵列</li><li>RAID1：镜像磁盘阵列</li><li>RAID2：采用纠错的汉明码的磁盘阵列</li><li>RAID3：位交叉奇偶校验的磁盘阵列</li><li>RAID4：块交叉奇偶校验的磁盘阵列</li><li>RAID5：无独立校验的奇偶校验磁盘阵列</li><li>RAID后面带的数字越大，冗余信息越少，可靠性越高</li></ul><h4 id="1、RAID0：无冗余和无校验的磁盘阵列"><a href="#1、RAID0：无冗余和无校验的磁盘阵列" class="headerlink" title="1、RAID0：无冗余和无校验的磁盘阵列"></a>1、RAID0：无冗余和无校验的磁盘阵列</h4><p><img src="https://s2.loli.net/2022/06/03/pkG7cvSVmflthYq.png" alt="RAID0"></p><p>逻辑上相邻的两个甚至多个扇区，在物理上存到两个或多个磁盘（类比上一篇介绍的<strong>低位交叉编址的多体存储器</strong>）</p><p>也就是说，逻辑上相邻的数据块，把它们<strong>依次、分散</strong>存在物理上多个磁盘内。</p><p>看得出来，RAID0存储方式没有冗余的信息，也没有校验的功能<sup class="refplus-num"><a href="#ref-j">[1]</a></sup></p><ul id="refplus" style="display:none;"><li id="ref-j" data-num="1">[1]   如果某个扇区内损坏或数据错位，存在这个扇区的信息就永远丢失，找不回来了。如果存有一些冗余信息，需要的时候可以用来恢复数据。</li></ul><p></p><h4 id="2、RAID1：镜像磁盘阵列"><a href="#2、RAID1：镜像磁盘阵列" class="headerlink" title="2、RAID1：镜像磁盘阵列"></a>2、RAID1：镜像磁盘阵列</h4><p>就是存两份一样的数据</p><p><img src="https://s2.loli.net/2022/06/03/lXJ8fduW3qpZGKQ.png" alt="RAID1"></p><p>虽然数据出问题的时候，可以通过比对信息，来恢复数据。但是冗余了一半的存储空间，确实有点太粗暴了，也不能并行访问</p><h4 id="3、采用纠错的汉明码的磁盘阵列"><a href="#3、采用纠错的汉明码的磁盘阵列" class="headerlink" title="3、采用纠错的汉明码的磁盘阵列"></a>3、采用纠错的汉明码的磁盘阵列</h4><p>这里每个盘的每块颜色存的不是一块数据，而是一个bit。逻辑上连续的几个bit在物理上分散存储在各个盘中。</p><p>而且，4 bit数据+3 bit汉明码，可以纠正一位错误信息。</p><p><img src="https://s2.loli.net/2022/06/03/dpLb4ns6XfVuJ1G.png" alt="RAID2"></p><p>后面几种偷懒不写<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ，感兴趣可以看<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/1149823?fromtitle=RAID&fromid=33858&fr=aladdin">RAID百度百科</a>了解更多</p><h2 id="3、光盘存储器"><a href="#3、光盘存储器" class="headerlink" title="3、光盘存储器"></a>3、光盘存储器</h2><p>用光学原理存储信息的装置。用聚焦光束对介质存信息</p><p>特点：</p><ul><li>存储密度高</li><li>携带方便</li><li>成本低、容量大</li><li>存储时间长，更好保存</li><li>……</li></ul><p>蓝光波长较短，接近紫光，存储数据的话，信息密度更高。必入蓝光光盘</p><p>光盘类型如下：</p><blockquote><ul><li>CD-ROM：只读光盘，无法写入数据</li><li>CD-R：只能写进去一次信息，之后不可修改</li><li>CD-RW：可重复读写光盘</li><li>DVD-ROM：高容量的CD-ROM。DVD表示通用数字化多功能的光盘</li></ul></blockquote><h2 id="4、固态硬盘SSD"><a href="#4、固态硬盘SSD" class="headerlink" title="4、固态硬盘SSD"></a>4、固态硬盘SSD</h2><p>是一种基于闪存技术的存储器，是一种ROM。它与U盘没有本质的区别，就是容量更大，存储性能更好。</p><p>一个SSD由一个或多个闪存芯片和闪存翻译层组成。闪存芯片替代传统旋转磁盘的机械驱动器。闪存翻译层相当于磁盘控制器的角色。</p><p><img src="https://s2.loli.net/2022/06/03/9Zv21iXa8yIGx7H.png" alt="SSD"></p>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux开发板搭建ros环境</title>
      <link href="/2022/05/26/ros-start/"/>
      <url>/2022/05/26/ros-start/</url>
      
        <content type="html"><![CDATA[<h1>linux开发板配置ros</h1><p>在linux开发板底下，使用官方源即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd /etc/apt/sources.list.d/sudo touch ros-latest.listsudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'sudo apt install curlcurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -sudo apt-get updatesudo apt install ros-melodic-desktop-full#↑为ros桌面版完整安装，包括了ROS、rqt、rviz、机器人通用库、2D/3D 模拟器和 2D/3D 感知#设置每次启动新的 shell 时自动将 ROS 环境变量添加到您的 bash 会话中echo "source /opt/ros/melodic/setup.bash" &gt;&gt; ~/.bashrcsource ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到目前为止，已经安装了运行核心 ROS 软件包所需的东西。如果要创建和管理自己的 ROS 工作区，有多种工具和要求是分开分发的。例如，rosinstall是一种常用的命令行工具，它使您能够通过一个命令轻松下载许多 ROS 包的源代码树。</p><p>要安装此工具和其他依赖项以构建 ROS 包，就运行以下指令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化rosdep</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install python-rosdepsudo rosdep initrosdep update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查ros运行环境</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">printenv | grep ROS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/26/GFPgOWDLtAzqHv7.png" alt=""></p><p>创建catkin工作区</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p ~/catkin_ws/srccd ~/catkin_ws/catkin_makecd buildmake -j8 -l8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为确保工作区被设置脚本正确覆盖，请确保ROS_PACKAGE_PATH环境变量包含所在的目录。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ..source devel/setup.bashecho $ROS_PACKAGE_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#此为打印输出的结果，如果与如下输出类似，就是配置成功/home/HwHiAiUser/catkin_ws/src:/opt/ros/melodic/share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>##测试步骤</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在新的终端运行rostopic list，如果看到话题，可以看到以下画面，算是成功安装</p><p><img src="https://s2.loli.net/2022/05/26/duJ42kf1xe8jnvL.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 环境搭建 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成概述（2.1存储器）</title>
      <link href="/2022/05/15/computer_organization3/"/>
      <url>/2022/05/15/computer_organization3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="计算机组成原理——2-1-存储系统"><a href="#计算机组成原理——2-1-存储系统" class="headerlink" title="计算机组成原理——2.1 存储系统"></a>计算机组成原理——2.1 存储系统</h1><h2 id="一、存储器的层次结构"><a href="#一、存储器的层次结构" class="headerlink" title="一、存储器的层次结构"></a>一、存储器的层次结构</h2><pre class="mermaid">graph TBCPU --&gt; Cache(Cache高速缓冲储存器)Cache --&gt; A(主存/内存)A --&gt;B(磁盘/辅存)B --&gt;C(U盘-磁带-光盘/外存)</pre><ul><li><p>从上到下：容量从小到大、速度，价格从大到小</p></li><li><p>性能更高的，还会将cache分为L1（一级cache）L2（ 二级cache）等等，通常来说，L1最快。cache成本比内存大得多。</p></li><li><p>主存&amp;辅存：实现虚拟存储系统，解决主存容量不够的问题。</p></li><li><p>Cache&amp;主存：解决了主存与CPU速度不匹配的问题。</p></li></ul><h3 id="1、按层次分类"><a href="#1、按层次分类" class="headerlink" title="1、按层次分类"></a>1、按层次分类</h3><pre class="mermaid">graph LRA(按层次分类)subgraph memoryB(高速缓存--cache)C(主存储器--主存 - 内存)endD(辅助存储器--辅存 - 外存)E(可直接被CPU读写)A --&gt;BA --&gt;CA --&gt;DB --&gt;EC --&gt;E</pre><h3 id="2、存储介质"><a href="#2、存储介质" class="headerlink" title="2、存储介质"></a>2、存储介质</h3><ul><li>半导体存储器（主存，Cache）</li><li>磁性材料存储器（磁盘，磁带）</li><li>光存储器，以光介质存储信息（光盘）</li></ul><h3 id="3、存取方式"><a href="#3、存取方式" class="headerlink" title="3、存取方式"></a>3、存取方式</h3><ul><li><p>随机存储器（Random Access Memory，RAM）</p><p>读写任何一个存储单元所需要的时间都相同，与存储单元所在物理位置无关。如内存条</p></li><li><p>顺序存储器（Sequential Access Memory，SAM）</p><p>读写一个存储单元所需的时间取决于存储单元所在位置。如磁带</p></li><li><p>直接存取存储器（Direct Access Memory，DAM）</p><p>既有随机存储特性，也有顺序存储特性。先直接选取信息所在的区域，然后按顺序的方式存储。如：机械硬盘</p></li><li><p>相联存储器（Associative Memory）即可以按内容访问的存储器（Content Addressed Memory，CAM）</p><p>可以按照内容检索到存储位置进行读写。快表<sup class="refplus-num"><a href="#ref-k">[1]</a></sup>就是一种相联存储器  </p><ul id="refplus" style="display:none;"><li id="ref-k" data-num="1">[1]  快表是一种特殊的高速缓冲存储器（Cache），内容是页表中的一部分或全部内容。</li><li id="ref-在操作系统中引入快表是为了加快地址映射速度" data-num="2">[2] 在操作系统中引入快表是为了加快地址映射速度。</li><li id="ref-在虚拟页式存储管理中设置了快表，作为当前进程页表的Cache。通常快表处于MMU中" data-num="3">[3] 在虚拟页式存储管理中设置了快表，作为当前进程页表的Cache。通常快表处于MMU中。</li></ul><p></p></li><li><p>顺序存储和直接存储的存储器统称<strong>串行访问存储器</strong>：</p><p>读取某个存储单元所需时间与存储单元的物理位置有关。</p></li></ul><h3 id="4、信息的可更改性"><a href="#4、信息的可更改性" class="headerlink" title="4、信息的可更改性"></a>4、信息的可更改性</h3><ul><li>读写存储器（read/write Memory）== 可读也可写（磁盘，内存，cache）</li><li>只读存储器（Read Only Memory）== 只读，不可写（CD-ROM，BIOS存储的ROM）要写入比较麻烦，需要先擦除再写入。</li></ul><h3 id="5、信息的可保存性"><a href="#5、信息的可保存性" class="headerlink" title="5、信息的可保存性"></a>5、信息的可保存性</h3><ul><li>易失性存储器（主存，cache）：断电后存储信息就消失了</li><li>非易失存储器（磁盘，光盘）：断电后信息还保留</li><li>破坏性读出（DRAM）：信息读出后，原存储信息被破坏。DRAM读出数据后需要进行重写</li><li>非破坏性读出（SRAM，磁盘，光盘）：信息读出后，原本信息不会被破坏</li></ul><h3 id="6、存储器性能指标"><a href="#6、存储器性能指标" class="headerlink" title="6、存储器性能指标"></a>6、存储器性能指标</h3><ul><li><p>存储容量：存储字长（MDR位数） x 字长（如：1M x 16位）</p></li><li><p>单位成本：每位加个 = 总成本 / 总容量</p></li><li><p>存储速度：数据传输率 = 数据的宽度 / 存储周期</p></li><li><p>存取时间Ta：从启动一次存储器操作到完成该操作所经历的时间，分读出时间和写入时间。</p></li><li><p>存取周期Tm：存储器进行一次完整的读写操作所需的全部时间。（也就是连续两次独立访问存储器操作，所需的最小时间间隔）</p></li><li><p>主存带宽Bm：又称数据传输率。表每秒从主存进出心理的最大数量，单位：字/秒、字节/每秒（B/s）、位/秒（b/s）</p></li></ul><h2 id="二、主存储器基本组成"><a href="#二、主存储器基本组成" class="headerlink" title="二、主存储器基本组成"></a>二、主存储器基本组成</h2><p>由电容与MOS关组成</p><p><img src="https://s2.loli.net/2022/05/13/fR9LpVQDsGouOe4.png" alt="原理图"></p><p>我们使用译码器，使用n位地址找到2^n个存储单元里对应的存储信息。地址由MAR存储。CPU通过地址总线连接MAR。</p><p>CPU给MAR一个地址，通过译码器找到对应地址的存储单元，将其数据通过数据总线（位线）输出给MDR，MDR吧数据给CPU。数据总线的宽度 = 存储字长</p><ul><li>总容量 = 存储单元个数 * 存储字长</li></ul><p>其中，MAR和MDR需要通过<strong>控制电路</strong>和<strong>译码器驱动器</strong>，可以理解为负责稳定输出。只有MAR和MDR里的数据存储稳定之后，控制电路才会打开通路的开关，让数据在总线上进行传输。</p><p><img src="https://s2.loli.net/2022/05/14/Ke6lCakUjm5MNB1.png"></p><p>片选线负责在多个存储芯片中，选择其中一个存储芯片，在里头读取数据。</p><p><img src="https://s2.loli.net/2022/05/14/R4umtJ9oEPwWhvS.png" alt="多个存储芯片"></p><p>存储芯片总结一共由于五类引脚：</p><ul><li><p>地址线</p></li><li><p>数据线</p></li><li><p>片选线</p></li><li><p>读写控制线</p></li><li><p>供电引脚与接地引脚</p></li></ul><p><strong>寻址</strong></p><p>按字节寻址</p><p>按字寻址</p><ul><li>字地址算术左移一定位数，即可转换为对应的字节地址</li></ul><p>按半字寻址</p><p>按双字寻址</p><h2 id="三、SRAM-amp-DRAM"><a href="#三、SRAM-amp-DRAM" class="headerlink" title="三、SRAM & DRAM"></a>三、SRAM &amp; DRAM</h2><ul><li><p>DRAM，Dynamic Random Access Memory，即动态RAM</p><p>SRAM，Static Random Access Memory，即静态RAM</p></li><li><p>DRAM用于主存，SRAM用于Cache</p></li><li><p>上述介绍的 “主存储器基本组成” 就是DRAM。</p></li></ul><table><thead><tr><th>类型特点</th><th>DRAM（常用主存）</th><th>SRAM（常用cache）</th></tr></thead><tbody><tr><td>存储器</td><td>栅极电容</td><td>双稳态触发器</td></tr><tr><td>是否破坏性</td><td>电容放电时信息被破坏，是破坏性读出，读出之后应有重写操作。也称 “再生” 。</td><td>读出数据的时候，触发器保持状态稳定，非破坏性读出，无需重写。</td></tr><tr><td>读写速度</td><td>更慢</td><td>更快</td></tr><tr><td>集成度&amp;成本</td><td>集成度高，成本低</td><td>集成度低，成本高</td></tr><tr><td>是否易失</td><td>是，断电后信息消失</td><td>是，断电后信息消失</td></tr><tr><td>需要刷新</td><td>需要，存储介质是电容</td><td>不需要，存储介质是触发器</td></tr><tr><td>送行列地址</td><td>分两次送</td><td>同时送</td></tr><tr><td>功耗&amp;发热量</td><td>功耗低，发热量小</td><td>功耗高，发热量高</td></tr></tbody></table><ul><li><p>DRAM存储单元使用的MOS管比SRAM更少，在芯片面积不变的情况下，DRAM集成度更高。</p></li><li><p>核心区别：存储元不一样</p></li></ul><h3 id="3-1-DRAM刷新"><a href="#3-1-DRAM刷新" class="headerlink" title="3.1 DRAM刷新"></a>3.1 DRAM刷新</h3><ul><li><p>刷新的概念</p><ul><li><p>刷新一次的时间间隔：</p><p>DRAM使用的电容存储信息，大概2ms后信息会消失，所以DRAM每2ms就需要刷新一次。</p></li><li><p>每次刷新多少个存储单元：</p><p>由于DRAM存储器需要刷新，如果我们有20根选线，就有2^20 = 1M根选线。如果全部接在一个译码器，难度会很大。</p><p>此时我们把这个译码器拆分成两个，为（行地址译码器）和（列地址译码器），每个译码器只需要处理一半的地址，即2^10 = 1k = 1024根选线，这样就可以把存储单元排列成2^{n/2} x 2^{n/2}的存储单元<strong>矩阵</strong>。</p><p><strong>使用行列地址可以减少选通线的数量</strong></p></li></ul></li><li><p>如何刷新？</p><p>所以每次刷新的时候，以行为单位，<strong>每次刷新一行存储单元</strong>。</p><p>这里有硬件的支持，由存储器独立完成，不需要CPU控制。</p><p>读出一行的信息之后就重新写入。</p><p>由于刷新一次类似于一次读操作，所以时间上占用一个读或写周期。</p></li><li><p>刷新的思路</p><ul><li><p>思路一，分散刷新：</p><p>每次读写完都刷新一行</p></li><li><p>思路二，集中刷新：</p><p>2ms内集中安排一块时间全部刷新。那就会出现有一段时间专门用于刷新，无法访问存储器，称为访存 “死区”。</p></li><li><p>思路三，异步刷新：</p><p>2ms内每行刷新一次即可，那每隔2ms就会出现一次 “死时间”（可以理解为分散了死区），在这期间，CPU无法访问。<strong>可以在译码阶段刷新</strong>。</p></li></ul></li><li><p>送行列地址：</p><ul><li>因为DRAM使用了两个译码器，所以我们使用<strong>地址线复用技术</strong>，也就是说，每次传输一半的地址给其中一个译码器即可先接受行地址，再接受列地址，分两次传输地址，给两个译码器。我们就可以减少一半的地址线，芯片引脚也会更少。</li><li>SRAM因为集成度更低，所以地址我们同时传输即可</li></ul></li><li><p>现在主存芯片通常使用<code>SDRAM</code>芯片，</p></li></ul><h2 id="四、只读存储器ROM"><a href="#四、只读存储器ROM" class="headerlink" title="四、只读存储器ROM"></a>四、只读存储器ROM</h2><p>RAM芯片断电后数据会消失（易失性的），而：</p><p>ROM芯片，断电后数据不会消失（非易失性的）。</p><p>ROM还可以细分为：<code>MROM</code>、<code>PROM</code>、<code>EPROM</code>、<code>flash闪存</code>、 <code>SSD</code></p><p>很多ROM也具有 “随机存储” 特性。</p><h3 id="1、MROM"><a href="#1、MROM" class="headerlink" title="1、MROM"></a>1、MROM</h3><p>MROM（Mask Read Only Memory），掩模式只读寄存器</p><p>由厂家直接写入信息，只能读出，之后任何人<strong>不可重写</strong></p><p>可靠性高、灵活性差、生产周期长，只适合批量生产</p><h3 id="2、PROM"><a href="#2、PROM" class="headerlink" title="2、PROM"></a>2、PROM</h3><p>PROM（Programmable Read Only Memory），可编程只读存储器</p><p>用户可以用专门的软件写入信息，<strong>写一次之后就不可更改</strong></p><h3 id="3、EPROM"><a href="#3、EPROM" class="headerlink" title="3、EPROM"></a>3、EPROM</h3><p>EPROM（Erasable Programmable Read Only Memory）</p><p>允许用户写入信息，之后可以擦除数据，可进行多次重写</p><h3 id="4、UVEPROM"><a href="#4、UVEPROM" class="headerlink" title="4、UVEPROM"></a>4、UVEPROM</h3><p>UVEPROM（Ultraviolet rays），可以使用紫外线照射8-20分钟，擦除<strong>所有</strong>信息</p><h3 id="5、EEPROM"><a href="#5、EEPROM" class="headerlink" title="5、EEPROM"></a>5、EEPROM</h3><p>第一个E表示的是Electrically，也就是说，可以使用电擦除，擦除<strong>特定</strong>的字。</p><h3 id="6、FLASH-MEMORY"><a href="#6、FLASH-MEMORY" class="headerlink" title="6、FLASH MEMORY"></a>6、FLASH MEMORY</h3><p>Flash Memory，闪速存储器（比如U盘、sd卡），从<code>EEPROM</code>发展来的。断电后可以保存信息，且<strong>可以进行多次快速擦除重写</strong>。</p><p>由于闪存需要先电擦除再写入，所以闪存的 “写” 要比 “读” 来的更慢。</p><p>每个存储元只需要一个MOS管，位密度要比<code>RAM</code>高。</p><h3 id="7、SSD固态硬盘"><a href="#7、SSD固态硬盘" class="headerlink" title="7、SSD固态硬盘"></a>7、SSD固态硬盘</h3><p>由控制单元+存储单元（flash）组成。</p><p>与闪存的核心区别在于：控制单元不一样。</p><p>但是由于存储介质类似，<strong>可以进行多次快速擦除重写</strong>。</p><p>SSD速度快、功耗低、价格高，目前个人电脑常用SSD取代传统的机械硬盘。</p><p>手机辅存也是用的FLASH芯片。相比SSD使用的芯片，集成度高，功耗低，价格贵</p><h2 id="五、计算机内重要的ROM"><a href="#五、计算机内重要的ROM" class="headerlink" title="五、计算机内重要的ROM"></a>五、计算机内重要的ROM</h2><pre class="mermaid">graph TBsubgraph 主机A[主存RAM //+ROM] subgraph CPU    B(运算器)    C(控制器)endend</pre><p>CPU的任务是到<strong>主存</strong>中取指令，然后去运行。主存RAM中存放着指令与数据。而断电后，RAM数据全部丢失。</p><p>所以CPU开机的时候，里头是没有存放指令的。需要把操作系统、应用程序相关的<strong>指令、数据</strong>，重新调入主存。</p><p>而我们知道，操作系统是安装在<strong>辅存</strong>里面的。如何开机，也是需要CPU执行开机指令。但此时CPU里头完全没有指令。</p><p>所以CPU开机的时候，就需要在主板上的ROM芯片读取开机的指令。这块ROM就是<strong>BIOS</strong>。</p><ul><li>主板上BIOS芯片（ROM)，存储了<strong>自举装入程序</strong>，负责引导装入操作系统（开机）</li></ul><p>逻辑上来说，主存由RAM（内存）+ROM（BIOS）组成，且二者通常统一编址。<strong>主板上ROM也是 “主存” 的一部分</strong>。</p><h2 id="六、双端口RAM-amp-多模块存储器"><a href="#六、双端口RAM-amp-多模块存储器" class="headerlink" title="六、双端口RAM & 多模块存储器"></a>六、双端口RAM &amp; 多模块存储器</h2><ul><li><p>存取周期：存取（启动存取 -&gt; 存取完）的时间 + 恢复（存取完 + 下次存取之前）的时间</p><p>也可以表示成：可以连续读写的最短时间间隔</p><ul><li>注：DRAM的恢复时间比较长，有可能会是存取时间的几倍（SRAM的恢复时间比较短）</li></ul></li></ul><p>每次读取完数据，都需要一段时间恢复。如果此时多核CPU都需要访存，那是不是每个CPU都需要等待RAM的恢复时间，才能进行下一次的存取？且即使是单核CPU，读写数据的速度比主存快很多，主存恢复时间太长了该怎么办？</p><p>这里就使用到双端口存储器</p><h3 id="6-1-双端口RAM"><a href="#6-1-双端口RAM" class="headerlink" title="6.1 双端口RAM"></a>6.1 双端口RAM</h3><ul><li><p>作用：<strong>优化多核CPU访问一根内存条的速度</strong>，可以通过两个端口</p></li><li><p>需要有两组完全独立的数据线、地址线、控制线</p></li><li><p>两个端口同时操作主存时：</p><ul><li>两个端口同时对不同的地址单元存数据</li><li>两个端口同时对同一个地址单元读出数据</li><li>两个端口同时对同一个地址单元写入数据（会造成写入错误）</li><li>两个端口同时对同一个地址单元，一个写入，一个读出（会造成读出错误）</li><li>解决方案：<ul><li>把<code>busy</code>信号置0，由判断逻辑决定暂时关闭一个端口（被延时），未被关闭的端口正常访问，被关闭的端口延长很小一段时间后可以再次访问。</li></ul></li></ul></li></ul><h3 id="6-2-多体并行存储器"><a href="#6-2-多体并行存储器" class="headerlink" title="6.2 多体并行存储器"></a>6.2 多体并行存储器</h3><p>CPU读写速度比内存快很多，而内存每次读写过后，需要一段恢复的时间。当CPU需要连续读取的时候，就必须等待内存的恢复时间。所以可以用上多体并行存储器</p><p>多体并行存储器可以理解为使用了多个存储体（每个内存条大小一致，<strong>假设我们使用四个存储体</strong>）</p><p>CPU访存的时候，一定需要一个地址。有以下两种编址模式</p><ul><li><p>高位交叉编址的多体存储器</p><p><img src="https://s2.loli.net/2022/05/14/lQFVykqaizZ2C78.png" alt="高位多体并行存储器原理图"></p><p>假设说我们用的八位地址，那我们就会用<strong>最高位</strong>来区分我存在第几个存储体里（比如最高两比特位共有四种状态）</p><ul><li>看图可知，高位内模块地址是连续的，存取方式仍然是串行存储。<strong>仍然是顺序存储器</strong></li><li>高位交叉的方式下，总是把低位的体内地址送到由高位体号确定的模块内进行译码。</li><li>访问一个连续主存块时，总是先在一个模块内进行访问，等到这个模块访问结束之后才转到下一个模块进行访问。</li><li>CPU总是按顺序访问存储模块，各个模块不能被并行访问，所以不能提高存储器的吞吐率</li></ul></li><li><p>低位交叉编址的多体存储器</p><p><img src="https://s2.loli.net/2022/05/14/SN7A3Kc5rlZDvXW.png" alt="低位多体并行存储器原理图"></p><p>假设说我们用的八位地址，那我们就会用<strong>最低位</strong>来区分我存在第几个存储体里（比如最低两比特位共有四种状态）</p><ul><li><p>看图可知，每个模块按照 “模m” 交叉编址，<strong>模块号 = 单元地址 % m</strong>。</p></li><li><p>低位交叉方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。程序连续放在相邻的模块中，因此称这种编址方式的存储器叫<strong>交叉存储器</strong>。可以在不改变每个模块存储周期的前提下，使用流水线并行存取，提高存储器的带宽。</p><ul><li>如果单模块存取周期为T，总线传送周期为r，实现流水线存储，**存储器交叉模块数m(交叉存储度)  应该大于等于<code>T/r</code>**。以保证启动某个模块后的<code>m*r</code>的时间内要再次启动模块的时候，这个模块已经存取完毕，并已经度过了内存的恢复时间。</li><li>存取周期为T，存取时间为r，为了流水线不间断，保证模块数量为<code>m&gt;=T/r</code>。</li></ul></li><li><p>这样下来，连续存取m个字所需要的时间为:<br>$$<br>t1 = T + (m-1)r<br>$$</p></li><li><p>而顺序方式连续读取m个字所需要的时间为：<br>$$<br>t2 = mT<br>$$</p></li><li><p>综上所述，低位交叉存储器的带宽得到了大幅度的提高（如下图）</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/14/Wfg1po5J3sv67Od.png" alt="低位交叉编址甘特图"></p><p>类似数组等等数据，或者编写的指令代码，其数据存放方式就是连续的存储（除了指令跳转部分）。所以连续存取的速度提升对于计算机来说很有意义。</p><h3 id="6-3-单体多字存储器"><a href="#6-3-单体多字存储器" class="headerlink" title="6.3 单体多字存储器"></a>6.3 单体多字存储器</h3><p>多体并行存储器就是，每个模块都有相同的容量和存储速度，是互相独立的。CPU可以自由选择在哪个存储体的哪个位置读取数据。</p><p>各个模块都有独立的读写控制电路、地址寄存器和数据寄存器等等。可以<strong>并行、交叉</strong>地工作。</p><p>单体多字存储器相当于做了一个合并。共用一套读写控制电路、地址控制器和数据寄存器（类似位拓展）。</p><p><img src="https://s2.loli.net/2022/05/15/BsiGhIDR1wzo8yc.png"></p><p>每次可以读取一整行的数据</p><p>设每个存储单元，存储m个字</p><p>总线宽度也为m个字</p><p>一次并行即可读出m个字</p><p>缺点：指令和数据在主存内必须是连续存放的。一旦遇到转移指令或者操作数不能连续存放，提速的效果就不明显了。</p>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Apt运行报错排查</title>
      <link href="/2022/05/12/error-linux-Unable-to-acquire-the-dpkg-frontend-lock/"/>
      <url>/2022/05/12/error-linux-Unable-to-acquire-the-dpkg-frontend-lock/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="linux中对于Unable-to-acquire-the-dpkg-frontend-lock的解决方法"><a href="#linux中对于Unable-to-acquire-the-dpkg-frontend-lock的解决方法" class="headerlink" title="linux中对于Unable to acquire the dpkg frontend lock的解决方法"></a>linux中对于Unable to acquire the dpkg frontend lock的解决方法</h1><p>运行环境：Ubuntu 18.04<br>问题描述：在别人配置好的Ubuntu下安装软件时，进行<code>apt-get</code>操作，出现了如下报错：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解决办法:</p><h2 id="一、终止占用的进程"><a href="#一、终止占用的进程" class="headerlink" title="一、终止占用的进程"></a>一、终止占用的进程</h2><p>导致的原因：<strong>进程中存在与apt相关的运行中的进程</strong></p><ul><li>检查是否在运行apt,apt-get相关的进程</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ps aux | grep -i apt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果存在与apt相关的正在运行的进程，kill掉对应的进程ID；</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo kill -9 &lt;process id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        或使用简单粗暴的方式:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo killall apt apt-get <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、删除lockfile并配置dpkg"><a href="#二、删除lockfile并配置dpkg" class="headerlink" title="二、删除lockfile并配置dpkg"></a>二、删除lockfile并配置dpkg</h2><p>问题现象：<strong>进程列表中已经没有与(apt/apt-get)相关的进程在运行，但依然报错</strong></p><p>导致的原因：lock file未被正常删除</p><ul><li>lock file用于防止两个或多个进程使用相同的数据。 当运行apt及其相关指令时，它会在几个地方创建lock files。<br>当前一个apt命令未正确终止时，lock file就不会被删除。因此它们会阻止任何新的apt / apt-get命令实例，</li><li>比如正在执行<code>apt-get update</code>，在执行过程中直接ctrl+c取消了该操作，很有可能就会造成这种情况。</li><li>要解决此问题，首先要删除lock file。<br>使用<code>lsof</code>命令获取持有lock file的进程的进程ID,依次运行如下命令:</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsof /var/lib/dpkg/locklsof /var/lib/apt/lists/locklsof /var/cache/apt/archives/lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是</p><p>以上命令执行结果如果无返回，说明没有正在运行的进程</p><p>如果返回了相应的进程，就需要kill掉。</p><p>删除所有的lock file</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo rm /var/lib/apt/lists/locksudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后重新配置一下dpkg：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo dpkg --configure -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果上述命令不出任何错误，就万事大吉了。</p><hr><p>但是有时候，执行配置命令时可能会出现以下错误：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">dpkg: error: dpkg frontend is locked by another process<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时需要找出正在锁定lock file的进程:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsof /var/lib/dpkg/lock-frontend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>kill掉输出的进程（如果输出为空则忽略）</p><pre class="line-numbers language-none"><code class="language-none">sudo kill -9 &lt;process id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除lock file并重新配置dpkg:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo rm /var/lib/dpkg/lock-frontendsudo dpkg --configure -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 报错排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成概述（1.概述）</title>
      <link href="/2022/04/19/computer_organization1/"/>
      <url>/2022/04/19/computer_organization1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="计算机组成原理——第一章"><a href="#计算机组成原理——第一章" class="headerlink" title="计算机组成原理——第一章"></a>计算机组成原理——第一章</h1><h2 id="1-1-计算机与案件的更新换代"><a href="#1-1-计算机与案件的更新换代" class="headerlink" title="1.1 计算机与案件的更新换代"></a>1.1 计算机与案件的更新换代</h2><ol><li><strong>摩尔定律</strong>：当价格不变，集成电路上可容纳的晶体管的数目，约每隔18个月便会增加一倍。也就是说，我们现在和18个月后花同样价钱买到的CPU，后者的性能是前者的2倍。</li><li><strong>半导体存储器的发展</strong>：1970年，仙童半导体公司产出第一个较大容量的半导体存储器。</li><li><strong>微处理机机器字长</strong>：32位和64位指的是机器字长。指<strong>计算机进行一次整数计算所能处理的二进制数据的位数</strong>。</li><li>*硬件发展：逻辑元件从电子管 -&gt; 晶体管 -&gt; 中小规模集成电路 -&gt; 大规模、超大规模集成电路</li></ol><h2 id="1-2-计算机系统硬件"><a href="#1-2-计算机系统硬件" class="headerlink" title="1.2 计算机系统硬件"></a>1.2 计算机系统硬件</h2><ul><li>系统软件（管理整个计算机系统，如操作系统<strong>OS</strong>、数据库管理系统<strong>DBMS</strong>、标准程序库、网络软件、服务程序）</li><li>应用软件（按任务需要编写的程序）</li><li>硬件是计算机物理基础。决定了计算机的 “天花板” 、“瓶颈”在哪，软件决定了我们可以把硬件性能发挥到什么程度。</li></ul><h3 id="1-2-1-计算机硬件"><a href="#1-2-1-计算机硬件" class="headerlink" title="1.2.1 计算机硬件"></a>1.2.1 计算机硬件</h3><h4 id="1-冯·诺依曼机的基本思想"><a href="#1-冯·诺依曼机的基本思想" class="headerlink" title="1. 冯·诺依曼机的基本思想"></a>1. 冯·诺依曼机的基本思想</h4><p>冯·诺依曼在研究<strong>EDVAC</strong>及时提出了“存储程序”的概念。特点如下：</p><ul><li>采用<strong>存储程序</strong>的结构，将指令以二进制代码的形式，事先输入计算机的主储存器，然后按其在储存器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</li><li>计算机硬件由运算器、存储器、控制器、输入设备、输出设备组成</li><li>指令和数据以同等地位存储在存储器中</li></ul><p><img src="https://s2.loli.net/2022/04/14/IOwrRx7jsXD3u29.png" alt="Schematic_diagram_of_von_Neumann_machine"></p><p>图中实线表示数据传输，虚线表示控制线以及反馈线</p><ul><li><p>输入设备：将信息转成及其能识别的形式</p></li><li><p>存储器：存数据和程序。存储器还分为<strong>主存和辅存</strong></p><ul><li>主存：内存</li><li>辅存：机械硬盘、固态硬盘等等。平时应用程勋存在辅存中，需要的时候才读入主存，所以辅存也算是一种I/O设备</li></ul></li><li><p>运算器：alu算数运算和逻辑运算</p></li><li><p>输出设备：将结果转成人们熟悉的形式</p></li><li><p>控制器：解析指令 &amp; 指挥程序运行</p></li><li><p>以上五个设备总和：硬件</p></li><li><p>数据程序：软件</p></li></ul><p>在计算机系统中，软件和硬件在逻辑上是等效的</p><ul><li>eg：乘法运算，可以设计专门的硬件电路去实现，也可以用软件执行多次加法来实现</li></ul><h4 id="2-冯·诺依曼机的特点"><a href="#2-冯·诺依曼机的特点" class="headerlink" title="2. 冯·诺依曼机的特点"></a>2. 冯·诺依曼机的特点</h4><ul><li><p>计算机有五大部件组成（输入输出设备统称<strong>I/O设备（input &amp; output）</strong>）</p></li><li><p>指令和数据，以同等地位存于存储器，可以用地址去寻访</p></li><li><p>指令和数据用二进制表示</p></li><li><p>指令有操作码和地址码组成</p></li><li><p>可以存储程序</p></li><li><p>以运算器为中心（这样会导致各种数据传输效率低下，所以线代计算机以存储器为中心，以下是原理图）</p></li></ul><p><img src="https://s2.loli.net/2022/04/14/4VwFux6RtiYblCj.png" alt="Schematic_diagram_of_modern_computer"></p><p>由于<strong>运算器</strong>和<strong>控制器</strong>之间逻辑关系十分紧密，所以在大规模集成电路工艺出现之后，这两个部件通常是整合在一个芯片上的，也就是我们现在的<strong>CPU</strong>。以下是简化原理图。</p><p><img src="https://s2.loli.net/2022/04/14/R9xEMKVUvYGLz8h.png" alt="Simplified_schematic_d_agram_of_computer"></p><p><strong>在计算机组成原理中，CPU和主存储器统称主机，而且并不是指平时日常生活中的电脑主机</strong></p><pre class="mermaid">graph LRA(硬件) --&gt;B(主机)B --&gt;B1(CPU)B --&gt;B2(主存)A --&gt;C(IO设备)C --&gt;C1(辅存)C --&gt;C2(输入设备)C --&gt;C3(输出设备)B2 --&gt;D(存储器)C1 --&gt;DB1 --&gt;E(运算器)B1 --&gt;F(控制器)</pre><h2 id="1-3-硬件各个部件"><a href="#1-3-硬件各个部件" class="headerlink" title="1.3 硬件各个部件"></a>1.3 硬件各个部件</h2><h3 id="1-主存储器"><a href="#1-主存储器" class="headerlink" title="1.主存储器"></a>1.主存储器</h3><p>MAR：地址寄存器</p><p>MDR：数据寄存器</p><p>线代计算机通常把MAR&amp;MDR集成在CPU内</p><pre class="mermaid">graph TBsubgraph memoryA[存储体] subgraph register    MAR(MAR地址寄存器)    MDR(MDR数据寄存器)endend</pre><p>在MAR给个地址，MAR去存储器寻找对应的数据，然后存放至MDR。可以类比为下图：</p><pre class="mermaid">graph TBsubgraph memoryA[仓库,机器人去找货物] subgraph register    MAR(MAR机器人,给机器人地址)     MDR(MDR柜台,机器人给你货物)endMAR --&gt;AA --&gt;MDRend</pre><p>其中，你要去取这个货物，就好比CPU要去取存储器的数据，从而完成整个数据访问过程。</p><p>如果要存数据，就把要存的数据放在MDR，对应地址给MAR，然后通过总线把数据存进存储体（仓库）。</p><ul><li><p>存储体</p><p>本身会被分为一个个的存储单元，按地址存储。</p><ul><li><p>存储单元：每个存储单元存放一串二进制代码，每个地址对应一个存储单元。</p></li><li><p>存储自（word）：存储单元中二进制代码的组合</p></li><li><p>存储字长：存储单元中二进制代码的位数，通常是8bit的整数倍</p></li><li><p>*存储元：存二进制的电容，每个存1bit</p></li><li><p>MAR位数反映存储单元的个数</p></li></ul></li><li><p>eg：MAR = 8 位 -&gt; 总共有 2的8次方 个存储单元</p><ul><li><p>MAR位数 = 存储字长</p></li><li><p>eg：MDR = 32位 -&gt; 每个存储单元可存放32bit，一个字 = 32 bit</p></li><li><p>字（word）和字节（byte）</p><p>一个字节（byte）= 8 bit</p><p>  1B = 一个字节，1b = 1个bit</p></li></ul></li></ul><h3 id="2-运算器"><a href="#2-运算器" class="headerlink" title="2. 运算器"></a>2. 运算器</h3><p>用于实现算术运算（加减乘除）和逻辑运算（与或非）</p><p>ACC: 累加器，用来存放操作数 / 运算结果</p><p>MQ: 乘商寄存器，惩处运算用来存放操作数 / 运算结果</p><p>x: 通用的 操作数寄存器，存放操作数</p><p>ALU: 算术逻辑单元，实现算术运算和逻辑运算</p><table><thead><tr><th align="center"></th><th align="center">加</th><th align="center">减</th><th align="center">乘</th><th align="center">除</th></tr></thead><tbody><tr><td align="center">ACC</td><td align="center">被加数、和</td><td align="center">被减数、差</td><td align="center">乘积高位</td><td align="center">被除数、余数</td></tr><tr><td align="center">MQ</td><td align="center"></td><td align="center"></td><td align="center">成熟、乘积低位</td><td align="center">商</td></tr><tr><td align="center">X</td><td align="center">加数</td><td align="center">减数</td><td align="center">被乘数</td><td align="center">除数</td></tr></tbody></table><h3 id="3-控制器"><a href="#3-控制器" class="headerlink" title="3. 控制器"></a>3. 控制器</h3><p>CU： 控制单元，分析指令，给出控制信号</p><p>IR：指令寄存器，存放当前执行的指令</p><p>PC：程序计数器，存放吓一跳指令的地址，有自动+1的功能</p><p>完成一条指令的流程：</p><ul><li>取指令：PC</li><li>分析指令：IR</li><li>执行指令：CU</li><li>指令：操作码 +地址码</li><li>OP(IR)：取操作码</li><li>Ad(IR)：取地址码<ul><li>CPU区分指令和数据的依据：指令周期的不同阶段</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/7s1virCB4IFyPWd.png" alt="schematic_diagram"></p><ul><li>运算器的核心部件是ALU，控制器的核心部件是CU。</li></ul><h2 id="1-4-计算机系统层次结构"><a href="#1-4-计算机系统层次结构" class="headerlink" title="1.4 计算机系统层次结构"></a>1.4 计算机系统层次结构</h2><p>代码需要翻译成机器语言，CPU在执行这些机器指令的时候，还需要细分为更细的小步骤来执行，这些小步骤称为<strong>微指令/微操作</strong>。</p><p>用微程序机器的微指令，逐步解析传统机器的每一条机器指令，并执行。</p><p>这样设计程序是很不方便的，所以现在出现了<strong>符号式程序设计语言</strong>，也就是<strong>汇编语言</strong>。识别汇编语言的机器叫<strong>虚拟机器</strong>。（因为虽然程序员看这台机器，好像可以直接识别汇编语言，但其实机器不可能真的识别出汇编语言，汇编语言必须先翻译成机器语言。才叫虚拟机器）</p><pre class="mermaid">graph TB    subgraph software    M4(M4虚拟机器--高级语言机器)    M3(M3虚拟机器--汇编语言机器)    M2(M2虚拟机器--操作系统机器)    end    subgraph hardware    M1(M1虚拟机器--机器语言机器)    M0(M0虚拟机器--微指令系统)    end    M4 --&gt;M3    M3 --&gt;M2     M2 --&gt;M1    M1 --&gt;M0</pre><p>翻译程序有以下三类：</p><ul><li><p>汇编程序：汇编器</p></li><li><p>解释程序：解释器</p></li><li><p>编译程序：编译器</p></li><li><p>汇编语言是一种 “助记符”，帮助人类记忆用的，本质上和机器语言是一一对应的。</p></li><li><p>高级语言需要先经过汇编，再翻译成机器语言。如果使用其他的库函数，还需要进行链接。使用编译程序</p></li><li><p>有的高级语言不是通过编译程序，而是用解释器，将程序翻译成与之对等的机器语言。很多脚本类的语言都是使用解释器，python、JavaScript，shell等等。</p></li><li><p>编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言，而后在执行机器语言程序（只能翻译一次）</p><p>会生成可执行文件，如 <code>*.exe</code>程序等等。</p></li><li><p>解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行，紧接着再翻译下一句（每次执行都需要翻译）</p></li><li><p>编译型的执行效率更高一些，解释性的执行效率更低一些。</p></li><li><p>编译、汇编、解释程序，可统称为 <strong>翻译程序</strong>。</p></li><li><p>*计算机体系结构学习的是：如何设计硬件与软件之间的接口</p><p>计算机组成原理学习的是：如何用硬件实现所定义的接口</p></li></ul><h2 id="1-5-计算机性能指标"><a href="#1-5-计算机性能指标" class="headerlink" title="1.5 计算机性能指标"></a>1.5 计算机性能指标</h2><h3 id="1-主储存器的性能指标"><a href="#1-主储存器的性能指标" class="headerlink" title="1 主储存器的性能指标"></a>1 主储存器的性能指标</h3><ul><li><p><strong>MAR</strong>位数反映<strong>存储单元</strong>，<code>最多</code>支持的个数，可支持 2的MAR次方</p></li><li><p><strong>MDR</strong>位数=存储字长=每个存储单元的大小</p></li><li><p><strong>总容量 = 存储单元个数 * 存储字长 bit = 存储单元个数 *存储字长 / 8 Byte</strong>，<code>1 Byte = 8 bit</code></p><p>eg：MAR=32位，MDR=8位，总容量 = 2^32 * 8 bit = 4GB</p></li></ul><p>$$<br>K=2^{10}\\M=2^{20}\\G=2^{30}\\T=2^{40}<br>$$</p><h3 id="2-cpu的性能指标"><a href="#2-cpu的性能指标" class="headerlink" title="2 cpu的性能指标"></a>2 cpu的性能指标</h3><ul><li>cpu的时钟周期：<br>把CPU的每一个脉冲信号的时间周期叫做<strong>cpu的时钟周期</strong>，单位是微秒或纳秒。</li></ul><p>$$<br>CPU主频（时钟频率） = \frac{1}{CPU时钟周期}<br>$$</p><ul><li><p><strong>CPI（Clock cycle Per Instruction）</strong>：执行一条指令所需的时间周期数</p><p>不同的指令，不同的CPI；甚至相同的指令，CPI也可能不同</p></li></ul><p>$$<br>执行一条指令的耗时 = \frac{CPI}{CPU的时钟周期} \\<br>CPU执行时间(整个程序耗时) = \frac{CPU时钟周期}{主频} = \frac{(指令条数*CPI)}{主频}<br>$$</p><ul><li><p><strong>IPS  (Instructions Per Second)</strong> :<code>每秒</code>执行多少条指令</p><ul><li>可细分为<code>KIPS</code>，<code>MIPS</code><br>$$<br>IPS = \frac{主频}{平均CPI}<br>$$</li></ul></li><li><p><strong>FLOPS  (Floating-point Operations Per Second)</strong> 每秒执行多少次<strong>浮点运算</strong></p><ul><li>可细分为<code>KFLOPS</code>，<code>MFLOPS</code>, <code>GFLOPS</code>，<code>TFLOPS</code></li></ul></li><li><p>此处K、M、G、T为数量单位，<strong>要与文件大小的指标区分开</strong><br>$$<br>K=kilo=10^3  \\ M=million=10^6 \\ G=giga=10^9 \\ T=tera=10^{12}<br>$$</p></li></ul><h3 id="3-系统整体的性能指标"><a href="#3-系统整体的性能指标" class="headerlink" title="3 系统整体的性能指标"></a>3 系统整体的性能指标</h3><ul><li><p>数据通路带宽：数据总线一次所能并行传送的信息的位数（各个硬件部件通过数据总线传输数据）</p></li><li><p>吞吐量：指系统在单位时间内处理请求的数量</p></li><li><p>响应时间：指从用户向计算机发送一个请求，到系统对这个请求作出响应，并获得它所需的结果 的等待时间</p></li><li><p>基准程序（跑分软件）：用来测量计算机处理速度的一种程序。</p><p>便于被测量的计算机性能可以与运行相同的程序的其他计算机性能进行比较</p></li></ul><p>思考问题:</p><ul><li>Q：主频高的CPU一般比主频低的CPU快吗？</li><li>A：不一定，需要看CPI，以及不同指令系统<br>(如果指令系统做过优化，即使主频和CPI不占优势，也有可能在某个方面性能更强)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述(2.2处理机调度)</title>
      <link href="/2022/04/19/operating_system2-2/"/>
      <url>/2022/04/19/operating_system2-2/</url>
      
        <content type="html"><![CDATA[<h1>操作系统——2.2 处理机调度</h1><h2 id="一、基本概念-4">一、基本概念</h2><p>进程调度（低级调度），就是按照某种算法，从就绪队列中，选择一个进程，为其分配处理机。</p><p>当有一堆任务要处理的时候，由于资源有限，这些事情没办法同时处理，这就需要确定某种规则来决定处理这些任务的顺序，这就是<strong>调度</strong>研究的问题。</p><p>一些概念的介绍：</p><ul><li>作业：一个具体的运行任务</li><li>用户向系统提交一个作业 <strong>≈</strong>用户让操作系统启动一个程序（来处理一个具体的任务）</li></ul><h3 id="1-1高级调度（作业调度）-4">1.1高级调度（作业调度）</h3><p>按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入会建立PCB，调出时才撤销PCB。</p><ul><li>简单理解就是：好几个程序需要启动，这个调度方式要确定先调度哪个。</li><li>***作业控制块（JCB）：**操作系统想用户提供的一组作业控制语言，用户将这种语言写作业说明书，然后程序、数据和作业一起交给系统操作员。</li><li>*多道批处理系统通常配有作业调度，其他系统中通常不需要配置作业调度。</li></ul><h3 id="1-2-中级调度（内存调度）-4">1.2 中级调度（内存调度）</h3><p>按照某种策略决定将那个处于挂起状态的进程重新调入内存。</p><ul><li><p>引入中级调度的目的是提高内存利用率和系统吞吐量。</p></li><li><p>内存不够时，可将那些暂时用不上的进程调度至外存等待，等内存空闲或者进程需要运行的时候再重新调入内存。</p></li><li><p>此时进程状态为<strong>挂起态</strong>，被挂起的进程PCB会被组织成<strong>挂起队列</strong>。</p></li></ul><p>中级调度实际上是存储器管理中的对换功能。</p><ul><li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率比高级调度更高。</li></ul><h3 id="1-3-低级调度（进程调度-处理机调度）-4">1.3 低级调度（进程调度 / 处理机调度）</h3><p>按照某种策略，从就绪队列中选取一个进程，将处理机分配给它。</p><p>这是一种最基本的调度，调用频率最高。</p><h3 id="1-4-进程的挂起-4">1.4 进程的挂起</h3><p>被挂起的进程称为 <u>挂起态（suspend）</u></p><p>挂起态可以进一步分为<strong>就绪挂起</strong>和<strong>阻塞挂起</strong>。</p><ul><li>进程在就绪态可以挂起为就绪挂起，就绪挂起可以激活为就绪态</li><li>进程在阻塞态可以挂起为阻塞挂起，阻塞挂起可以激活为阻塞态</li><li>阻塞挂起可以在事件出现的时候变成就绪挂起</li><li>并且，在创建态和运行态的进程，也可以直接挂起为就绪挂起</li></ul><p><strong>！挂起和阻塞的区别：</strong></p><ul><li>两种状态都是参数不能获得CPU的服务的</li><li><strong>挂起态</strong>是将进程调到外存去了，<strong>阻塞态</strong>下的进程还在内存中。</li><li>有的操作系统会把<strong>就绪挂起</strong>，<strong>阻塞挂起</strong>分为两个挂起队列，甚至会根据阻塞原因不同，把挂起队列细分为多个队列。</li></ul><table><thead><tr><th>调度</th><th>调度发生在</th><th>发生频率</th><th>对进程状态的影响</th></tr></thead><tbody><tr><td>高级调度（作业调度）</td><td>外存-&gt;内存（面向作业）</td><td>最低</td><td>无-&gt;创建态-&gt;就绪态</td></tr><tr><td>中级调度（内存调度）</td><td>外存-&gt;内存（面向进程）</td><td>中等</td><td>挂起态-&gt;就绪态（阻塞挂起-&gt;阻塞态）</td></tr><tr><td>低级调度（进程调度）</td><td>内存-&gt;CPU</td><td>最高</td><td>就绪态-&gt;运行态</td></tr></tbody></table><h2 id="二、进程调度方式-4">二、进程调度方式</h2><h3 id="2-1进程调度的时机-4">2.1进程调度的时机</h3><p><strong>！<strong>什么时候</strong>需要</strong>进程调度</p><ul><li><p>当前运行的进程<strong>主动放弃</strong>处理机</p><ul><li>进程终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（如：等待IO）</li><li>有的系统中，只允许进程主动放弃处理机</li></ul></li><li><p>当前运行的进程<strong>被动放弃</strong>处理机</p><ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如：IO中断）</li><li>有更高优先级的进程进入就绪队列<ul><li>有的系统中，当有更紧急的任务需要处理的时候，也会强行剥夺处理机（被动放弃）</li></ul></li></ul></li></ul><p><strong>！<strong>什么时候</strong>不能</strong>进程调度</p><ul><li><strong>处理中断的过程中</strong>：处理中断过程复杂，与硬件密切相关，很难在冲段处理的时候进行进程切换</li><li>进程在<strong>操作系统内核程序临界区中</strong>。但是进程在普通临界区中是可以进行调度和切换的。</li><li>在<strong>原子操作过程中（原语）</strong>。原子操作不可中断（如修改PCB中进程状态标志，并放置在相应队列）</li></ul><p><strong>！eg：<strong>进程在</strong>操作系统内核临界区</strong>中<strong>不能</strong>进行调度切换（√）</p><p><strong>！eg：<strong>进程处于</strong>临界区</strong>时<strong>不能</strong>进行处理机调度（×）</p><p><strong>！临界资源：<strong>一个时间段内只允许一个进程使用的资源。个进程需要</strong>互斥地</strong>访问临界资源。</p><p>**！临界    区：**访问临界资源的那段代码。</p><p><strong>内核程序临界区</strong>一般是用来访问<strong>某种内核数据结构的</strong>，比如说进程的就绪队列（由各个就绪进程的PCB组成）</p><ul><li>举个栗子：</li></ul><p>比如有一个内核进程，要访问就绪队列</p><pre class="mermaid">graph LRA(进程) --&gt;B(就绪队列)</pre><p>那就需要先锁住<span class="github-emoji"><span>🔒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f512.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>就绪队列 。如果还没退出临界区（还没解锁）就进行进程调度，但经常调度相关程序也需要访问就绪队列，此时就绪队列又被锁住了，因此有无法顺利进行进程调度。</p><p>由此可见，内核程序临界区访问的临界资源，如果不尽快释放，很有可能因此影响到操作系统内核的其他管理工作。所以，访问内核程序临界区期间不可以进行调度与切换。</p><ul><li>再举个栗子：</li></ul><p>有一个进程要控制打印机，在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但是打印机是慢速的设备，如果一直不允许进程调度，会导致CPU一直空闲。</p><p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。访问普通临界区时可以进行调度与切换。</p><h3 id="2-1-进程调度的方式-4">2.1 进程调度的方式</h3><h5 id="非剥夺方式（非抢占方式）-4">非剥夺方式（非抢占方式）</h5><p>只允许进程主动放弃处理机，如果运行过程中有更紧迫的任务到达，当前进程还会继续使用处理机，直到该进程终止或主动进入阻塞态。</p><ul><li>实现简单，系统开销小，但无法及时处理紧急任务。适用早期的批处理系统。</li></ul><h5 id="剥夺方式（抢占方式）-4">剥夺方式（抢占方式）</h5><p>当一个进程正在处理机上执行时，如果有一个更重要的任务到达，则立即暂停正在执行的进程，将处理机分配给那个紧迫的进程。</p><ul><li>可以优先处理更紧急的进程，也可以让各个进程按时间片轮流执行的功能（通过使用时钟中断）。适用于分时操作系统，实时操作系统。</li></ul><h5 id="细分进程调度-4">细分进程调度</h5><ul><li><p>狭义的进程调度：从就绪队列中选中一个要运行的进程</p></li><li><p>广义的进程调度：包含了选择进程和进程切换两个步骤</p><ul><li>对原来运行的进程的数据进行保存</li><li>对新进程的数据恢复（通常这些信息保存在PCB）</li><li>！进程切换是有代价的。因此如果过于频繁的进行进程调度、切换，必然会降低整个系统的运行效率。并不是调度越频繁、并发度越高</li></ul></li></ul><h2 id="三、调度算法的评价指标-4">三、调度算法的评价指标</h2><h3 id="1-CPU利用率：-4">1 CPU利用率：</h3><ul><li>CPU处于忙碌的时间占总时间的比例。</li></ul><p>$$<br>利用率 = \frac{有效工作的时间}{总时间 – 空闲+工作的时间}<br>$$</p><h3 id="2-系统吞吐量：-4">2 系统吞吐量：</h3><ul><li>单位时间内完成的作业数量</li></ul><p>$$<br>系统吞吐量 = \frac{总完成的作业数量}{总共花费的时间}<br>$$</p><h3 id="3-周转时间：-4">3 周转时间：</h3><ul><li>作业提交给系统开始，到作业完成为止的时间间隔</li></ul><p>包括四个部分：</p><ul><li>作业在外存后备队列等待调度的时间（高级调度）</li><li>进程在就绪队列上等待调度的时间（低级调度）</li><li>进程上CPU执行的时间</li><li>进程等待I/O操作完成的时间<ul><li>其中后三项在作业整个处理的过程中，可能发生多次</li></ul></li></ul><p>$$<br>作业周转时间 = 作业完成时间 - 作业提交时间 \\<br>平均周转时间 = \frac{\sum_{i=1}^n作业n的周转时间}{作业数} \\<br>带权周转时间 = \frac{作业周转时间}{作业实际运行时间} \\ = \frac{作业完成时间 - 作业提交时间}{作业实际运行时间}\\<br>平均带权周转时间 = \sum_{i=1}^n 作业n的带权周转时间<br>$$</p><p>其中，带权周转时间可以理解为：周转时间比运行时间大多少倍。如果带权周转时间太大，说明原本只需要少量时间让CPU为其服务，却让他等待了很长的时间。</p><h3 id="4-等待时间：-4">4 等待时间：</h3><ul><li>指进程/作业<strong>处于等待处理机窗台时间之和</strong>。等待时间越长，用户满意度越低。</li></ul><p>因为处理机调度算法不影响作业执行或者I/O时间，只影响作业在就绪队列中等待所花的时间。</p><p>因此，衡量一个调度算法的优劣，只需要简单的看等待时间。</p><ul><li>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>。等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li><li>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后等待的时间，还要加上作业在外存后备队列中等待的时间</strong>。</li><li>一个作业总共需要被CPU服务多久，被I/O设备服务多久，一般情况下，是确定不变的。调度算法值影响作业、进程的等待时间。我们也可以使用<strong>平均等待时间</strong>来评价整体性能。</li></ul><h3 id="5-响应时间-4">5 响应时间</h3><ul><li>指用户提交请求到首次产生响应所使用的时间</li></ul><h2 id="四、调度算法-4">四、调度算法</h2><h3 id="1、先来先服务——FCFS-4">1、先来先服务——FCFS</h3><h4 id="1-算法思想-19">1 算法思想</h4><p>主要从<strong>公平</strong>的角度去考虑（类比食堂排队打饭的例子）</p><h4 id="2-算法规则-19">2 算法规则</h4><p>按照作业/进程到达的先后顺序进行服务</p><h4 id="3-用于作业-进程调度-19">3 用于作业/进程调度</h4><p>作业调度：考虑的是哪个作业先到达后备队列</p><p>进程调度：考虑的是哪个进程先到达就绪队列</p><h4 id="4-是否可抢占-19">4 是否可抢占</h4><p>使用非抢占式算法</p><h4 id="5-优缺点-16">5 优缺点</h4><ul><li>优点：公平，实现简单</li><li>缺点：排在长作业/进程后面的短作业需要等待很长的时间，带权周转时间很大，对短作业用户来说，体验不好。</li><li>总结：FCFS<strong>对长作业有利，对短作业不利</strong>。</li></ul><h4 id="6-是否会导致饥饿-19">6 是否会导致饥饿</h4><p>不会。排在前面的作业总会处理完。</p><ul><li>饥饿的概念：某个作业或者进程长时间得不到服务</li></ul><h3 id="2、短作业优先——SJF-4">2、短作业优先——SJF</h3><h4 id="1-算法思想-20">1 算法思想</h4><p>追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</p><h4 id="2-算法规则-20">2 算法规则</h4><p>最短的作业/进程优先得到服务（指要求服务的时间最短）</p><h4 id="3-用于作业-进程调度-20">3 用于作业/进程调度</h4><p>两种都可以用。对进程来说，叫**短进程优先（SPF，shortest process first）**算法</p><h4 id="4-是否可抢占-20">4 是否可抢占</h4><p>SJF和SPF是非抢占式的算法。但也有抢占式的版本，叫<strong>最短剩余时间优先算法（SRTN Shortest Remaining Time Next）</strong></p><ul><li><p>SRTN：当有进程<strong>加入就绪队列改变时就需要调度</strong>。如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间更短，则由新进程<strong>抢占</strong>处理机。当前运行进程重新回到就绪队列。</p><p><strong>! 另外</strong>，当一个进程完成时<sup class="refplus-num"><a href="#ref-f">[1]</a></sup>也需要用这种算法进行调度。  </p><ul id="refplus" style="display:none;"><li id="ref-f" data-num="1">[1]  进程主动放弃处理机的时候</li></ul><p></p></li><li><p>细节：</p><ul><li><p>平时讨论短作业优先默认是<code>SJF / SPF</code>，是非抢占式的</p></li><li><p>其实<code>SRTN</code>比<code>SJF</code>的平均的等待时间，平均周转时间要更少。</p><p>应该说：<strong>在所有进程同时可运行时</strong>，或者<strong>在所有进程都几乎同时到达的时候</strong>，采用<code>SJF</code>调度算法的平均等待时间，平均周转时间最少。</p></li><li><p>一般来说，<code>SJF</code>的平均等待时间和平均周转时间，比除了SRTN以外的算法（如FCFS）要更少。</p></li><li><p>不过说<code>SJF</code>是平均等待时间，平均周转时间最少，仍然是不够严谨的</p></li></ul></li></ul><h4 id="5-优缺点-17">5 优缺点</h4><ul><li>优点：“最短的” 平均等待时间、平均周转时间</li><li>缺点：<ul><li>不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿</strong>现象。</li><li>作业/进程的运行时间，是由用户提供的，并不一定完全准确，不一定真正可以实现短作业优先。</li><li>该算法完全没有考虑作业的紧迫程度，不能保证紧迫性作业会被及时处理。</li></ul></li></ul><h4 id="6-是否会导致饥饿-20">6 是否会导致饥饿</h4><p>会。如果源源不断有大量短作业/进程到来，可能会使长作业很长时间都得不到服务。产生饥饿现象。</p><p>如果一直得不到服务，则称之为 “饿死”。</p><h3 id="3、高响应比优先——HRRN-4">3、高响应比优先——HRRN</h3><h4 id="1-算法思想-21">1 算法思想</h4><p>综合考虑 作业/进程 的等待时间和要求服务的时间。</p><h4 id="2-算法规则-21">2 算法规则</h4><p>在每次调度时，先计算各个 作业/进程 的<strong>响应比</strong>，选择<strong>响应比最高的</strong> 作业/进程 为其服务。<br>$$<br>响应比 = \frac{等待时间+要求服务时间}{要求服务时间}<br>\geq 1<br>$$</p><h4 id="3-用于作业-进程调度-21">3 用于作业/进程调度</h4><p>都可以使用</p><h4 id="4-是否可抢占-21">4 是否可抢占</h4><p>非抢占式算法，只有当前运行中的作业或进程<strong>主动放弃处理机时</strong>，才需要调度，才需要计算响应比。调度时<strong>计算所有就绪进程的响应比，选中响应比最高的</strong>进程上处理机。</p><h4 id="5-优点-4">5 优点</h4><ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比夜壶越来越大，从而避免了长作业饥饿的问题。</li></ul><h4 id="6-是否会导致饥饿-21">6 是否会导致饥饿</h4><p>不会</p><ul><li>以上三种算法总结</li></ul><p>这几种算法主要关心对用户的公平性，平均周转时间，平均等待时间等评价系统性能的指标。但是不关心 “响应时间” ，也不区分任务的紧急程度。</p><p>因此，对用户来说，交互性很差，这三种算法一般适用于<strong>早期的批处理系统</strong>。</p><p>当然，<code>FCFS</code>也常结合其他算法使用。</p><h3 id="4、时间片轮转（RR-Round-Robin）-4">4、时间片轮转（RR, Round-Robin）</h3><h4 id="1-算法思想-22">1 算法思想</h4><p>公平地、轮流地为各个进程服务，让每个进程在一定时间内都可以得到响应</p><p><strong>！常用于分时操作系统，更注重 “响应时间”</strong></p><h4 id="2-算法规则-22">2 算法规则</h4><p>按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个<strong>时间片</strong>。</p><p>若进程未在一个时间片内执行完，则剥夺处理机，将进程程序放到就绪队列队尾重新排队。</p><p><strong>！时间片划分需要注意：</strong></p><ul><li><p>如果时间片太大：</p><p>使每个进程在一个时间片内就可以完成。则该算法会退化成FCFS（先到先服务）算法，并增大进程响应时间。</p></li><li><p>如果时间片太小：</p><p>会导致进程切换过于频繁，系统要花大量的时间来处理进程切换。从而导致实际用于进程执行的时间比例减少。</p></li><li><p>* 一般来说设计时间片时需要让切换进程的开销比例不超过 1%。</p></li></ul><h4 id="3-用于作业-进程调度-22">3 用于作业/进程调度</h4><p>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</p><h4 id="4-是否可抢占-22">4 是否可抢占</h4><p>抢占式算法。</p><p>若进程未能在时间片内运行完，将被强制剥夺处理机使用权。</p><p>由时钟装置发出的<strong>时钟中断</strong>来通知CPU时间片已到时。</p><h4 id="5-优缺点-18">5 优缺点</h4><ul><li><p>优点：</p><p>公平，响应快，适用于分时操作系统</p></li><li><p>缺点：</p><ul><li><p>由于高频率的进程切换，因此有一定的开销</p></li><li><p>不区分任务紧急程度</p></li></ul></li></ul><h4 id="6-是否会导致饥饿-22">6 是否会导致饥饿</h4><p>不会</p><h3 id="5、优先级调度算法-4">5、优先级调度算法</h3><h4 id="1-算法思想-23">1 算法思想</h4><p>实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</p><h4 id="2-算法规则-23">2 算法规则</h4><p>给每一个 作业/进程 各自的优先级，调度的时候选择优先级最高的 作业/进程 。</p><h4 id="3-用于作业-进程调度-23">3 用于作业/进程调度</h4><p>可用于作业调度、进程调度、以及I/O调度。</p><h4 id="4-是否可抢占-23">4 是否可抢占</h4><p>抢占式&amp;非抢占式。</p><p>区别：</p><ul><li>非抢占式只需在进程主动放弃处理机时进行调度即可</li><li>抢占式还需在就绪队列变化时，检查是否会发生进程之间的抢占</li></ul><p>要注意的是，就绪队列未必只有一个，可以按照优先级不同来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。</p><ul><li><p>优先级</p><ul><li><p>静态优先级：光剑进程时候确定的，之后一直不变</p><ul><li><p>通常来说：</p><ul><li><p>系统进程优先级 高于 用户进程</p></li><li><p>前台进程优先级 高于 后台进程</p></li><li><p>操作系统更偏好I/O型进程（I/O繁忙型进程）</p><p>I/O设备可以和CPU设备并行工作。</p><p>让I/O设备尽早投入工作，资源利用率、系统吞吐量会得到提升。</p></li><li><p>与I/O型进程先对的是<strong>计算型进程（CPU繁忙进程）</strong></p></li></ul></li></ul></li><li><p>动态优先级：创建的时候有个初始值，之后会根据情况动态地调整优先级</p><ul><li>如果进程在就绪队列中等待很长时间，就可以适当提升优先级</li><li>如果进程占用处理机很长时间，则可以适当降低优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可以适当提升优先级</li></ul></li></ul></li></ul><h4 id="5-优缺点-19">5 优缺点</h4><ul><li><p>优点：</p><p>用优先级区分任务紧急程度。适用于实时操作系统。可以灵活地调整对各个 作业/进程 的偏好程度</p></li><li><p>缺点</p><p>如果源源不断的有高优先级的进程进来，可能会导致饥饿</p></li></ul><h4 id="6-是否会导致饥饿-23">6 是否会导致饥饿</h4><p>会</p><h3 id="6、多级反馈队列-4">6、多级反馈队列</h3><h4 id="1-算法思想-24">1 算法思想</h4><p>对其他调度算法的整理集中</p><h4 id="2-算法规则-24">2 算法规则</h4><ol><li><p>设置多个就绪队列</p><p><strong>各级队列优先级 从高到低，时间片 从小到大</strong></p></li><li><p>新进程到大时，先进入1级队列，按<code>FCFS</code>原则排队等待被分配。</p><p>若用完时间片进程还未结束，则进入下一级队列的队尾。</p><p>如果此时已经在最下级的队列，则重新放回该队队尾。</p></li><li><p>只有第k级队列为空时，才会为k+1级的队列分配时间片</p></li></ol><h4 id="3-用于作业-进程调度-24">3 用于作业/进程调度</h4><p>用于进程调度</p><h4 id="4-是否可抢占-24">4 是否可抢占</h4><p>抢占式算法。</p><p>在k级队列的进程运行过程中，若更上级的队列中进了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p><h4 id="5-优缺点-20">5 优缺点</h4><ul><li><p>优点：</p><ul><li><p>对各类型进程相对公平（FCFS的优点）</p></li><li><p>每个新到达的进程都苦很快得到响应（RR的优点）</p></li><li><p>短进程只用较少的时间就可以完成（SPF的优点）</p></li><li><p>不比实现估计进程的运行时间（避免用户提供的运行时间不准确）</p></li><li><p>可以灵活地调整对各类进程的偏好程度，比如CPU密集型进程，I/O密集型进程</p><p>（可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高的优先级）</p></li></ul></li><li><p>缺点：</p><p>可能会导致饥饿</p></li></ul><h4 id="6-是否会导致饥饿-24">6 是否会导致饥饿</h4><p>会</p><p>如果源源不断有短进程进入队列，可能会导致饥饿</p><ul><li>后三种算法适用于交互式的系统（比如Unix就是使用多级反馈队列调度算法）</li></ul>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机知识 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy 总结笔记</title>
      <link href="/2022/04/17/numpy-summary/"/>
      <url>/2022/04/17/numpy-summary/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="numpy-总结笔记"><a href="#numpy-总结笔记" class="headerlink" title="numpy 总结笔记"></a>numpy 总结笔记</h1><p>偶然翻到一篇以前整理的numpy笔记，由于数据分析是人工智能很重要很基础的内容，因此稍作整理和大家共享</p><h2 id="一、Ndarray-对象"><a href="#一、Ndarray-对象" class="headerlink" title="一、Ndarray 对象"></a>一、Ndarray 对象</h2><p>ndarray 内部由以下内容组成：</p><ul><li><p>一个指向数据（内存 | 内存映射文件中的一块数据）的指针。</p></li><li><p>数据类型或 dtype，描述在数组中的 固定大小值的格子。</p></li><li><p>一个表示数组形状（shape）的元组，表各维度大小的元组。</p></li><li><p>一个跨度元组（stride），其中的整数指的是 为了前进到当前维度 下一个元素需要”跨过”的字节数。</p></li></ul><p> <img src="https://s2.loli.net/2022/04/17/D6L4eZEcpbjw1AR.png" alt="np-nparray"></p><p>跨度可以是负数，这样会使数组在内存中后向移动，切片中 obj[::-1] 或 obj[:,::-1] 就是如此。</p><p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p><p><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p><p>参数说明：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>object</strong></td><td>数组或嵌套的数列</td></tr><tr><td><strong>dtype</strong></td><td>数组元素的数据类型，可选</td></tr><tr><td><strong>copy</strong></td><td>对象是否需要复制，可选</td></tr><tr><td><strong>order</strong></td><td>创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td></tr><tr><td><strong>subok</strong></td><td>默认返回一个与基类类型一致的数组</td></tr><tr><td><strong>ndmin</strong></td><td>指定生成数组的最小维度</td></tr></tbody></table><h2 id="二、NumPy-数据类型"><a href="#二、NumPy-数据类型" class="headerlink" title="二、NumPy 数据类型"></a>二、NumPy 数据类型</h2><h3 id="1）：基本数据类型"><a href="#1）：基本数据类型" class="headerlink" title="1）：基本数据类型"></a>1）：基本数据类型</h3><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>bool_</td><td>布尔型数据类型（True 或者 False）</td></tr><tr><td>int_</td><td>默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td></tr><tr><td>intc</td><td>与 C 的 int 类型一样，一般是 int32 或 int 64</td></tr><tr><td>intp</td><td>用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td></tr><tr><td>int8</td><td>字节（-128 to 127）</td></tr><tr><td>int16</td><td>整数（-32768 to 32767）</td></tr><tr><td>int32</td><td>整数（-2147483648 to 2147483647）</td></tr><tr><td>int64</td><td>整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td>uint8</td><td>无符号整数（0 to 255）</td></tr><tr><td>uint16</td><td>无符号整数（0 to 65535）</td></tr><tr><td>uint32</td><td>无符号整数（0 to 4294967295）</td></tr><tr><td>uint64</td><td>无符号整数（0 to 18446744073709551615）</td></tr><tr><td>float_</td><td>float64 类型的简写</td></tr><tr><td>float16</td><td>半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td>float32</td><td>单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td>float64</td><td>双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td>complex_</td><td>complex128 类型的简写，即 128 位复数</td></tr><tr><td>complex64</td><td>复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td>complex128</td><td>复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><ul><li><p>numpy 的数值类型实际上是 dtype 对象的实例，并且对应唯一的字符，如 np.bool_，np.int32，np.float32，等等。</p></li><li><p>int8, int16, int32, int64 四种数据类型可以使用字符串 ‘i1’, ‘i2’,’i4’,’i8’ 代替</p></li></ul><h3 id="2）：数据类型对象dtype"><a href="#2）：数据类型对象dtype" class="headerlink" title="2）：数据类型对象dtype"></a>2）：数据类型对象dtype</h3><p>dtype 对象使用以下语法构造：</p><p><code>numpy.dtype(object, align, copy)</code></p><ul><li><p>object 要转换为的数据类型对象</p></li><li><p>align    如果为 true，填充字段使其类似 C 的结构体。</p></li><li><p>copy    复制 dtype 对象 ，若为 false，则是对内置数据类型对象的引用</p></li></ul><p>每个内建类型都有一个唯一定义它的字符代码，如下：        </p><table><thead><tr><th>字符</th><th>对应类型</th></tr></thead><tbody><tr><td>b</td><td>布尔型</td></tr><tr><td>i</td><td>(有符号) 整型</td></tr><tr><td>u</td><td>无符号整型 integer</td></tr><tr><td>f</td><td>浮点型</td></tr><tr><td>c</td><td>复数浮点型</td></tr><tr><td>m</td><td>timedelta（时间间隔）</td></tr><tr><td>M</td><td>datetime（日期时间）</td></tr><tr><td>O</td><td>(Python) 对象</td></tr><tr><td>S, a</td><td>(byte-)字符串</td></tr><tr><td>U</td><td>Unicode</td></tr><tr><td>V</td><td>原始数据 (void)</td></tr></tbody></table><p>实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(np.dtype(np.int32))&gt;int32print(np.dtype('i4'))&gt;int32print(np.dtype('&lt;i4'))&gt;int32print(np.dtype([('age',np.int8)]))&gt;[('age', 'i1')]dt = np.dtype([('age',np.int8)]) print(np.array([(10,),(20,),(30,)], dtype = dt))&gt;[(10,) (20,) (30,)]dt = np.dtype([('age',np.int8)]) a = np.array([(10,),(20,),(30,)], dtype = dt) print(a['age'])&gt;[10 20 30]student = np.dtype([('name','S20'), ('age', 'i1'), ('marks', 'f4')]) print(student)&gt;[('name', 'S20'), ('age', 'i1'), ('marks', 'f4')]student = np.dtype([('name','S20'), ('age', 'i1'), ('marks', 'f4')]) print(np.array([('abc', 21, 50),('xyz', 18, 75)], dtype = student))&gt;[('abc', 21, 50.0), ('xyz', 18, 75.0)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><h3 id="1）：数组属性"><a href="#1）：数组属性" class="headerlink" title="1）：数组属性"></a>1）：数组属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>ndarray.ndim</td><td>秩，即轴的数量或维度的数量</td></tr><tr><td>ndarray.shape</td><td>数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td>ndarray.size</td><td>数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td>ndarray.dtype</td><td>ndarray 对象的元素类型</td></tr><tr><td>ndarray.itemsize</td><td>ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td>ndarray.flags</td><td>ndarray 对象的内存信息</td></tr><tr><td>ndarray.real</td><td>ndarray 元素的实部</td></tr><tr><td>ndarray.imag</td><td>ndarray 元素的虚部</td></tr><tr><td>ndarray.data</td><td>包含实际数组元素的缓冲区由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr><tr><td>ndarray.reshape</td><td>ndarray重新分配大小，包括秩等等都可以变换</td></tr></tbody></table><p>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>C_CONTIGUOUS (C)</td><td>数据是在一个单一的C风格的连续段中</td></tr><tr><td>F_CONTIGUOUS (F)</td><td>数据是在一个单一的Fortran风格的连续段中</td></tr><tr><td>OWNDATA (O)</td><td>数组拥有它所使用的内存或从另一个对象中借用它</td></tr><tr><td>WRITEABLE (W)</td><td>数据区域可以被写入，将该值设置为 False，则数据为只读</td></tr><tr><td>ALIGNED (A)</td><td>数据和所有元素都适当地对齐到硬件上</td></tr><tr><td>UPDATEIFCOPY (U)</td><td>这个数组是其它数组的一个副本当这个数组被释放时，原数组的内容将被更新</td></tr></tbody></table><p>实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x = np.array([1,2,3,4,5]) print (x.flags)&gt;C_CONTIGUOUS : True&gt;F_CONTIGUOUS : True&gt;OWNDATA : True&gt;WRITEABLE : True&gt;ALIGNED : True&gt;WRITEBACKIFCOPY : False&gt;UPDATEIFCOPY : Falsea = np.array([[1,2,3],[4,5,6]]) a.shape = (3,2) print (a)&gt;[[1 2]  [3 4]  [5 6]]# 数组的 dtype 为 int8（一个字节） x = np.array([1,2,3,4,5], dtype = np.int8) print (x.itemsize) # 数组的 dtype 现在为 float64（八个字节） y = np.array([1,2,3,4,5], dtype = np.float64) print (y.itemsize)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>一个元素类型为float64的数组，itemsize属性值为8(float64占用64个bits，每个字节长度为8，所以64/8占用 8 个字节）</p></li><li><p>一个元素类型为complex32的数组item属性为4（32/8）</p></li></ul><h3 id="2）：创建数组"><a href="#2）：创建数组" class="headerlink" title="2）：创建数组"></a>2）：创建数组</h3><p><code>numpy.zeros(shape, dtype = float, order = 'C')</code></p><p><code>numpy.ones(shape, dtype = None, order = 'C')</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 默认为浮点数 x = np.ones(5) print(x) # 设置类型为整数 y = np.zeros((5,), dtype = np.int) print(y) # 自定义类型 z = np.zeros((2,2), dtype = [('x', 'i4'), ('y', 'i4')]) print(z)# 输出[1. 1. 1. 1. 1.][0 0 0 0 0][[(0, 0) (0, 0)] [(0, 0) (0, 0)]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）：从已有的数组创建数组"><a href="#3）：从已有的数组创建数组" class="headerlink" title="3）：从已有的数组创建数组"></a>3）：从已有的数组创建数组</h3><h4 id="1、asarray"><a href="#1、asarray" class="headerlink" title="1、asarray"></a>1、asarray</h4><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>任意形式的输入参数，可以是 列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</td></tr><tr><td>dtype</td><td>数据类型，可选</td></tr><tr><td>order</td><td>可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python">x = [(1,2,3),(4,5)] a = np.asarray(x) print (a)# 输出[(1, 2, 3) (4, 5)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、numpy-frombuffer"><a href="#2、numpy-frombuffer" class="headerlink" title="2、numpy.frombuffer"></a>2、numpy.frombuffer</h4><p>numpy.frombuffer 用于实现动态数组。</p><p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><p><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></p><ul><li>注：<br>buffer是字符串的时候，Python3默认str是Unicode 类型所以要转成bytestring在原str前加上b。</li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>buffer</td><td>可以是任意对象，会以流的形式读入</td></tr><tr><td>dtype</td><td>返回数组的数据类型，可选</td></tr><tr><td>count</td><td>读取的数据数量，默认为-1，读取所有数据</td></tr><tr><td>offset</td><td>读取的起始位置，默认为0</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python">s = b'Hello World' a = np.frombuffer(s, dtype = 'S1') print (a)# 输出[b'H' b'e' b'l' b'l' b'o' b' ' b'W' b'o' b'r' b'l' b'd']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、numpy-fromiter"><a href="#3、numpy-fromiter" class="headerlink" title="3、numpy.fromiter"></a>3、numpy.fromiter</h4><p>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p><p><code>numpy.fromiter(iterable, dtype, count=-1)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>iterable</td><td>可迭代对象</td></tr><tr><td>dtype</td><td>返回数组的数据类型</td></tr><tr><td>count</td><td>读取的数据数量，默认为-1，读取所有数据</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 使用 range 函数创建列表对象 list=range(5) it=iter(list) # 使用迭代器创建 ndarray x=np.fromiter(it, dtype=float) print(x)# 输出[0. 1. 2. 3. 4.]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4）：从数值范围创建数组"><a href="#4）：从数值范围创建数组" class="headerlink" title="4）：从数值范围创建数组"></a>4）：从数值范围创建数组</h3><h4 id="1、numpy-arange"><a href="#1、numpy-arange" class="headerlink" title="1、numpy.arange"></a>1、numpy.arange</h4><p>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象：</p><p><code>numpy.arange(start, stop, step, dtype)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>序列的起始值</td></tr><tr><td>stop</td><td>序列的终止值，若endpoint为true，该值包含于数列中</td></tr><tr><td>num</td><td>要生成的等步长的样本数量，默认为50</td></tr><tr><td>endpoint</td><td>该值为 true 时，数列中包含stop值，反之不包含，默认True</td></tr><tr><td>retstep</td><td>如果为 True 时，生成的数组中会显示间距，反之不显示</td></tr><tr><td>dtype</td><td>ndarray 的数据类型</td></tr></tbody></table><h4 id="2、numpy-logspace"><a href="#2、numpy-logspace" class="headerlink" title="2、numpy.logspace"></a>2、numpy.logspace</h4><p>numpy.logspace 函数用于创建一个于等比数列。格式如下：</p><p><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>序列的起始值为：base ** start</td></tr><tr><td>stop</td><td>序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中</td></tr><tr><td>num</td><td>要生成的等步长的样本数量，默认为50</td></tr><tr><td>endpoint</td><td>该值为true时，数列中中包含stop值，反之不包含，默认True</td></tr><tr><td>base</td><td>对数 log 的底数，取对数的时候 log 的下标</td></tr><tr><td>dtype</td><td>ndarray 的数据类型</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python">print (np.logspace(1.0, 2.0, num = 10))&gt;[ 10.           12.91549665     16.68100537      21.5443469  27.82559402        35.93813664   46.41588834     59.94842503      77.42636827    100.    ]  print (np.logspace(0,9,10,base=2))&gt;[  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、索引、切片"><a href="#3、索引、切片" class="headerlink" title="3、索引、切片"></a>3、索引、切片</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = np.arange(10) s = slice(2,7,2) # 从索引 2 开始到索引 7 停止，间隔为2 print (a[s])&gt;[2  4  6]b = a[2:7:2] # 从索引 2 开始到索引 7 停止，间隔为 2 print(b)&gt;[2  4  6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切片还可以包括省略号 <code>…</code>，来使选择元组的长度与数组的维度相同。 </p><p>如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = np.array([[1,2,3],[3,4,5],[4,5,6]]) print (a[...,1]) # 第2列元素 print (a[1,...]) # 第2行元素 print (a[...,1:]) # 第2列及剩下的所有元素# 输出&gt;[2 4 5]&gt;[3 4 5]&gt;[[2 3]  [4 5]  [5 6]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、高级索引"><a href="#4、高级索引" class="headerlink" title="4、高级索引"></a>4、高级索引</h4><ul><li>整数索引</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x = np.array([[1, 2], [3, 4], [5, 6]]) y = x[[0,1,2], [0,1,0]] print (y)# 输出[1  4  5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>布尔索引</li></ul><p>我们可以通过一个布尔数组来索引目标数组。</p><p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><p>如大于 5 的元素：<code>print (x[x &gt; 5])</code></p><p>使用 <code>~</code>（取补运算符）来过滤 NaN：</p><p><code>a = np.array([np.nan, 1,2,np.nan,3,4,5]) print (a[~np.isnan(a)])</code></p><ul><li>花式索引</li></ul><p>关于 np.ix_ 的具体使用：</p><p><code>x[np.ix_([1,5,7,2],[0,3,1,2])]</code>这句话会输出一个4*4的矩阵，其中的元素分别是：</p><pre class="line-numbers language-none"><code class="language-none">x[1,0] x[1,3] x[1,1] x[1,2]x[5,0] x[5,3] x[5,1] x[5,2]x[7,0] x[7,3] x[7,1] x[7,2]x[2,0] x[2,3] x[2,1] x[2,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相当于：</p><pre class="line-numbers language-none"><code class="language-none">y=np.array([[x[1,0], x[1,3], x[1,1], x[1,2]],\            [x[5,0], x[5,3], x[5,1],x[5,2]],\      [x[7,0] ,x[7,3], x[7,1], x[7,2]],\          [x[2,0], x[2,3], x[2,1], x[2,2]]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>就是说，如果 np.xi_ 中输入两个列表，则第一个列表存的是待提取元素的行标，第二个列表存的是待提取元素的列标，第一个列表中的每个元素都会遍历第二个列表中的每个值，构成新矩阵的一行元素。</p><h4 id="5、数组广播"><a href="#5、数组广播" class="headerlink" title="5、数组广播"></a>5、数组广播</h4><p>广播的规则:</p><ul><li><p>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</p></li><li><p>输出数组的形状是输入数组形状的各个维度上的最大值。</p></li><li><p>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</p></li><li><p>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</p></li></ul><p>简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li><p>数组拥有相同形状。</p></li><li><p>当前维度的值相等。</p></li><li><p>当前维度的值有一个是 1。</p></li></ul><p>若条件不满足，抛出 “ValueError: frames are not aligned” 异常。</p><h4 id="6、迭代器"><a href="#6、迭代器" class="headerlink" title="6、迭代器"></a>6、迭代器</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = np.arange(6).reshape(2,3) print ('迭代输出：') for x in np.nditer(a): print (x, end=", " ) # 迭代输出：0, 1, 2, 3, 4, 5, <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>控制遍历顺序</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">for x in np.nditer(a, order='F'):Fortran order，即是列序优先；for x in np.nditer(a.T, order='C'):C order，即是行序优先；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>修改数组中元素的值</li></ul><p>nditer 对象另一个可选参数 op_flags</p><p>默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only）</p><p>为了在遍历数组的同时，实现对数组元素值得修改</p><p>必须指定 read-write 或者 write-only 的模式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = np.arange(0,60,5) a = a.reshape(3,4) print ('原始数组：') print (a) print ('\n') for x in np.nditer(a, op_flags=['readwrite']): x[...]=2*x print ('改后数组：') print (a)#原始数组：改后数组：[[ 0  5 10 15][[  0  10  20  30] [20 25 30 35][ 40  50  60  70] [40 45 50 55]][ 80  90 100 110]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>外部循环</strong></p><p>nditer 类的构造器拥有 flags 参数，它可以接受下列值：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>c_index</td><td>可以跟踪 C 顺序的索引</td></tr><tr><td>f_index</td><td>可以跟踪 Fortran 顺序的索引</td></tr><tr><td>multi_index</td><td>每次迭代可以跟踪一种索引类型</td></tr><tr><td>external_loop</td><td>给出的值是具有多个值的一维数组，而不是零维数组</td></tr></tbody></table><h4 id="7、数组操作"><a href="#7、数组操作" class="headerlink" title="7、数组操作"></a>7、数组操作</h4><ul><li>修改数组形状</li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>reshape</td><td>不改变数据的条件下修改形状</td></tr><tr><td>flat</td><td>数组元素迭代器</td></tr><tr><td>flatten</td><td>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td>ravel</td><td>返回展开数组</td></tr></tbody></table><p><code>numpy.reshape(arr, newshape, order='C')</code></p><ul><li><p>arr：要修改形状的数组</p></li><li><p>newshape：整数或者整数数组，新的形状应当兼容原有形状</p></li><li><p>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。</p></li></ul><p><code>ndarray.flatten(order='C')</code></p><p><code>numpy.ravel(a, order='C')</code></p><ul><li><p>numpy.ravel() 展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，类似 C/C++引用reference），修改会影响原始数组。</p></li><li><p>翻转数组</p></li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>transpose</td><td>对换数组的维度</td></tr><tr><td>ndarray.T</td><td>和 self.transpose() 相同，转置</td></tr><tr><td>rollaxis</td><td>向后滚动指定的轴</td></tr><tr><td>swapaxes</td><td>对换数组的两个轴</td></tr></tbody></table><ul><li>修改数组维度</li></ul><table><thead><tr><th>维度</th><th>描述</th></tr></thead><tbody><tr><td>broadcast</td><td>产生模仿广播的对象</td></tr><tr><td>broadcast_to</td><td>将数组广播到新形状</td></tr><tr><td>expand_dims</td><td>通过在指定位置插入新的轴扩展数组形状</td></tr><tr><td>squeeze</td><td>从数组的形状中删除一维条目</td></tr></tbody></table><ul><li>numpy.broadcast ：</li></ul><p>用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x = np.array([[1], [2], [3]]) y = np.array([4, 5, 6])# 对 y 广播 x b = np.broadcast(x,y) # 它拥有 iterator 属性，基于自身组件的迭代器元组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>numpy.broadcast_to(array, shape, subok)：</p><p>将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</p></li><li><p>numpy.expand_dims(arr, axis)</p><p>arr：输入数组</p><p>axis：新轴插入的位置</p></li><li><p>numpy.squeeze(arr, axis)</p></li><li><p>连接数组</p></li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>concatenate</td><td>连接沿现有轴的数组序列</td></tr><tr><td>stack</td><td>沿着新的轴加入一系列数组。</td></tr><tr><td>hstack</td><td>水平堆叠序列中的数组（列方向）</td></tr><tr><td>vstack</td><td>竖直堆叠序列中的数组（行方向）</td></tr></tbody></table><p><code>numpy.concatenate((a1, a2, ...), axis)</code></p><ul><li><p>a1, a2, …：相同类型的数组</p></li><li><p>axis：沿着它连接数组的轴，默认为0，即为竖直方向链接。1为水平方向链接。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">#沿轴 0 连接两个数组：沿轴 1 连接两个数组：[[1 2][[1 2 5 6] [3 4][3 4 7 8]] [5 6] [7 8]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>numpy.stack(arrays, axis)</code></p><p>用于沿新轴连接数组序列</p><ul><li><p>arrays相同形状的数组序列</p></li><li><p>axis：返回数组中的轴，输入数组沿着它来堆叠</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 沿轴 0 堆叠两个数组：沿轴 1 堆叠两个数组：[[[1 2][[[1 2]  [3 4]] [5 6]] [[5 6][[3 4]  [7 8]]] [7 8]]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>numpy.hstack(array1, array2)    水平堆叠</p></li><li><p>numpy.vstack(array1, array2)    竖直堆叠</p></li><li><p>分割数组</p></li></ul><table><thead><tr><th>函数</th><th>数组及操作</th></tr></thead><tbody><tr><td>split</td><td>将一个数组分割为多个子数组</td></tr><tr><td>hsplit</td><td>将一个数组水平分割为多个子数组（按列）</td></tr><tr><td>vsplit</td><td>将一个数组垂直分割为多个子数组（按行）</td></tr></tbody></table><p><code>numpy.split(ary, indices_or_sections, axis)</code></p><ul><li><p>ary：被分割的数组</p></li><li><p>indices_or_sections：若是一个整数，就用该数平均切分，若是一个数组，为沿轴切分的位置（左开右闭）</p></li><li><p>axis：设置沿着哪个方向进行切分，默认为 0，水平切分。为 1 时，竖直切分。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">print (np.split(a,[4,7]))&gt;[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>数组元素添加&amp;删除</li></ul><table><thead><tr><th>函数</th><th>元素及描述</th></tr></thead><tbody><tr><td>resize</td><td>返回指定形状的新数组</td></tr><tr><td>append</td><td>将值添加到数组末尾</td></tr><tr><td>insert</td><td>沿指定轴将值插入到指定下标之前</td></tr><tr><td>delete</td><td>删掉某个轴的子数组，并返回删除后的新数组</td></tr><tr><td>unique</td><td>查找数组内的唯一元素</td></tr></tbody></table><p><code>numpy.resize(arr, shape)</code></p><p>函数返回指定大小的新数组。</p><p>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p><ul><li><p>arr：要修改大小的数组</p></li><li><p>shape：返回数组的新形状</p></li></ul><p><code>numpy.append(arr, values, axis=None)</code></p><p>函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 </p><p>输入数组的维度必须匹配否则将生成ValueError。</p><ul><li><p>append 函数返回的始终是一个一维数组。</p></li><li><p>arr：输入数组</p></li><li><p>values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</p></li><li><p>axis：默认为 None。当axis无定义时，是横向加成，****返回总是为一维数组****。</p><ul><li>当axis为0时，数组是加在下边（列数要相同）</li><li>当axis为1时，数组是加在右边（行数要相同）</li></ul></li></ul><p><code>numpy.insert(arr, obj, values, axis)</code></p><p>函数在给定索引之前，沿给定轴在输入数组中插入值。</p><p>如果值的类型转换为要插入，则它与输入数组不同。 </p><p>插入没有原地的，函数会返回一个新数组。</p><p>如果未提供轴，则输入数组会被展开。</p><ul><li><p>arr：输入数组</p></li><li><p>obj：在其之前插入值的索引</p></li><li><p>values：要插入的值</p></li><li><p>axis：沿着它插入的轴，如果未提供，则输入数组会被展开</p></li></ul><p><code>Numpy.delete(arr, obj, axis)</code></p><p>函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数情况一样，如果未提供轴参数，则输入数组将展开。</p><ul><li><p>arr：输入数组</p></li><li><p>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</p></li><li><p>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</p></li></ul><p><code>numpy.unique(arr, return_index, return_inverse, return_counts)</code></p><p>用于去除数组中的重复元素。</p><ul><li><p>arr：输入数组，若不是一维数组则会展开</p></li><li><p>return_index：为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</p></li><li><p>return_inverse：为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</p></li><li><p>return_counts：为true，返回去重数组中的元素在原数组中的出现次数</p></li></ul><h4 id="8、numpy位运算"><a href="#8、numpy位运算" class="headerlink" title="8、numpy位运算"></a>8、numpy位运算</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>bitwise_and</td><td>对数组元素执行位与操作</td></tr><tr><td>bitwise_or</td><td>对数组元素执行位或操作</td></tr><tr><td>invert</td><td>按位取反</td></tr><tr><td>left_shift</td><td>向左移动二进制表示的位</td></tr><tr><td>right_shift</td><td>向右移动二进制表示的位</td></tr></tbody></table><h2 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>对两个数组的逐个字符串元素进行连接</td></tr><tr><td>multiply()</td><td>返回按元素多重连接后的字符串</td></tr><tr><td>center()</td><td>居中字符串</td></tr><tr><td>capitalize()</td><td>将字符串第一个字母转换为大写</td></tr><tr><td>title()</td><td>将字符串的每个单词的第一个字母转换为大写</td></tr><tr><td>lower()</td><td>数组元素转换为小写</td></tr><tr><td>upper()</td><td>数组元素转换为大写</td></tr><tr><td>split()</td><td>指定分隔符对字符串进行分割，并返回数组列表</td></tr><tr><td>splitlines()</td><td>返回元素中的行列表，以换行符分割</td></tr><tr><td>strip()</td><td>移除元素开头或者结尾处的特定字符</td></tr><tr><td>join()</td><td>通过指定分隔符来连接数组中的元素</td></tr><tr><td>replace()</td><td>使用新字符串替换字符串中的所有子字符串</td></tr><tr><td>decode()</td><td>数组元素依次调用str.decode</td></tr><tr><td>encode()</td><td>数组元素依次调用str.encode</td></tr></tbody></table><h2 id="五、统计"><a href="#五、统计" class="headerlink" title="五、统计"></a>五、统计</h2><ul><li><p>numpy.amin()         用于计算数组中的元素沿指定轴的最小值。</p></li><li><p>numpy.amax()         用于计算数组中的元素沿指定轴的最大值。</p></li><li><p>numpy.ptp()            计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p></li><li><p>numpy.percentile(a, q, axis)</p><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 </p><ul><li><p>a: 输入数组</p></li><li><p>q: 要计算的百分位数，在 0 ~ 100 之间</p></li><li><p>axis: 沿着它计算百分位数的轴</p></li></ul><p>第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p><p>例子：入学考试成绩以百分位数的形式报告。假设某个考生在考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。这里的 p = 70。</p></li><li><p>numpy.median()         函数用于计算数组 a 中元素的中位数（中值）</p></li><li><p>numpy.mean()        返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p><p>算术平均值是沿轴的元素的总和除以元素的数量。</p></li><li><p>numpy.average()        根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。</p><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p><p>$$<br>加权平均值 = \frac{1*4+2*3+3*2+4*1}{4+3+2+1}<br>$$</p></li><li><p>标准差        <code>numpy.std = sqrt(mean((x - x.mean())**2))</code></p></li><li><p>方差            <code>numpy.var = mean((x - x.mean())** 2)</code></p></li></ul><h2 id="六、排序、条件刷选函数"><a href="#六、排序、条件刷选函数" class="headerlink" title="六、排序、条件刷选函数"></a>六、排序、条件刷选函数</h2><table><thead><tr><th>种类</th><th>速度</th><th>最坏情况</th><th>工作空间</th><th>稳定性</th></tr></thead><tbody><tr><td>‘quicksort’（快速排序）</td><td>1</td><td>O(n^2)</td><td>0</td><td>否</td></tr><tr><td>‘mergesort’（归并排序）</td><td>2</td><td>O(n*log(n))</td><td>~n/2</td><td>是</td></tr><tr><td>‘heapsort’（堆排序）</td><td>3</td><td>O(n*log(n))</td><td>0</td><td>否</td></tr></tbody></table><ul><li><p><code>numpy.sort(a, axis, kind, order)</code></p><ul><li><p>a: 要排序的数组</p></li><li><p>axis: 沿着排序数组的轴，若没有数组则会被展开，沿着最后的轴排序，0按列，1按行</p></li><li><p>kind: 默认’quicksort’</p></li></ul><p> -order: 如果数组包含字段，则是要排序的字段</p></li><li><p>numpy.argsort()            返回的是数组值从小到大的索引值。</p></li><li><p>numpy.lexsort()             用于对多个序列进行排序。</p></li></ul><p>想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><p>例子：在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = ('aaaa','arrr','raaa','rrmm')b = ('fy','sy','sy','fy')ind = np.lexsort((a,b)) print(ind)&gt;[0 3 1 2]print ([a[i] + ", " + b[i] for i in ind])&gt;['aaaa, fy', 'rrmm, fy', 'arrr, sy', 'raaa, sy']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>msort(a)</td><td>数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相当于 np.sort(a, axis=0)。</td></tr><tr><td>sort_complex(a)</td><td>对复数按照先实部后虚部的顺序进行排序。</td></tr><tr><td>partition(a, kth[, axis, kind, order])</td><td>指定一个数，对数组进行分区</td></tr><tr><td>argpartition(a, kth[, axis, kind, order])</td><td>可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</td></tr></tbody></table><ul><li><p>numpy.argmax() &amp; numpy.argmin()    分别沿给定轴返回最大和最小元素的索引。</p></li><li><p>numpy.nonzero()                 函数返回输入数组中非零元素的索引。</p></li><li><p>numpy.where()                     函数返回输入数组中满足给定条件的元素的索引。</p></li><li><p>numpy.extract()             函数根据某个条件从数组中抽取元素，返回满条件的元素。</p></li></ul><h2 id="七、字节交换"><a href="#七、字节交换" class="headerlink" title="七、字节交换"></a>七、字节交换</h2><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p><ul><li><p>大端模式：</p><p>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p></li><li><p>小端模式：</p><p>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p></li></ul><p>例如：在 C 语言中，一个类型为 int 的变量 x 地址为 0x100，那么其对应地址表达式&amp;x的值为 0x100。且x的四个字节将被存储在存储器的 0x100, 0x101, 0x102, 0x103位置。</p><p><img src="https://s2.loli.net/2022/04/17/nqu9VrwvxIR5SYG.png" alt="np-address"></p><ul><li>numpy.ndarray.byteswap()            将 ndarray 中每个元素中的字节进行大小端转换。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; A = np.array([1,256,8755],dtype=np.int16)&gt;&gt;&gt; print(list(map(hex,A)))['0x1', '0x100', '0x2233']&gt;&gt;&gt; print(A.byteswap(inplace=True))[  256     1 13090]&gt;&gt;&gt; print(list(map(hex,A)))['0x100', '0x1', '0x3322']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、线性代数"><a href="#八、线性代数" class="headerlink" title="八、线性代数"></a>八、线性代数</h2><table><thead><tr><th>函数</th><th>速度</th></tr></thead><tbody><tr><td>dot</td><td>两个数组的点积，即元素对应相乘</td></tr><tr><td>vdot</td><td>两个向量的点积</td></tr><tr><td>inner</td><td>两个数组的内积</td></tr><tr><td>matmul</td><td>两个数组的矩阵积</td></tr><tr><td>determinant</td><td>数组的行列式</td></tr><tr><td>solve</td><td>求解线性矩阵方程</td></tr><tr><td>inv</td><td>计算矩阵的乘法逆矩阵</td></tr><tr><td>linalg.det</td><td>计算矩阵的行列式</td></tr><tr><td>linalg.solve</td><td>求解线性矩阵方程</td></tr></tbody></table><h2 id="九、I-x2F-O"><a href="#九、I-x2F-O" class="headerlink" title="九、I/O"></a>九、I/O</h2><p>NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。</p><p>npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p><p>常用的 IO 函数：</p><ul><li><p>load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。</p></li><li><p>savez() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。</p></li><li><p>loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)</p></li><li><p>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</p><p>将数组保存到以 .npy 为扩展名的文件中。</p><p>它们是 Numpy 专用的二进制格式后的数据</p><p>使用 load() 函数来读取数据才可以正常显示</p><ul><li>file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。</li><li>arr: 要保存的数组</li><li>allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。</li><li>fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。</li></ul></li><li><p>numpy.savez(file, *args, **kwds)函数将多个数组保存到以 npz 为扩展名的文件中。</p><ul><li>file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。</li><li>args: 要保存的数组，可以用关键字参数为数组起名，非关键字参数传递的数组会自动起名为 arr_0, arr_1, …　。</li><li>kwds: 要保存的数组使用关键字名称。</li></ul></li><li><p>savetxt() 以简单的文本文件格式存储数据，对应使用 loadtxt() 函数来获取数据。</p></li></ul><p><code>np.loadtxt(FILENAME, dtype=int, delimiter=' ')</code></p><p><code>np.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></p><p><strong>参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a=np.arange(0,10,0.5).reshape(4,-1) np.savetxt("out.txt",a,fmt="%d",delimiter=",") # 改为保存为整数，以逗号分隔 b = np.loadtxt("out.txt",delimiter=",") # load 时也指定为逗号分隔 print(b)# 输出[[0. 0. 1. 1. 2.] [2. 3. 3. 4. 4.] [5. 5. 6. 6. 7.] [7. 8. 8. 9. 9.]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速入门 Markdown(新手向)</title>
      <link href="/2022/04/16/markdown-quick-get-start/"/>
      <url>/2022/04/16/markdown-quick-get-start/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="快速学习Markdown"><a href="#快速学习Markdown" class="headerlink" title="快速学习Markdown"></a>快速学习Markdown</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p><p><strong>本篇可能是目录结构最混乱的文章，<em>跟紧带序号的标题</em>，开始学习吧 <span class="github-emoji"><span>☀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2600.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ）</strong></p><h2 id="1、Markdown-应用"><a href="#1、Markdown-应用" class="headerlink" title="1、Markdown 应用"></a>1、Markdown 应用</h2><p>Markdown 能被使用来撰写电子书，如：Gitbook。</p><p>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p><p>本教程使用的是<code>Typora</code>。用vscode也是可以的，在vscode右侧栏扩展按钮下载<strong>Markdown Preview Enhanced</strong> 即可。</p><p>在<code>Typora</code>，用<code>ctrl + / </code>按键即可切换源码模式和预览模式。</p><h2 id="2、Markdown-标题"><a href="#2、Markdown-标题" class="headerlink" title="2、Markdown 标题"></a>2、Markdown 标题</h2><pre class="line-numbers language-none"><code class="language-none">2.1 我是一级标题=================2.2 我是二级标题-----------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下</p><h1 id="2-1-我是一级标题"><a href="#2-1-我是一级标题" class="headerlink" title="2.1 我是一级标题"></a>2.1 我是一级标题</h1><h2 id="2-2-我是二级标题"><a href="#2-2-我是二级标题" class="headerlink" title="2.2 我是二级标题"></a>2.2 我是二级标题</h2><p>用#号标记六级标题，参考如下效果</p><pre class="line-numbers language-none"><code class="language-none"># 2.3 一级标题## 2.4 二级标题### 2.5 三级标题#### 2.6 四级标题##### 2.7 五级标题###### 2.8 六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-3-一级标题"><a href="#2-3-一级标题" class="headerlink" title="2.3 一级标题"></a>2.3 一级标题</h1><h2 id="2-4-二级标题"><a href="#2-4-二级标题" class="headerlink" title="2.4 二级标题"></a>2.4 二级标题</h2><h3 id="2-5-三级标题"><a href="#2-5-三级标题" class="headerlink" title="2.5 三级标题"></a>2.5 三级标题</h3><h4 id="2-6-四级标题"><a href="#2-6-四级标题" class="headerlink" title="2.6 四级标题"></a>2.6 四级标题</h4><h5 id="2-7-五级标题"><a href="#2-7-五级标题" class="headerlink" title="2.7 五级标题"></a>2.7 五级标题</h5><h6 id="2-8-六级标题"><a href="#2-8-六级标题" class="headerlink" title="2.8 六级标题"></a>2.8 六级标题</h6><h2 id="3、Markdown字体"><a href="#3、Markdown字体" class="headerlink" title="3、Markdown字体"></a>3、Markdown字体</h2><p>markdown可以使用一下几种字体，参考如下效果：</p><pre class="line-numbers language-none"><code class="language-none">*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___~~删除线文本~~&lt;u&gt;带下划线文本&lt;/u&gt; #通过HTML的&lt;u&gt;&lt;/u&gt;标签带脚注文本，鼠标指一下会显示对应解释 [^tuoyou-hao]。[^tuoyou-hao]: 拓佑豪博客<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em><br><del>删除线文本</del><br><u>带下划线文本</u> #通过HTML的<u></u>标签<br>带脚注文本，鼠标指一下会显示对应解释<sup class="refplus-num"><a href="#ref-t">[1]</a></sup>。</p><ul id="refplus" style="display:none;"><li id="ref-t" data-num="1">[1]   拓佑豪博客</li></ul><p></p><h2 id="4、Markdown分割线"><a href="#4、Markdown分割线" class="headerlink" title="4、Markdown分割线"></a>4、Markdown分割线</h2><pre class="line-numbers language-none"><code class="language-none">**** * ******- - -----------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><hr><hr><hr><hr><hr><h2 id="5、Markdown-列表项"><a href="#5、Markdown-列表项" class="headerlink" title="5、Markdown 列表项"></a>5、Markdown 列表项</h2><h3 id="5-1-Markdown-无序列表"><a href="#5-1-Markdown-无序列表" class="headerlink" title="5.1 Markdown 无序列表"></a>5.1 Markdown 无序列表</h3><pre class="line-numbers language-none"><code class="language-none">* 文本* 文本+ 文本+ 文本- 文本- 文本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下</p><ul><li>文本</li><li>文本</li></ul><ul><li>文本</li><li>文本</li></ul><ul><li>文本</li><li>文本</li></ul><h3 id="5-2-Markdown-有序列表"><a href="#5-2-Markdown-有序列表" class="headerlink" title="5.2 Markdown 有序列表"></a>5.2 Markdown 有序列表</h3><pre class="line-numbers language-none"><code class="language-none">1. 第一项2. 第二项3. 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="5-3-列表嵌套"><a href="#5-3-列表嵌套" class="headerlink" title="5.3 列表嵌套"></a>5.3 列表嵌套</h3><pre class="line-numbers language-none"><code class="language-none">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="6、Markdown区块"><a href="#6、Markdown区块" class="headerlink" title="6、Markdown区块"></a>6、Markdown区块</h2><pre class="line-numbers language-none"><code class="language-none">&gt; 最外层&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>当然，这些是可以互相嵌套的</p><pre class="line-numbers language-none"><code class="language-none">&gt; 列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt;&gt; + 第二项&gt; + 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><blockquote><p>列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li><p>第一项</p><blockquote><ul><li>第二项</li></ul></blockquote></li><li><p>第三项</p></li></ul></blockquote><h2 id="7、Markdown-代码"><a href="#7、Markdown-代码" class="headerlink" title="7、Markdown 代码"></a>7、Markdown 代码</h2><p><strong>单行代码：</strong></p><pre class="line-numbers language-none"><code class="language-none">`echo HelloWorld`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p><code>echo HelloWorld</code></p><p><strong>代码区块：</strong></p><pre class="line-numbers language-none"><code class="language-none">​```c#include &lt;stdio.h&gt;void main(){printf("Hello World\n");}//a.c​```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在第一行的<code>```</code>旁边指定语言，也可以不指定。效果如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void main(){printf("Hello World\n");}//a.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8、Markdown-链接"><a href="#8、Markdown-链接" class="headerlink" title="8、Markdown 链接"></a>8、Markdown 链接</h2><pre class="line-numbers language-none"><code class="language-none">这是一个链接 [拓佑豪的博客](tuoyou-hao.github.io)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p>这是一个链接 <a href="tuoyou-hao.github.io">拓佑豪的博客</a></p><p>在Typora，也可以直接打链接地址：<a href="https://tuoyou-hao.github.io/">https://tuoyou-hao.github.io</a></p><p><em><strong>高级链接</strong></em></p><pre class="line-numbers language-none"><code class="language-none">这个链接用 1 作为网址变量 [baidu][1]然后在文档的结尾为变量赋值（网址）[1]: https://www.baidu.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><p>这个链接用 1 作为网址变量 <a href="https://www.baidu.com/">baidu</a><br>然后在文档的结尾为变量赋值（网址）</p><h2 id="9、Markdown图片"><a href="#9、Markdown图片" class="headerlink" title="9、Markdown图片"></a>9、Markdown图片</h2><p>格式是 ![图片名称](图像地址)</p><p>如果你是在本地的图片，图像地址就可以用文件路径</p><p>如果你需要这个图像到哪儿都可以看，除了把图片的路径改为<code>相对路径</code>然后一并打包，还可以把图像放在<code>图床</code></p><p>效果如下：</p><p><img src="https://support.huaweicloud.com/productdesc-Atlas200DK1012/figure/zh-cn_image_0205566091.png" alt="atlas"></p><p>是不是感觉图像太大了？如果你的图像需要缩放，可以使用以下语句</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src=图片地址 style="zoom: 缩放比例;" /&gt;&lt;img src="https://support.huaweicloud.com/productdesc-Atlas200DK1012/figure/zh-cn_image_0205566091.png" style="zoom: 33%;" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://support.huaweicloud.com/productdesc-Atlas200DK1012/figure/zh-cn_image_0205566091.png" style="zoom: 33%;"><h2 id="10、Markdown表格"><a href="#10、Markdown表格" class="headerlink" title="10、Markdown表格"></a>10、Markdown表格</h2><p> Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。 </p><pre class="line-numbers language-none"><code class="language-none">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>文字对齐方式：</p><pre class="line-numbers language-none"><code class="language-none">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="11、Markdown其他技巧"><a href="#11、Markdown其他技巧" class="headerlink" title="11、Markdown其他技巧"></a>11、Markdown其他技巧</h2><h3 id="1、支持的-HTML-元素"><a href="#1、支持的-HTML-元素" class="headerlink" title="1、支持的 HTML 元素"></a>1、支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>kbd、b、i、em、sup 、ub、br</code>等 ，如：</p><pre class="line-numbers language-none"><code class="language-none">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;c&lt;/kbd&gt; 键复制文本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>c</kbd> 复制文本</p><h3 id="2、转义"><a href="#2、转义" class="headerlink" title="2、转义"></a>2、转义</h3><p>Markdown 使用了很多特殊符号来表示不同的符号，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： </p><pre class="line-numbers language-none"><code class="language-none">**文本加粗** \*\* 正常显示星号 \*\*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持在这些符号前面加上反斜杠，达到转义的目的：</p><pre class="line-numbers language-none"><code class="language-none">\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、Markdown表情"><a href="#3、Markdown表情" class="headerlink" title="3、Markdown表情"></a>3、Markdown表情</h3><p>可以使用各种emoji，<span class="github-emoji"><span>🔆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f506.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>或者<span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>等等都可以</p><p>想要使用这些emoji，可以前往这个链接<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji</a>，找到合适的emoji，点击一下就复制成功了，可以自由使用在Markdown里。</p><h3 id="4、数学公式、流程图等等"><a href="#4、数学公式、流程图等等" class="headerlink" title="4、数学公式、流程图等等"></a>4、数学公式、流程图等等</h3><p>markdown支持书写数学公式，代码建立流程图等等，后续会出专栏专门介绍。</p><ul><li>Latex数学矩阵表示：</li></ul><pre class="line-numbers language-none"><code class="language-none">$$\begin{Bmatrix}   a &amp; b \\\\   c &amp; d\end{Bmatrix}$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$$<br>\begin{Bmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{Bmatrix}<br>$$</p><ul><li>流程图：</li></ul><pre class="line-numbers language-none"><code class="language-none">​&lt;pre class="mermaid"&gt;graph LRA[方形] --&gt;B(圆角)    B --&gt; C{条件a}    C --&gt;|a=1| D[结果1]    C --&gt;|a=2| E[结果2]    F[横向流程图]​&lt;/pre&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">graph LRA[方形] --&gt;B(圆角)    B --&gt; C{条件a}    C --&gt;|a=1| D[结果1]    C --&gt;|a=2| E[结果2]    F[横向流程图]</pre>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新手 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述(2.1进程与线程)</title>
      <link href="/2022/04/12/operating_system2-1/"/>
      <url>/2022/04/12/operating_system2-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="操作系统——2-1-进程与线程"><a href="#操作系统——2-1-进程与线程" class="headerlink" title="操作系统——2.1 进程与线程"></a>操作系统——2.1 进程与线程</h1><h2 id="2-1-1-进程"><a href="#2-1-1-进程" class="headerlink" title="2.1.1 进程"></a>2.1.1 进程</h2><ul><li><p>程序，是静态的，就是一系列的指令集合。</p></li><li><p>进程，是动态的，是程序的一次执行过程。</p></li><li><p>当进程被创建的时候，操作系统会给该进程分配一个<strong>唯一的、不重复的ID</strong>——PID(Process ID)，进程ID</p></li><li><p>每个进程，操作系统会记录：</p><ul><li>其PID，进程所属用户ID（UID）</li><li>还要记录给每个进程分配了多少资源（如内存，正在使用哪些IO设备，正在使用那些文件，可用于实现操作系统对资源的管理。）</li><li>记录进程的运行情况（CPU使用时间、磁盘使用情况、网络流量使用情况等等，可用于实现操作系统对进程的控制、调度）</li><li>这些信息都会同意保存在一个数据结构<strong>PCB</strong>（process control block）中，即进程控制块，存放管理时需要的信息。</li></ul></li></ul><pre class="mermaid">graph LRPCB(PCB) --&gt;A(进程描述信息)    A --&gt;A1(进程标识符PID)    A --&gt;A2(用户标识符UID)PCB --&gt;B(进程控制和管理信息)    B --&gt;B1(CPU/磁盘/网络流量 使用统计)    B --&gt;B2(进程当前状态 就绪/阻塞/运行)PCB --&gt;C(资源分配清单)    C --&gt;C1(正在使用的文件)    C --&gt;C2(正在使用的内存区域)    C --&gt;C3(正在使用的IO设备)PCB --&gt;D(处理机相关信息)    D --&gt;D1(PSW/PC等 寄存器的值)</pre><ul><li>当进程被创建时，操作系统为期创建一个PCB。当进程运行结束，操作系统会将其收回。操作系统对进程进行管理工作所需信息都存在PCB中。</li></ul><pre class="mermaid">graph LRS(进程的组成) --&gt;PCBPCB --&gt;P1(进程描述信息)PCB --&gt;P2(进程控制和管理信息)PCB --&gt;P3(资源分配清单)PCB --&gt;P4(处理机相关信息)S --&gt;A(程序段)A --&gt;A1(程序的代码  指令序列)S --&gt;B(数据段)B --&gt;B1(运行过程中产生的各种数据)B --&gt;B2(如 程序中定义的变量)S1[准确来说, 应该是 进程实体的组成]</pre><p>PCB通常包含的内容：</p><table><thead><tr><th align="center">进程描述信息</th><th align="center">进程控制和管理信息</th><th align="center">资源分配清单</th><th align="center">处理机相关信息</th></tr></thead><tbody><tr><td align="center">进程标识符PID</td><td align="center">进程当前状态</td><td align="center">代码段指针</td><td align="center">通用寄存器值</td></tr><tr><td align="center">用户标识符UID</td><td align="center">进程优先级</td><td align="center">数据段指针</td><td align="center">地址寄存器值</td></tr><tr><td align="center"></td><td align="center">代码运行入口地址</td><td align="center">堆栈段指针</td><td align="center">控制寄存器值</td></tr><tr><td align="center"></td><td align="center">程序的外存地址</td><td align="center">文件描述符</td><td align="center">标志寄存器值</td></tr><tr><td align="center"></td><td align="center">进入内存时间</td><td align="center">键盘</td><td align="center">状态字</td></tr><tr><td align="center"></td><td align="center">处理机占用时间</td><td align="center">鼠标</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">信号量使用</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>PCB是给操作系统用的。<strong>PCB是进程存在的唯一标志！</strong></li><li>程序段、数据段是给进程自己使用的。和自身的运行逻辑有关</li></ul><p>进程，是动态的，是程序进行资源分配和调度的一个独立个体。</p><p>进程实体（进程映像）：是静态的，是进程某一时刻运行时的快照（照片）。进程实体可以反映进程在某一时刻的状态。</p><ul><li>一个进程的调度，就是操作系统决定让这个进程上CPU运行。</li></ul><p><strong>进程的特征</strong>：</p><ul><li><p>动态性：</p><p>是进程的最基本特征。进程是程序的一次执行过程，动态产生、变化和消亡</p></li><li><p>并发性：</p><p>内存中有多个进程实体。各个进程可以并发执行。</p></li><li><p>独立性：</p><p>课接受独立运行、调度、获得资源的基本单位</p><p>各个进程拥有的内存地址空间相互独立</p></li><li><p>异步性：</p><p>各自独立，不可预知的速度运行。操作系统要提供 <strong>进程同步机制</strong> 来解决异步问题</p></li><li><p>结构性：</p><p>每个进程都配有一个PCB。</p></li></ul><h2 id="2-1-2-进程的状态"><a href="#2-1-2-进程的状态" class="headerlink" title="2.1.2 进程的状态"></a>2.1.2 进程的状态</h2><p><strong>进程的状态</strong>：</p><ul><li><p>创建态：进程被创建时的状态。系统会为其分配资源，初始化PCB。</p></li><li><p>就绪态：进程创建完成的状态。<strong>但由于没有CPU，暂时不能运行</strong></p></li><li><p>运行态：进程正在CPU上运行。</p></li></ul><p>进程运行过程中，可能会请求等待某个时间的发生（如等待某种系统资源的分配，或者等待其他进程的响应）。所以还有：</p><ul><li>阻塞态：在这个事件发生之前，该进程无法继续运行。操作系统会将其设置为阻塞态。</li></ul><pre class="mermaid">graph LRA((新建)) --&gt; |创建|B(就绪)B --&gt;|调度|C(运行)C --&gt;|时间到|BC --&gt;|退出|E(终止)C --&gt;|事件等待|D(阻塞)D --&gt;|事件发生|B</pre><ul><li><p>就绪态 -&gt; 运行态：进程被调度</p></li><li><p>运行态 -&gt; 阻塞态：是一种主动行为，等待资源分配</p></li><li><p>阻塞态 -&gt; 就绪态：是一种被动行为，资源分配到位</p></li><li><p>运行态 -&gt; 就绪态：时间片结束时候会有适中中断，或者CPU被其他优先级更高的进程抢占</p></li><li><p>三种基本状态：运行态、就绪态、阻塞态。</p></li><li><p>PCB中会有个state表示进程的当前状态</p></li></ul><p><strong>进程的组织——链接方式</strong>：</p><ul><li>主要使用到了：执行指针、就绪队列指针、阻塞队列指针</li></ul><p>链式方式（系统管理一系列的队列，每个队列都会指向相应状态的PCB）大多数操作系统使用该方式</p><p>​        执行指针指向当前运行态（执行态）的进程</p><p>索引方式</p><p>​        给各个相应进程建立索引表，每个索引表的表项指向PCB</p><h2 id="2-1-3-进程控制"><a href="#2-1-3-进程控制" class="headerlink" title="2.1.3 进程控制"></a>2.1.3 进程控制</h2><p>实现进程的状态转换。进程控制需要用<strong>原语</strong>来实现。</p><p>原语的执行具有原子性，即允许过程只能一气呵成，期间不允许被中断。</p><p>可以用“关中断指令“和”开中断指令“这两个特权指令来实现原子性。</p><ul><li>没有关闭中断指令的时候，CPU每执行一句话就会检查是否有中断信号，有的换就中断程序，去执行中断信号所对应的程序。</li><li>关闭了中断指令之后，即使有中断指令进来，CPU就不会理会，继续执行自己当前的指令。</li><li>执行了“开中断指令” ，才会检查刚才是否有中断信号。有的话，就马上转去中断处理程序。</li><li>在”关中断“与“开中断”之间的指令就是原子性的，不可被中断。</li></ul><h3 id="2-1-3-1-进程的创建："><a href="#2-1-3-1-进程的创建：" class="headerlink" title="2.1.3.1 进程的创建："></a>2.1.3.1 进程的创建：</h3><ul><li>创建原语：<ul><li>申请空白的PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入 就绪队列</li></ul></li><li>引起进程创建的事件<ul><li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理这个请求</li><li>应用请求：由用户进程主动请求创建的一个子进程</li></ul></li></ul><h3 id="2-1-3-2-进程的摧毁："><a href="#2-1-3-2-进程的摧毁：" class="headerlink" title="2.1.3.2 进程的摧毁："></a>2.1.3.2 进程的摧毁：</h3><ul><li>撤销原语：<ul><li>从PCB集合中找到终止进程的PCB</li><li>若该进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程（进程之间的关系是树形的结构）</li><li>将该进程拥有的所有资源归还给父进程或者操作系统</li><li>删除PCB</li></ul></li><li>引起进程终止的时间<ul><li>正常结束：进程自己请求终止（exit系统调用）</li><li>异常结束：整数除0、非法使用特权指令然后被操作系统强行杀掉</li><li>外接干预：命令行<kbd>ctrl</kbd>+<kbd>c</kbd>键直接中断代码运行</li></ul></li></ul><h3 id="2-1-3-3-进程的阻塞和唤醒："><a href="#2-1-3-3-进程的阻塞和唤醒：" class="headerlink" title="2.1.3.3 进程的阻塞和唤醒："></a>2.1.3.3 进程的阻塞和唤醒：</h3><ul><li>进程的阻塞<ul><li>阻塞原语<ul><li>找到要阻塞的进程 对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为 “阻塞态” ，暂停进程的运行</li><li>将PCB插入相应事件的等待队列</li></ul></li><li>引起进程阻塞的事件<ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul></li></ul></li><li>进程的唤醒<ul><li>唤醒原语<ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列溢出，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul></li><li>引起进程唤醒的事件：等待的事件发生了。 <strong>一个进程因为什么事情被阻塞，就应该由这个事件来唤醒</strong> 。</li></ul></li></ul><h3 id="2-1-3-4进程的切换："><a href="#2-1-3-4进程的切换：" class="headerlink" title="2.1.3.4进程的切换："></a>2.1.3.4进程的切换：</h3><ul><li>切换原语<ul><li>将运行环境信息存入PCB</li><li>PCB移入相应队列</li><li>选择另一个进程执行，更新其PCB</li><li>根据PCB恢复新进程所需的运行环境</li></ul></li><li>引起进程切换的时间<ul><li>当前进程的时间片计时结束</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ul><p>无论哪个进程要控制原语，要做的无非三类事情：</p><ol><li><p>更新PCB中的信息</p></li><li><p>将PCB插入合适的队列</p></li><li><p>分配/回收资源</p></li></ol><h2 id="2-1-4-进程通信"><a href="#2-1-4-进程通信" class="headerlink" title="2.1.4 进程通信"></a>2.1.4 进程通信</h2><pre class="mermaid">graph LRA(进程通信) --&gt;B(共享存储)B --&gt;B1(基于数据结构的共享)B --&gt;B2(基于存储区的共享)A --&gt;C(消息传递)C --&gt;C1(直接通信)C --&gt;C2(间接通信)A --&gt;D(管道通信)</pre><h3 id="2-1-4-1进程通信"><a href="#2-1-4-1进程通信" class="headerlink" title="2.1.4.1进程通信"></a>2.1.4.1进程通信</h3><p>进程之间的信息交换。为了保证安全，一个进程不能直接访问另一个进程的地址空间</p><ul><li><p>共享空间：<strong>两个进程对共享空间的访问必须是互斥的</strong>（互斥访问通过操作系统给的工具实现）。操作系统只提供共享空间和同步互斥工具（如P、V操作）</p><ul><li>基于数据结构共享：比如共享空间只能存放长度为10的数组，这种方式速度慢，限制多，是一种低级的通信方式</li><li>基于存储区的共享：在内存中划出一块共享存储区，数据的形式、存放的位置都是由进程来控制，而不是操作系统。该共享方式更快，是一种高级的通信方式。</li></ul></li><li><p>管道通信：</p><p>管道是指用于连接读写进程的一个共享文件，又叫做<strong>pipe</strong>文件。其实就是在内存中开辟一个大小固定的缓冲区。</p><ul><li>一个管道只能采用<code>半双工通信</code>，某一时间段内只能实现<strong>单向</strong>的传输。如果要实现<code>双向同时通信</code>，则需要设置两个管道。</li><li>各个进程要<strong>互斥</strong>地访问管道。</li><li>数据以字符流的形式进入管道。<ul><li>当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走</li><li>当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li></ul></li><li>如果没写满，就不允许读；如果没读空，就不允许写</li><li>数据一旦被读出，就会从管道中被抛弃。这就意味着读进程最多只能有一个。否则可能会出现读错数据的情况</li></ul></li></ul><h3 id="2-1-4-2-消息传递"><a href="#2-1-4-2-消息传递" class="headerlink" title="2.1.4.2 消息传递"></a>2.1.4.2 消息传递</h3><p>进程之间的数据交换以<strong>格式化的消息（message）</strong>为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p><p>消息分为消息头和消息体两个板块</p><ul><li>消息头：包括发送进程ID、接受进程ID、消息类型、消息长度等等信息（计算机网络中发送的“报文”，就是一种格式化消息）</li><li>消息体：消息本体</li></ul><p>消息传递有两种方式：</p><ul><li>直接通信方式：消息直接挂到接受进程的消息缓冲队列上</li><li>间接通信方式：消息先发送到中间实体（信箱）中，也成为“信箱通信方式”，如：计算机网络中的电子邮件系统</li></ul><h2 id="2-1-5-线程的概念"><a href="#2-1-5-线程的概念" class="headerlink" title="2.1.5 线程的概念"></a>2.1.5 线程的概念</h2><p>有的进程可能需要 “同时” 做很多事情，传统的进程只能串行执行一系列程序。所以引入了 “线程” ，来增加并发度。</p><p>可以把线程理解为“轻量级进程”</p><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等等都是分配给进程的）</p><p>带来的变化：</p><ul><li>资源分配、调度<ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul></li><li>并发性<ul><li>传统进程机制中，只能进程间并发</li><li>引入线程后，各个线程之间也能并发，提升了并发度</li></ul></li><li>系统开销<ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li><li>引入线程后，并发所带来的系统开销减小。</li><li>线程间并发，如果是统一进程内的线程切换，则不需要切换进程环境，系统开销小</li></ul></li></ul><p>线程的属性：</p><ul><li><p>线程是处理机调度的单位。</p><ul><li>同一个进程中线程切换，不引起进程切换。</li><li>不同的进程中线程切换，会引起进程切换。</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul></li><li><p>多CPU计算机中，各个线程可以占用不同CPU</p></li><li><p>每个线程都拥有一个线程ID，线程控制块TCB，TCB记录了线程执行的寄存器和栈等现场状态。</p><ul><li>线程也有就绪、阻塞、运行三种基本状态。</li><li>不同线程可以执行相同的程序</li></ul></li><li><p>线程几乎不拥有系统资源。但线程可以访问其隶属进程的系统资源。属于同一进程的所有线程都具有相同的地址空间</p></li><li><p>同一进程的不同线程间贡献进程的资源</p></li><li><p>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</p></li></ul><h2 id="2-1-6-多线程"><a href="#2-1-6-多线程" class="headerlink" title="2.1.6 多线程"></a>2.1.6 多线程</h2><pre class="mermaid">graph LRA(线程) --&gt;B(实现方式)B --&gt;B1(用户级线程)B --&gt;B2(内核级线程)A --&gt;C(多线程模型)C --&gt;C1(一对一模型)C --&gt;C2(多对一模型)C --&gt;C3(多对多模型)</pre><h3 id="2-1-6-1用户级线程（User-Level-Thread，ULT）"><a href="#2-1-6-1用户级线程（User-Level-Thread，ULT）" class="headerlink" title="2.1.6.1用户级线程（User-Level-Thread，ULT）"></a>2.1.6.1用户级线程（User-Level-Thread，ULT）</h3><ul><li><p>由应用程序在用户控件完成，用户才能感知到线程的存在，而内核意识不到线程的存在。</p><p>应用于早期操作系统，线程的实现是使用线程库实现的。</p><p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p></li><li><p>用户级线程有应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都有<strong>应用程序负责</strong>（包括线程切换）</p></li><li><p>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统干预</p></li><li><p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程” 就是 <strong>从用户视角看，能看到的线程</strong>。</p></li><li><p>优点：</p><ol><li>用户级线程的切换在用户控件即可完成，不需要切换到核心态。</li><li>线程管理的系统开销小，效率高。</li><li>调度算法可以是进程专用的，不同的进程可以根据自人需要，对自己的线程选择不同的调度算法。</li><li>用户级线程的实现与操作系统无关，对象池管理的代码是属于用户程序的一部分。</li></ol></li><li><p>缺点：</p><ol><li>当一个用户级线程被阻塞后，<strong>整个进程都会被阻塞</strong>，<strong>并发度不高</strong>。</li><li>多个线程不可在多核处理机上并行运行。不能发挥多处理机的优势，内核每次分配给一个进程的只有一个CPU，因此进程中仅有一个线程能执行。</li></ol></li></ul><pre class="mermaid">graph TBA1(用户级线程) ---|用户空间|S(线程库)A2(用户级线程) ---|用户空间|SA3(用户级线程) ---|用户空间|Ssubgraph kernel_area    P(内核级线程)endS ---|内核空间|PT((用户级方式))</pre><h3 id="2-1-6-2-内核级线程（KLT"><a href="#2-1-6-2-内核级线程（KLT" class="headerlink" title="2.1.6.2 内核级线程（KLT)"></a>2.1.6.2 内核级线程（KLT)</h3><ul><li><p>内核级线程的管理工作由操作系统内核完成</p></li><li><p>线程调度、切换等工作都由内核负责。因此<strong>内核级线程的切换必须在核心态下才能完成</strong>。</p></li><li><p>操作系统会为每个内核级线程创建TCB（Thread Control Bolck，线程控制块）</p></li><li><p>优点：</p><ol><li>能发挥多处理机的优势，并发能力强。多线程可以在多核处理机上并行执行。</li><li>如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机。</li><li>内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。</li><li>内核本身也可以采用多线程技术，提高系统的执行速度和效率。</li></ol></li><li><p>缺点：</p><p>同一进程中的线程切换，需要从用户态转为核心态，系统开销较大。</p><p>因为用户进程的线程在用户态执行，而线程调度和管理需要在内核实现</p></li></ul><pre class="mermaid">graph TBA1(用户级线程) ---|用户空间|P1A2(用户级线程) ---|用户空间|P2A3(用户级线程) ---|用户空间|P3subgraph kernel_area    P1 ---|内核空间|P(内核级线程)    P2 ---|内核空间|P    P3 ---|内核空间|PendT((内核级方式))</pre><h3 id="2-1-6-3-组合方式"><a href="#2-1-6-3-组合方式" class="headerlink" title="2.1.6.3 组合方式"></a>2.1.6.3 组合方式</h3><p>同一个进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞，结合了ULT与KLT的优势，并克服了各自的不足</p><p>实现线程库主要方式有</p><ul><li>在用户空间中提供一个没有内核支持的库</li><li>实现由操作系统直接支持的内核级的库</li></ul><pre class="mermaid">graph TBA1(用户级线程) ---|用户空间|S1(线程库1)A2(用户级线程) ---|用户空间|S1A3(用户级线程) ---|用户空间|S1A4(用户级线程) ---|用户空间|S2(线程库2)subgraph kernel_area    P1(内核级线程)    P2(内核级线程)    P3(内核级线程)endS1 ---|内核空间|P1S1 ---|内核空间|P2S2 ---|内核空间|P3T((组合 方式))</pre><h3 id="2-1-6-4-多线程模型"><a href="#2-1-6-4-多线程模型" class="headerlink" title="2.1.6.4 多线程模型"></a>2.1.6.4 多线程模型</h3><h4 id="1、一对一模型"><a href="#1、一对一模型" class="headerlink" title="1、一对一模型"></a>1、一对一模型</h4><p>类比内核级线程图</p><p>一个用户级线程映射到一盒内核级线程。每个用户进程有和用户线程一样多的内核级线程。</p><ul><li><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，<strong>并发能力强</strong>。多线程可以在多核处理机上运行</p></li><li><p>缺点：一个用户进程会占用多个内核级线程，线程切换又需要操作系统来完成，需要切换到核心态。<strong>线程管理的成本高，开销大</strong>。</p></li></ul><h4 id="2、多对一模型"><a href="#2、多对一模型" class="headerlink" title="2、多对一模型"></a>2、多对一模型</h4><p>类比用户级线程图</p><p>多个用户级线程映射到一个内核级线程，且一个进程只能被分配到一个内核级线程。</p><ul><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，系统管理的开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li><li><strong>！重点</strong>：操作系统只 “看得见” 内核级线程，因此只有内核级线程才是处理机分配的单位</li></ul><h4 id="3、多对多模型"><a href="#3、多对多模型" class="headerlink" title="3、多对多模型"></a>3、多对多模型</h4><p>类比组合模型图</p><ul><li><p>n个用户级线程映射到m个内核级线程<strong>（n&gt;=m）</strong>。每个用户级进程对应m个内核级线程。</p></li><li><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞）</p></li><li><p>克服了一对一模型中一个用户占用太多线程，开销太大的缺点</p></li><li><p>可以理解为：</p><ul><li>用户级线程是 “代码逻辑”的载体</li><li>内核级线程是 “运行机会”的载体</li><li>内核级线程才是处理机分配的单位</li></ul></li><li><p>一段 “代码逻辑”只有获得 “运行机会”，才能被CPU执行</p><ul><li>内核级线程中可以运行任意一个有映射关系的用户级线程代码</li><li>只有两个内核级线程中正在运行的代码逻辑全都阻塞，这个进程才会阻塞。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机知识 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atlas 200DK 初步环境配置指南</title>
      <link href="/2022/04/09/Atlas_200DK_first_Environment_configuration/"/>
      <url>/2022/04/09/Atlas_200DK_first_Environment_configuration/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Atlas-200DK-初步环境配置指南"><a href="#Atlas-200DK-初步环境配置指南" class="headerlink" title="Atlas 200DK 初步环境配置指南"></a>Atlas 200DK 初步环境配置指南</h1><p>本教程教你如何搭建Atlas 200DK开发运行环境，快速预备Atlas 200DK的开发</p><h2 id="一、配置VMware虚拟机开发环境"><a href="#一、配置VMware虚拟机开发环境" class="headerlink" title="一、配置VMware虚拟机开发环境"></a>一、配置VMware虚拟机开发环境</h2><h3 id="第一步，设置root密码"><a href="#第一步，设置root密码" class="headerlink" title="第一步，设置root密码"></a>第一步，设置root密码</h3><p><code>sudo passwd root</code></p><p>然后显示屏会跳出一句</p><p><code>[sudo] password for pi: </code></p><ol><li><p>pi是我设置的账号名</p></li><li><p>在这里需要输入你一开始设置的账户密码，并且是<strong>不会显示在屏幕上</strong></p></li><li><p>输入完毕你的账户密码，就设置root账户密码:<code>sudo passwd root</code></p><p>Enter new UNIX password: </p><p>Retype new UNIX password: </p><p>passwd: password updated successfully</p></li></ol><p>如以上显示则说明密码设置成功，请记住你的root密码</p><h3 id="第二步，换源（可选）"><a href="#第二步，换源（可选）" class="headerlink" title="第二步，换源（可选）"></a>第二步，换源（可选）</h3><p>（内容参照<a href="https://www.cnblogs.com/huang-y-x/p/11082168.html%EF%BC%8C%E5%8F%AF%E5%9C%A8%E9%87%8C%E9%9D%A2%E9%80%89%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%BA%90%EF%BC%89">https://www.cnblogs.com/huang-y-x/p/11082168.html，可在里面选用不同的源）</a></p><p>1：备份原来的源</p><p><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p><p>2：进入root账户</p><p><code>su</code></p><p>3：进入设置源的文件</p><p><code>vi /etc/apt/sources.list</code></p><p>4：</p><p>本文使用中科大的源，粘贴以下内容</p><pre class="line-numbers language-none"><code class="language-none">##中科大源deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后按<kbd>esc</kbd>键，输入 :wq 回车，保存并退出</p><p>也可以选用清华源</p><pre class="line-numbers language-none"><code class="language-none">##清华源deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换完源之后，一定要更新一下软件列表</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt-get updateapt-get upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下载vim</p><p><code>apt-get install vim</code></p><ul><li><p>如果出现什么问题，可以试试 <code>apt-get -f install</code>，或者重复多跑几次</p></li><li><p>如果出现编辑一半就报错退出，请在root账户底下<code>rm /etc/apt/.sources.list.swp</code>，然后重新使用vi指令进入即可。</p></li></ul><h2 id="二、Atlas-200DK-初步制卡"><a href="#二、Atlas-200DK-初步制卡" class="headerlink" title="二、Atlas 200DK 初步制卡"></a>二、Atlas 200DK 初步制卡</h2><p>准备依赖环境</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install python3 python3-pip gitpip3 install pyyamlsudo apt-get install qemu-user-static binfmt-support python3-yaml squashfs-tools gcc-aarch64-linux-gnu g++-aarch64-linux-gnu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把以下文件整合进home目录下的<code>mksd</code>文件夹，比如说我的路径是<code>/home/pi/mksd</code>。</p><p>在home/pi目录下执行<code>mkdir mksd</code>，然后<code>cd mksd</code>进入mksd文件夹</p><ul><li>ubuntu-18.04-server-arm64.iso(在历史版本里面找，本教程选用的是18.04.4)</li></ul><p>  <a href="https://releases.ubuntu.com/?_ga=2.35892448.1525631547.1620916708-1630382698.1620537185">下载Ubuntu server arm 镜像</a></p><ul><li>200dk固件与驱动（本教程的版本号选用5.1.RC1.alpha002）</li></ul><p>  <a href="https://www.hiascend.com/hardware/firmware-drivers?tag=community">atlas 200dk 驱动</a></p><ul><li>获取软件包（主要下载run文件）</li></ul><p>  <a href="https://support.huaweicloud.com/environment-deployment-Atlas200DK202/atlased_04_0020.html">atlas 200 dk软件包</a></p><ul><li>制卡脚本（务必参考下列版本号说明）</li></ul><p><a href="https://gitee.com/ascend/tools/tree/master/makesd">atlas-tools</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># usb数据线连Ubuntu的脚本wget https://raw.githubusercontent.com/Huawei-Ascend/tools/master/configure_usb_ethernet/for_20.1/configure_usb_ethernet.sh# 下载python包（可选）wget https://www.python.org/ftp/python/3.7.5/Python-3.7.5.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>! 注意</strong>：<strong>制卡脚本</strong>版本号需要一一对应。不同版本的工具连接有可能已经更新，请前往<a href="https://gitee.com/ascend/tools/tree/master/makesd">https://gitee.com/ascend/tools/tree/master/makesd</a><br>参考下表给的版本号进行查询</p><p><strong>! 点击上述链接，参考下表选择对应版本号的文件夹，然后下载里面的<code>make_sd_card.py</code>和<code>make_ubuntu_sd.sh</code>两个工具。然后把工具放进mksd里。</strong></p><p><strong>如果你的各项文件版本和本教程使用的一致，本教程需要打开的文件夹是<code>generic_script</code></strong></p><table><thead><tr><th align="center"><strong>驱动与固件版本</strong></th><th align="center"><strong>CANN版本</strong></th></tr></thead><tbody><tr><td align="center">1.0.13.alpha</td><td align="center">5.1.RC1.alpha005</td></tr><tr><td align="center"><strong>1.0.12.alpha</strong></td><td align="center">5.1.RC1.alpha003</td></tr><tr><td align="center"></td><td align="center"><strong>5.1.RC1.alpha002</strong></td></tr><tr><td align="center"></td><td align="center">5.1.RC1.alpha001</td></tr><tr><td align="center"></td><td align="center">5.0.5.alpha001</td></tr><tr><td align="center">1.0.11.alpha</td><td align="center">5.0.3.alpha005</td></tr><tr><td align="center"></td><td align="center">5.0.2.alpha005</td></tr><tr><td align="center">1.0.10.alpha</td><td align="center">5.0.2.alpha003</td></tr><tr><td align="center">1.0.9.alpha</td><td align="center">5.0.2.alpha002</td></tr><tr><td align="center"></td><td align="center">5.0.2.alpha001</td></tr><tr><td align="center"></td><td align="center">3.3.0.alpha006</td></tr><tr><td align="center"></td><td align="center">3.3.0.alpha005</td></tr><tr><td align="center"></td><td align="center">3.3.0.alpha001</td></tr><tr><td align="center"></td><td align="center">3.2.0.alpha001 备注：曾用版本号“20.2.alpha001”</td></tr><tr><td align="center">1.0.8.alpha</td><td align="center">3.1.0.alpha001 备注：曾用版本号“20.1.alpha001”</td></tr><tr><td align="center">1.0.7.alpha</td><td align="center">20.0.0</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/04/09/fhin7djFQ51YGyJ.png" alt="atlas-mksd-file.png"></p><p>（请确保制卡的时候，对应版本号的文件是正确的，并且至少需要有上免图片中的文件）</p><p>用读卡器接入你需要制卡的sd卡，把读卡机接入VMware。在 虚拟机-&gt;可移动设备中 吧读卡器接入虚拟机</p><p>用这个指令搜索你的读卡器<code>sudo fdisk -l</code></p><p>我在输出的最后一栏找到这个输出</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Device     Boot Start       End   Sectors  Size Id Type/dev/sdb1       32768 124735487 124702720 59.5G  7 HPFS/NTFS/exFAT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的sdb1就是我的读卡器的标号</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">supython3 make_sd_card.py local /dev/sdb1   #自己选好路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后系统就会自己开始制卡，请耐心等待。</p><p>如果最终制卡成功，会显示<code>Make SD Card successfully!</code>。如果有报错，请检查<strong>制卡工具的版本号</strong>是否有问题。</p><p>制好卡之后把卡放在atlas-200dk上，通电，让atlas自己进行初始化。</p><p>请参考指示灯，从网线接口一端数起各个灯分别为：MINI_LED2、MINI_LED1、3559_ACT、3559_VEDIO</p><img src="https://support.huaweicloud.com/productdesc-Atlas200DK1012/figure/zh-cn_image_0205566091.png" style="zoom: 33%;"><p>通电后，等待一会儿，等四个灯常亮才算正常开机。如果出现问题，请参考下表排查问题：</p><table><thead><tr><th>MINI_LED2</th><th>MINI_LED1</th><th>当前Atlas 200 DK 开发者套件（型号 3000）开发者板状态</th><th>注意事项</th></tr></thead><tbody><tr><td>灭</td><td>灭</td><td>Atlas 200 DK 开发者套件（型号 3000）开发者板启动</td><td>可以对Atlas 200 DK 开发者套件（型号 3000）开发者板断电或重启。</td></tr><tr><td>灭</td><td>亮</td><td>Ascend 310启动</td><td>可以对Atlas 200 DK 开发者套件（型号 3000）开发者板断电或重启，新版本升级时建议不要断电或重启。</td></tr><tr><td>闪烁</td><td>闪烁</td><td>固件升级</td><td>不能执行Atlas 200 DK 开发者套件（型号 3000）开发者板断电或重启操作，否则会导致固件升级不完整，单板损坏。当新版本升级时才会有固件升级流程，升级时间比较久，预计在15分钟内，请您耐心等待。</td></tr><tr><td>亮</td><td>亮</td><td>Atlas 200 DK 开发者套件（型号 3000）开发者板启动完成</td><td>可以对Atlas 200 DK 开发者套件（型号 3000）开发者板断电或重启。</td></tr></tbody></table><table><thead><tr><th>3559_ACT</th><th>3559_VEDIO</th><th>当前Atlas 200 DK 开发者套件（型号 3000）开发者板状态</th><th>注意事项</th></tr></thead><tbody><tr><td>灭</td><td>灭</td><td>Hi3559C系统未启动</td><td>无</td></tr><tr><td>灭</td><td>亮</td><td>Hi3559C系统启动中</td><td>无</td></tr><tr><td>亮</td><td>亮</td><td>Hi3559C系统启动完成</td><td>无</td></tr></tbody></table><h2 id="三、USB线连接atlas"><a href="#三、USB线连接atlas" class="headerlink" title="三、USB线连接atlas"></a>三、USB线连接atlas</h2><p>我们还是在这个Ubuntu系统内。</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install net-toolsifconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>找到如下内容，这是没配置好的网卡：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ens35u1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        ether 4e:57:14:39:8b:22  txqueuelen 1000  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 88  bytes 20428 (20.4 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了能够让atlas和其他linux系统通过type-c线进行通信，我们在mksd目录下启动命令行，执行<code>sudo bash configure_usb_ethernet.sh</code></p><p>然后执行<code>ssh HwHiAiUser@192.168.1.2</code>即可正常使用ssh连接通信。默认密码<code>Mind@123</code>。</p><p>如果你在虚拟机Ubuntu执行<code>sudo vim /etc/netplan/01-network-manager-all.yaml</code>查看文件配置</p><p>你就会发现，实际上执行完脚本，里面会多出来这一部分语句：</p><pre class="line-numbers language-none"><code class="language-none">network:  version: 2  renderer: NetworkManager  ethernets:     ens35u1:       dhcp4: no       addresses: [192.168.1.166/8]       gateway4: 255.255.255.0       nameservers:         addresses: [114.114.114.114]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而你再输入<code>ipconfig -a</code>可以看到如下信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.112.142  netmask 255.255.255.0  broadcast 192.168.112.255        inet6 fe80::ffdf:db40:6e3a:7437  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:7d:50:10  txqueuelen 1000  (Ethernet)        RX packets 217214  bytes 312285559 (312.2 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 43731  bytes 3099983 (3.0 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens35u1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.1.166  netmask 255.0.0.0  broadcast 192.255.255.255        inet6 fe80::4c57:14ff:fe39:8b22  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 4e:57:14:39:8b:22  txqueuelen 1000  (Ethernet)        RX packets 138  bytes 19845 (19.8 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 472  bytes 80561 (80.5 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>证明已经配置好了。</p><p>在虚拟机Ubuntu进入管理员root用户，输入以下配置：</p><p>！其中，参数ens35u1输入的是上面那份输出内容中<strong>第二个网卡</strong>的名字，ens33输入的是<strong>第一个网卡</strong>的名字。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo "1" &gt; /proc/sys/net/ipv4/ip_forward #允许报文转换iptables -t nat -A POSTROUTING -o &lt;ens33&gt; -s 192.168.1.0/24 -j MASQUERADEiptables -A FORWARD -i &lt;ens35u1&gt; -o &lt;ens33&gt; -m state --state RELATED,ESTABLISHED -j ACCEPTiptables -A FORWARD -i &lt;ens35u1&gt; -o &lt;ens33&gt; -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在ssh连接atlas的终端进入管理员账户，输入以下指令</p><p>其中[192.168.1.166]对应的是第二个网卡（atlas的）对应ip</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">route add default gw [192.168.1.166] dev usb0vim /etc/systemd/resolved.conf# 按i进入编辑模式，加入DNS=114.114.114.114 :wqping baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后你就会发现，atlas可以通过usb线联网。</p><h2 id="四、路由器连Atlas"><a href="#四、路由器连Atlas" class="headerlink" title="四、路由器连Atlas"></a>四、路由器连Atlas</h2><p>在开发板root账户下，输入<code>vim /etc/netplan/01-netcfg.yaml</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">network:  version: 2  renderer: networkd  ethernets:    eth0:      dhcp4: no #改为yes，保存退出      addresses: [192.168.0.2/24]      gateway4: 192.168.0.1      nameservers:            addresses: [114.114.114.114]    usb0:      dhcp4: no      addresses: [192.168.1.2/24]      #gateway4: 192.168.1.1      nameservers:            addresses: [114.114.114.114]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用网线连接开发板到一个可以上网的路由器当中，这个路由器需要开启DHCP。</p><p>输入<code>netplan apply</code></p><p>在Ubuntu虚拟机里面执行<code>ssh HwHiAiUser@192.168.0.2</code>，即可连上atlas</p><h2 id="五、网线共享网络"><a href="#五、网线共享网络" class="headerlink" title="五、网线共享网络"></a>五、网线共享网络</h2><p><strong>此过程建议提前将type-c先和网线一并连接好</strong></p><p>进入*<em>\控制面板\网络和 Internet\网络连接\*</em></p><img src="https://bbs-img.huaweicloud.com/blogs/img/1609137121924096771.png"><p><img src="https://bbs-img.huaweicloud.com/blogs/img/1609137189933024388.png"></p><p>其余的配置和<strong>四、路由器连Atlas</strong>步骤是一致的，都需要修改/etc/netplan/01-netcfg.yaml，都需要<code>netplan apply</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atlas 200DK </tag>
            
            <tag> Linux </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述(第一部分)</title>
      <link href="/2022/04/05/operating_system1/"/>
      <url>/2022/04/05/operating_system1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="操作系统——第一章-系统概述"><a href="#操作系统——第一章-系统概述" class="headerlink" title="操作系统——第一章: 系统概述"></a>操作系统——第一章: 系统概述</h1><h2 id="1-1-基本概念（定义）"><a href="#1-1-基本概念（定义）" class="headerlink" title="1.1 基本概念（定义）"></a>1.1 基本概念（定义）</h2><ul><li>操作系统（operating system，os）是系统资源的<strong>管理者</strong>，管理<strong>软件、硬件资源</strong>，给用户和其他软件方便的接口和环境，是一个<strong>系统软件</strong>。</li></ul><h2 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2  操作系统特征"></a>1.2  操作系统特征</h2><h3 id="1-并发（concurrence）"><a href="#1-并发（concurrence）" class="headerlink" title="1. 并发（concurrence）"></a>1. 并发（concurrence）</h3><p>微观上交替进行，宏观上同时执行。（操作系统和程序并发是一起诞生的）</p><ul><li>重点：<ul><li>单核CPU：同一时刻只能执行一个程序，各个程序只能<strong>并发</strong>执行。</li><li>多核CPU：同一时刻可以同时执行多个程序，多个程序可以<strong>并行</strong>执行。</li></ul></li></ul><h3 id="2-共享（sharing）"><a href="#2-共享（sharing）" class="headerlink" title="2. 共享（sharing）"></a>2. 共享（sharing）</h3><p>系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>互斥：系统中某些资源，虽然可以给多进程使用，但一个时间段内只允许一个进程访问该资源。</p><p>同时：系统中某些资源，允许一个时间段内由多个进程 “同时” 对他们进行访问。（微观上可能是交替的）</p><pre class="mermaid">graph LRA(两种资源共享方式) --&gt;B(互斥共享方式)    B --&gt;C(一个时间段内只允许一个进程访问该资源)    A --&gt;D(同时共享模式)    D --&gt;E(一个时间段内由多个进程 同时 对他们进行访问)    F[sharing]</pre><p><strong>注意</strong>：并发和共享是操作系统两个最基本特征，<strong>两者互为存在条件</strong>：</p><ol><li>资源共享是一程序并发为条件的。（若系统不允许程序并发执行，自然不存在资源共享问题）</li><li>若系统不能对资源共享进行有效管理，一定影响到程序的并发执行。</li></ol><h3 id="3-虚拟（virtual）"><a href="#3-虚拟（virtual）" class="headerlink" title="3. 虚拟（virtual）"></a>3. 虚拟（virtual）</h3><ul><li>可归纳为：<ul><li>时分复用技术：如处理器的分时共享（微观：处理机在微小时间段为各个进程服务，大时间分成小时间）</li><li>空分复用技术：如虚拟存储器</li></ul></li></ul><p>详见第三章</p><h3 id="4-异步（asynchronism）"><a href="#4-异步（asynchronism）" class="headerlink" title="4. 异步（asynchronism）"></a>4. 异步（asynchronism）</h3><p>并发的程序不是从头走到底的，是“走走停停”，如果进程正在占用资源，其他进程需要先被阻塞，等待资源释放。</p><h2 id="1-3-操作系统运行机制"><a href="#1-3-操作系统运行机制" class="headerlink" title="1.3 操作系统运行机制"></a>1.3 操作系统运行机制</h2><ul><li><p>实现操作系统，需要写<strong>内核程序</strong>，很多个内核程序组成**操作系统内核(kernel)**，简称内核，是整个操作系统最核心的部分。</p><ul><li>操作系统有个内核就足够了 (eg. Docker容器 -&gt; 仅需linux内核)</li><li>操作系统的功能未必都在内核中，如GUI图形化界面</li></ul></li><li><p>CPU设计的时候就划分了特权指令和非特权指令</p><ul><li>应用程序只能运行非特权指令（如加法减法）</li><li>内核程序可以运行特权指令（如内存清0指令，这条指令影响重大，只允许“管理者”——即操作系统内核来使用）。</li></ul></li><li><p>但是CPU运行的时候，只会把一条一条指令（二进制指令）送进去运行，怎么判断运行的程序是应用程序指令还是内核程序的指令？</p><p>此时我们把CPU划分成为两种状态，<strong>”内核态“</strong>，<strong>“用户态”</strong></p><ul><li><p>内核态：说明此时运行的是<code>内核程序</code>，<strong>可以执行特权指令</strong></p></li><li><p>用户态：说明此时运行的是<code>应用程序</code>，<strong>只能执行非特权指令</strong></p></li><li><p>CPU中的寄存器**程序状态字寄存器（PSW)**，其中有一个二进制位，1表示内核态，0表示用户态</p><p>当需要交换状态，修改PSW值即可</p></li></ul></li></ul><h2 id="1-4-中断和异常"><a href="#1-4-中断和异常" class="headerlink" title="1.4 中断和异常"></a>1.4 中断和异常</h2><ul><li>中断的作用：如果应用程序运行的时候，发生了中断，就会让cpu立即停止此时运行的应用程序，转而执行相应的内核程序。中断是让管理者（操作系统内核）夺回使用权的唯一途径，而中断，会使CPU由用户态转变为内核态</li></ul><pre class="mermaid">graph LRA(内核态 -&gt; 用户态) --&gt;B(用特权指令 修改PSW的值)C(用户态 -&gt; 内核态) --&gt;D(引发 中断 硬件自动完成 CPU状态转换过程 强行夺回CPU使用权)</pre><ul><li><p>中断的类型：</p><ul><li><p>内中断（也叫做 <strong>异常</strong>）：与当前执行指令有关，中断信号来源于CPU内部</p><p>有时候应用程序想请求操作系统内核的服务，此时会执行一条<strong>特殊的指令——陷入指令</strong>。该指令会引发一个内部中断信号。应用程序主动吧使用权归还给操作系统，希望操作系统提供某项服务。（先传入所需的参数，再调用陷入指令）</p><ul><li>而<strong>系统调用</strong>就是利用陷入指令来完成</li><li><strong>陷入指令并不是特权指令</strong>,陷入指令在用户态执行，执行后立刻引发一个<strong>内中断</strong>，使CPU进入内核态。</li></ul><p>异常分三个种类：</p><ul><li><p>陷阱、陷入（trap）：</p><p>由陷入指令引发，是应用程序故意引发的</p></li><li><p>故障（fault）：</p><p>由错误条件引起，可能被内核程序修复。内核程序修复后会把CPU使用权还给应用程序，让他继续执行下去。如：缺页故障</p></li><li><p>终止（abort）：</p><p>由致命错误引起，内核程序无法修复，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0，非法使用特权指令</p></li></ul></li><li><p>外中断（狭义上统称 <strong>中断</strong>）：与当前执行指令无关，中断信号来源于CPU外部</p><p>例子：时钟中断。由时钟部件（在cpu的外部）发来中断信号，实现程序并发的重要前提。</p><p>​            io设备提供中断信号。这些中断信号让操作系统可以很好的调度各个进程。</p><p>外部中断又分可屏蔽中断<strong>INTR</strong>和不可屏蔽中断<strong>NMI</strong></p></li></ul></li><li><p>中断机制的基本原理：</p><p>  不同类型的中断信号，需要用不同的中断处理程序来处理。查询<strong>中断向量表</strong>，以此来找到相应的中断处理程序在内存中存放的位置。</p></li></ul><p>显然，中断处理程序一定是在内核态的，需要运行在内核态（涉及计算机组成原理）</p><h2 id="1-5-系统调用"><a href="#1-5-系统调用" class="headerlink" title="1.5 系统调用"></a>1.5 系统调用</h2><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单好用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p><pre class="mermaid">graph TDA[应用程序] --&gt; system(系统调用)    A --&gt; |高级语言| C(c库函数)    C --&gt; system(系统调用)    system(系统调用) --&gt; operating[操作系统]    F[系统调用与库函数的区别]</pre><pre class="mermaid">graph LRA(系统调用 按功能分类) --&gt;B(设备管理 完成对设备的 请求/释放/启动 等功能)A --&gt;C(文件管理 完成对文件的 读/写/创建/删除 等功能)A --&gt;D(进程控制 完成进程的 创建/撤销/阻塞/唤醒 等功能)A --&gt;E(进程通信 完成进程之间的 消息传送/信号传递 等功能)A --&gt;F(内存管理 完成内存的 分配/回收 等功能)</pre><p>*拓展链接：<a href="https://www.cnblogs.com/wanghuaijun/p/6548633.html">linux提供了哪些系统调用</a></p><ul><li><p>凡是与共享资源有关的操作（如存储分配、IO操作、文件管理等），都必须通过系统调用的方式向<strong>操作系统内核</strong>提出服务请求。由内核代为完成，保证系统的稳定性与安全性。（也防止用户非法操作）</p></li><li><p>总结：</p><ul><li><p>陷入指令是在用户态执行，执行陷入指令后立即引发一个内中断，使CPU进入内核态。</p></li><li><p>发出系统调用的请求是在用户态，而对系统调用的相应处理是在内核态下进行。</p></li></ul></li><li><p>别名：</p><ul><li><p><strong>内核态=核心态=管态</strong>  </p></li><li><p><strong>用户态=目态</strong>  </p></li><li><p><strong>陷入指令=trap指令=访管指令</strong></p></li></ul></li><li><p>访管指令的基本功能是让程序拥有 “自愿进管” 的手段。从而引起访管中断。访管中断处理程序将按照系统调用的操作数和参数转到相应的例行子程序<sup class="refplus-num"><a href="#ref-r">[1]</a></sup>。完成服务功能后，退出中断，返回到用户程序断点继续执行。</p><ul id="refplus" style="display:none;"><li id="ref-r" data-num="1">[1]   例行程序 (routine)亦称例程.一种计算机程序.是与一项计算任务相对应的处理对象和处理规则的描述.可以是一个主程序的一部分或一个专用程序，也可包含若干个子程序.它一般在一个程序或多个程序中多次使用.例行程序和子程序常常存放在程序库中，通常存储在外存储器上.</li></ul><p></p></li></ul><h2 id="1-6-操作系统的体系结构"><a href="#1-6-操作系统的体系结构" class="headerlink" title="1.6 操作系统的体系结构"></a>1.6 操作系统的体系结构</h2><h3 id="1-分层法"><a href="#1-分层法" class="headerlink" title="1 分层法"></a>1 分层法</h3><p>将操作系统分为若干层，最底层（层0）为硬件，最高层（层N）为用户接口。每层只能调用紧邻它的低层的功能与服务（单向依赖）</p><ul><li>优点：<ul><li>便于系统的调试和验证，简化了系统设计与实现。</li><li>易扩充、易维护：增加、修改或替换其中一层，只要不改变接口，就不会影响其它层。</li></ul></li><li>缺点：<ul><li>各层合理定义较难，依赖关系稳定之后，往往不够灵活。</li><li>效率较差，通常调用的时候需要自上而下地穿越多层，增加开销。</li></ul></li></ul><h3 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2 模块化"></a>2 模块化</h3><p>是将操作系统按功能分为若干个功能模块。每个模块具有某种功能，并规定好接口，使各个模块之间可以通信。然后细分下各个子模块，这种设计方法叫做<strong>模块-接口法</strong>。</p><p>划分模块的时候，如果分的太小，虽然可以降低模块本身的复杂性，但会使得模块之间的联系过多，造成系统比较混乱。如果模块分的过大，会增加模块内部复杂性。</p><p>而且，划分模块的时候，要充分考虑模块的独立性，独立性越高，各个模块之间交互就变少，系统结构也就越清晰。衡量模块的独立性主要有两个标准：</p><ul><li><p>内聚性：模块内部各个部分联系的紧密程度。内聚性越高，模块独立性越好。</p></li><li><p>耦合度：模块间相互联系和相互影响的程度。耦合性越高，模块独立性越好。</p></li><li><p>优点：</p><ul><li>提高了操作系统设计的正确性、可理解性、可维护性</li><li>增强了操作系统的课适应性</li><li>加速了操作系统的开发过程</li></ul></li><li><p>缺点：</p><ul><li>模块间的接口规定很难满足对接口的实际需求</li><li>各个模块规格的设计没有一个统一的好答案，没找到可靠的决定顺序</li></ul></li></ul><h3 id="3-内核架构"><a href="#3-内核架构" class="headerlink" title="3 内核架构"></a>3 内核架构</h3><p><strong>而操作系统从内核上分大致分为两点：</strong></p><ul><li><p>大内核/单内核/宏内核 </p><ul><li>操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码量庞大，结构混乱，难以维护</li><li>典型的大内核操作系统：Linux、Unix</li></ul></li><li><p>微内核</p><ul><li><p>只把最基本的功能留在内核</p></li><li><p>微内核基本功能：</p><ul><li><p>进程/线程管理</p></li><li><p>低级存储器管理</p><p>在微内核中，只配置了最基本的低级存储器管理机制。如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制，这一部分需要依赖于硬件，因此放入微内核。</p><p>而实现虚拟存储器管理的策略，则包含应采取何种页面置换算法，采用何种内存分配与回收的策略，应将这部分放在微内核外的存储器管理服务器中。</p></li><li><p>中断和陷入处理</p></li></ul></li><li><p>优点：内核功能少，结构清晰，方便维护</p></li><li><p>缺点：需要频繁地在内核态和用户态切换，容易降低CPU性能</p></li><li><p>典型的微内核操作系统：Windows NT</p></li><li><p>定义微内核结构OS的四个方面：</p><ul><li><p>足够小的内核</p></li><li><p>基于客户/服务器模式</p></li><li><p>应用<strong>机制与策略分离</strong>原理</p><ul><li><p>机制是指实现某一功能的具体执行机构</p></li><li><p>策略是指在机制的基础上借助于某些参数和算法来实现该功能的优化，或者达到不同的功能目标。</p><p>传统OS中，将机制放在OS内核的较低层中，把策略放在内核的较高层。而微内核OS中，通常将机制放在微内核里，才能把内核做的很小</p></li></ul></li><li><p>采用面向对象技术</p><p>基于面向对象技术中的<strong>抽象</strong>与<strong>隐蔽</strong>原则，能控制系统的复杂性。进一步利用<strong>对象、封装、继承</strong>等概念还能确保系统运行的正确、可靠、易扩展性。也是因为如此，面向对象技术被广泛应用在操作系统的设计中。</p></li></ul></li></ul></li></ul><p>操作系统主要分两个板块：</p><ul><li><p>非内核功能：如GUI</p></li><li><p>内核功能：</p><ul><li><p>与硬件管理较紧密的模块</p><ul><li>时钟管理（利用时钟中断实现计时功能）</li><li>中断处理</li><li>原语（设备驱动、CPU切换等）<ul><li>是一种特殊程序</li><li>处于操作系统最底层，是最接近硬件的部分</li><li>这种程序具有原子性，运行必须一气呵成，不可被中断。</li><li>运行时间短，调用频繁</li></ul></li></ul></li><li><p>这些管理工作更多是对数据结构的操作，不会直接涉及硬件。</p><ul><li><p>把这部分功能也写进内核的内核叫大内核。反之，只有时钟，中断，原语的内核称之为微内核，其进程管理等等内容将运行在用户态，对性能有一定的影响。</p></li><li><p>进程管理、存储器管理、设备管理等功能</p></li></ul></li><li><p>这些内核功能，必须运行在内核态</p></li><li><p>微内核相比大内核，CPU运行状态的转换（psw）的次数会变多。CPU运行状态的转换是有成本的，消耗不少时间。频繁转换运行状态会降低系统性能</p></li></ul></li><li><p>Ubuntu、centos的开发团队主要是实现了非内核功能，而内核功能都是用了Linux内核。</p></li></ul><h2 id="1-7-操作系统的发展与分类"><a href="#1-7-操作系统的发展与分类" class="headerlink" title="1.7 操作系统的发展与分类"></a>1.7 操作系统的发展与分类</h2><h3 id="1-手工操作阶段"><a href="#1-手工操作阶段" class="headerlink" title="1 手工操作阶段"></a>1 手工操作阶段</h3><ul><li><p>纸带机打孔</p></li><li><p>缺点：用户独占全集，”人机速度矛盾“ 导致资源利用率低。</p></li><li><p>人机速度矛盾:人需要很长时间写纸带代码，且一次只能由一名程序员使用计算机，不允许多人使用；而计算机很快就可以运行完纸带代码</p></li></ul><h3 id="2-单道批处理系统"><a href="#2-单道批处理系统" class="headerlink" title="2 单道批处理系统"></a>2 单道批处理系统</h3><ul><li><p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序（操作系统的雏形）</strong>负责控制作业的输入输出，磁带读取熟读比纸带快很多</p></li><li><p>主要优点：缓解一定程度的人及速度矛盾，资源利用率有一定的提升</p></li><li><p>主要缺点：内存中仅能有一道程序运行，运行结束才能进行下一道（串行执行）。而<strong>CPU有大量的时间在空闲等待IO完成</strong>，资源利用率还是不高</p></li></ul><h3 id="3-多道批处理系统"><a href="#3-多道批处理系统" class="headerlink" title="3 多道批处理系统"></a>3 多道批处理系统</h3><ul><li><p>每次往内存中读取多道程序</p></li><li><p>操作系统正式诞生，支持多道程序并发运行</p></li><li><p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源，<strong>资源利用率大幅度提升</strong>，CPU和其他组员更能保持 “忙碌” 状态，系统吞吐量增大</p></li><li><p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业指挥就只能等待计算机处理完毕，中间不能控制自己的作业执行</p><p>如：无法调试程序，无法在程序运行中输入参数）</p></li></ul><h3 id="4-分时操作系统"><a href="#4-分时操作系统" class="headerlink" title="4 分时操作系统"></a>4 分时操作系统</h3><ul><li><p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可以通过终端与计算机进行交互</p></li><li><p>主要优点：用户请求可以被即时响应，<strong>解决人机交互的问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</p></li><li><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是公平的，循环地为每个用户/作业服务一个时间片，不区分任务优先级/紧急性。</p></li></ul><h3 id="5-实时操作系统"><a href="#5-实时操作系统" class="headerlink" title="5 实时操作系统"></a>5 实时操作系统</h3><ul><li><p>计算机接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p><ul><li><p>硬实时系统：必须在绝对严格的时间内完成任务</p><ul><li>如：自动驾驶系统</li></ul></li><li><p>软实时系统：能够接受偶尔的违反时间规定</p><ul><li>如：订票系统（实时更新票数）</li></ul></li></ul></li><li><p>主要优点：能够及时响应一些紧急任务，某些优先级高的任务不需要时间片排队。</p><h3 id="6-其他操作系统"><a href="#6-其他操作系统" class="headerlink" title="*6 其他操作系统"></a>*6 其他操作系统</h3></li><li><p>网络操作系统：实现网络中各种资源的共享（文件共享）和各个计算机之间的通信</p></li><li><p>分布式操作系统：特点是分布性、并行性，任何任务都可以分布在这些计算机上，并行协同地完成任务</p></li><li><p>个人操作系统：Windows、macOS等等</p></li></ul><h2 id="1-8-操作系统引导"><a href="#1-8-操作系统引导" class="headerlink" title="1.8 操作系统引导"></a>1.8 操作系统引导</h2><p>常见的操作系统引导流程如下</p><ul><li><p>激活CPU：</p><p>激活的CPU读取[ROM]<sup class="refplus-num"><a href="#ref-ROM">[1]</a></sup>中的boot程序，将指令寄存器置为BIOS<sup class="refplus-num"><a href="#ref-BIOS">[2]</a></sup>的第一条指令，即开始执行BIOS的指令。  </p><ul id="refplus" style="display:none;"><li id="ref-ROM" data-num="1">[1]  只读存储器，即使切断电源，信息也不会丢失，又称为固定存储器。整机工作过程中只能读出，不能像随机存储器能快速方便地改写存储内容。</li><li id="ref-BIOS" data-num="2">[2]   基本输入输出系统</li></ul><p></p></li><li><p>硬件自检：</p><p>启动BIOS程序之后，先进行硬件自检，检测是否故障。如有故障，用蜂鸣器发出不同含义的蜂鸣；如无故障，屏幕会开始显示cpu，内存，硬盘等等信息。</p></li><li><p>加载带有操作系统的硬盘：</p><p>BIOS在自检结束后，开始读取Boot Sequence(通过CMOS里存的启动顺序，或者通过与用户交互的方式)，把控制权交给排序第一位的设备。然后CPU将该存储设备的<strong>引导扇区</strong>的内容存至内存中。</p></li><li><p>加载主引导记录<strong>MBR</strong>：</p><p>硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现该盘不是可引导盘，就换下一个。若没有课引导盘，会导致死机。<strong>主引导记录MBR的作用就是告诉CPU去硬盘的哪个分区去寻找操作系统</strong>。</p></li><li><p>扫描硬盘分区表，并加载硬盘活动分区：</p><p>MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘的活动分区之后，开始加载硬盘的活动分区，将控制权交给活动分区。</p></li><li><p>加载分区引导记录PBR：</p><p>读取活动分区的第一个扇区，这个扇区称为**分区引导记录(PBR)**，其作用是寻找并激活分区根目录下，用于引导操作系统的程序（启动管理器）。</p></li><li><p>加载启动管理器：</p><p>分区引导记录搜索活动分区中的启动管理器，并加载它。</p></li><li><p>加载操作系统</p></li></ul><h2 id="1-9-虚拟机"><a href="#1-9-虚拟机" class="headerlink" title="1.9 虚拟机"></a>1.9 虚拟机</h2><p>虚拟机是一台逻辑计算机。通过隐藏特点计算平台的实际物理特性，为用户提供抽象、统一、模拟的计算环境。有两种虚拟方法。</p><h3 id="1-第一类虚拟管理程序"><a href="#1-第一类虚拟管理程序" class="headerlink" title="1 第一类虚拟管理程序"></a>1 第一类虚拟管理程序</h3><p>该虚拟机作为用户态执行，不允许使用特权指令。而虚拟机上的操作系统认为自己是在内核态（实际上不是），成为虚拟内核态。</p><p>在支持虚拟化的CPU上，执行特权指令时，，虚拟机管理程序会检测是虚拟机中的操作系统执行的还是虚拟机中的用户程序执行的。前者，会安排正常执行；否则，虚拟机管理程序会模拟真实硬件，面对用户，模拟执行特权指令时的行为。</p><h3 id="2-第二类虚拟管理程序"><a href="#2-第二类虚拟管理程序" class="headerlink" title="2 第二类虚拟管理程序"></a>2 第二类虚拟管理程序</h3><p>是一类与操作系统分配和调度资源的程序，很像一个普通的进程。。这一类仍然伪装成具有CPU和各种资源的完备计算机。VMware是首个在x86上的第二类虚拟管理程序。</p><p>刚开始启动的时候，这一类虚拟管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（宿主操作系统中的一个文件）。安装完成后即可运行。</p><p>有的说法，把第一类成为<strong>裸金属架构</strong>，第二类称为<strong>寄居架构</strong>。</p>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机知识 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈搭建Matery的一些流程</title>
      <link href="/2022/04/02/build-matery/"/>
      <url>/2022/04/02/build-matery/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="浅谈搭建matery的一些流程"><a href="#浅谈搭建matery的一些流程" class="headerlink" title="浅谈搭建matery的一些流程"></a>浅谈搭建matery的一些流程</h1><p>好不容易完善了该matery，发现自己并没有记录如何真正搭建的流程。</p><p>乘着刚搭建不久，来记录一下搭建<code>hexo-theme-matery</code>的一些流程</p><h2 id="0，介绍开发环境"><a href="#0，介绍开发环境" class="headerlink" title="0，介绍开发环境"></a>0，介绍开发环境</h2><ul><li><p>长年未更新的老Win10，以及更新过的vscode</p></li><li><p>这里建议参考以下几个链接一起看</p><ul><li><a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></li><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/">https://godweiyang.com/2018/04/13/hexo-blog/</a></li><li><a href="https://www.matemaster.cn/posts/52745.html">https://www.matemaster.cn/posts/52745.html</a></li></ul></li></ul><h2 id="1，搭建node-js等等初步工作环境"><a href="#1，搭建node-js等等初步工作环境" class="headerlink" title="1，搭建node.js等等初步工作环境"></a>1，搭建node.js等等初步工作环境</h2><p>先去官网下载<a href="https://nodejs.org/en/">node.js</a>，选择稳定版即可</p><p><img src="https://s2.loli.net/2022/04/03/dOYo2q4nPvJhrcl.png"></p><p>一路默认安装即可。装完会有两个组件，一个是node.js本身，一个是npm组件。</p><ul><li>自己新建一个文件夹，以后的网页代码全放在里面，我的是在d:/tuoyou-hao</li><li>用vscode打开这个文件夹（或者你用命令行 cd 进去 也可以），在vscode打开终端，输入以下指令</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">&gt; node -vv16.14.2&gt; npm -v8.5.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于npm下载速度较慢，我们可以选用淘宝的源下载。我们用npm下载cnpm：</p><p><code> &gt; npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>下载完成后，输入<code>cnpm -v</code>检查一下，输出下列内容即为正常</p><p><img src="https://s2.loli.net/2022/04/03/WDuRxhQiZV1w9IN.png"></p><p>然后我们开始安装hexo</p><pre class="line-numbers language-none"><code class="language-none">&gt; cnpm install -g hexo-cli &gt; hexo -vINFO  Validating confighexo: 6.1.0hexo-cli: 4.3.0os: win32 10.0.17134node: 16.14.2v8: 9.4.146.24-node.20uv: 1.43.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1n+quiccldr: 40.0icu: 70.1tz: 2021a3unicode: 14.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV# 显示如上内容，hexo就是正常的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个文件夹里面 <code>hexo init</code></p><p>hexo会为你生成很多文件，然后下载并配置一个默认主题（在theme文件夹）</p><p>配置完成后，命令行输入<code>hexo s</code>即可在本地localhost:4000看到hexo给你生成的网页</p><p>进入\source\_posts文件夹底下，就是存放你的博客的地方，使用markdown格式编写。</p><p>确认完毕以后，先去申请一个新的GitHub仓库</p><p>会让你填写自己GitHub的地址。此时需要申请自己的GitHub，并将仓库命名为&lt;你的GitHub名字&gt;.github.io</p><ul><li><p>比如我的GitHub名字叫tuoyou-hao，创建的新仓库就叫做“tuoyou-hao.github.io”。<strong>必须符合该命名格式</strong>！</p><p>创建完该仓库即可，无需进行其他操作</p></li><li><p>去配置GitHub的ssh key，建立ssh链接，具体步骤参考：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account</a></p></li></ul><p>配置完毕后，执行该指令，下载GitHub推送工具</p><p><code>cnpm install --save hexo-deployer-git</code></p><p>然后修改根目录下<code>_config.yml</code>里头的配置，找到deploy选修</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git  repository: git@github.com:xxx/xxx.github.io.git #填你的仓库名  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行hexo指令。命令行常用以下指令：</p><pre class="line-numbers language-none"><code class="language-none">hexo clean #清理本地生成文件hexo g  # 生成博客网页文件hexo s  # 本地预览博客hexo d  # 上传网页文件到github<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>hexo d完毕以后，进入你xxx.gihub.io网站，即可查看到你部署的网页（会有几分钟的延迟）</p><h2 id="2，配置matery"><a href="#2，配置matery" class="headerlink" title="2，配置matery"></a>2，配置matery</h2><ul><li><p>git clone该链接到themes文件夹：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p></li><li><p>并把根目录下<code>_config.yml</code>文件里的theme参数改成你clone的文件夹名字（我自己重命名叫matery，theme参数也要叫matery）</p></li><li><p>在matery主题文件夹里面也有一个<code>_config.yml</code>文件，还有一个<code>README_CN.md</code>文件，请你一定要认真仔细看那份文件，需要根据那份文件下载各种依赖。下载完成后，根据自己的需要去配置</p></li><li><p>配置完成就发布到自己的GitHub仓库吧</p></li></ul><h2 id="3，百度推送"><a href="#3，百度推送" class="headerlink" title="3，百度推送"></a>3，百度推送</h2><p>在百度推送上，建议参考：<a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1</a></p><p>登录该网站：<a href="https://ziyuan.baidu.com/">https://ziyuan.baidu.com/</a></p><p>登录成功后，在用户中心-&gt;站点管理-&gt;添加网站操作 </p><p>然后如何寻找token呢，token=秘钥：</p><p><img src="https://s2.loli.net/2022/04/03/j4m8YTUfV29Dei3.jpg"></p><p>其中matery内置了推送功能，我们只需要写好参数即可。</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git  repository: git@github.com:xxx/xxx.github.io.git  branch: master- type: baidu_url_submitter #记得在deploy下配置这一句baidu_url_submit:  count: 20 # 提交最新的一个链接  host: https://xxx.github.io # 在百度资源搜索平台中注册的域名  token: xxxxxxx # 请注意这是推送秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4，-配置评论控件"><a href="#4，-配置评论控件" class="headerlink" title="4， 配置评论控件"></a>4， 配置评论控件</h2><p>首先，在matery底下，将js底下的twikoo更新至最新版</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">js:twikoo: https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参考链接：<a href="https://twikoo.js.org/quick-start.html#%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2">https://twikoo.js.org/quick-start.html#%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2</a></p><ol><li><p>申请 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDB (opens new window)</a>账号</p></li><li><p>创建免费 MongoDB 数据库，区域推荐选择 <code>AWS / N. Virginia (us-east-1)</code></p></li><li><p>在 Clusters 页面点击 CONNECT，按步骤设置允许所有 IP 地址的连接（<a href="https://vercel.com/support/articles/how-to-allowlist-deployment-ip-address">为什么？ (opens new window)</a>），创建数据库用户，选择connect，一定要选择链接您的应用，那个数据库连接字符串才是我们需要的，请将连接字符串中的 <code>password</code> 修改为数据库密码</p><p><img src="https://s2.loli.net/2022/04/03/kLJfdnUmFrqZleC.png"></p><p><img src="https://s2.loli.net/2022/04/03/jmieJ9aAYcXLISO.png"></p></li><li><p>申请 <a href="https://vercel.com/signup">Vercel (opens new window)</a>账号</p></li><li><p>进入以下网址把 Twikoo 一键部署到 Vercel<br><a href="https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/dev/src/vercel-min">https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/dev/src/vercel-min</a></p></li><li><p>进入 Settings - Environment Variables，添加环境变量 <code>MONGODB_URI</code>，值为第 3 步的数据库连接字符串</p></li><li><p>进入 Overview，点击 Domains 下方的链接，如果环境配置正确，可以看到 “Twikoo 云函数运行正常” 的提示</p></li><li><p>Vercel Domains（包含 <code>https://</code> 前缀，例如 <code>https://xxx.vercel.app</code>）整个网址即为您的环境 id</p></li><li><p>把网址贴进主题的_config.yml里头对应的twikoo的envId，并启用twikoo功能。</p></li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">twikoo:  enable: true  visitor: true  envId: https://xxxx.app #搭建教程：https://twikoo.js.org/quick-start.html  # region: ap-guangzhou # 环境地域，默认为 ap-shanghai  path: 'window.location.pathname' # 自定义文章路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5，-配置图像上传"><a href="#5，-配置图像上传" class="headerlink" title="5， 配置图像上传"></a>5， 配置图像上传</h2><p>在写本篇博客的时候，当我推送上来的时候，意外的发现文章的图片迟迟读取不了，测试过以下指令，反而本地localhost也读取不了了<br><code>cnpm install https://github.com/CodeFalling/hexo-asset-image –save</code></p><p>由于我并非前端工作者，对这方面知识还是比较匮乏，你们可以参考这个教程的解决方法：<br><a href="https://www.cnblogs.com/hugochen1024/p/12570656.html">https://www.cnblogs.com/hugochen1024/p/12570656.html</a></p><p>我自己是注册<code>SM.MS</code>网站，链接：<a href="https://sm.ms/">https://sm.ms/</a><br>在该网站上传图片，网站会给你一个链接，导入该链接的图片即可。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Matrey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速入门Makefile(新手向)</title>
      <link href="/2022/03/31/Makefile-quick-get-start/"/>
      <url>/2022/03/31/Makefile-quick-get-start/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="快速入门Makefile-新手向"><a href="#快速入门Makefile-新手向" class="headerlink" title="快速入门Makefile(新手向)"></a>快速入门Makefile(新手向)</h1><h2 id="1、什么是Makefile"><a href="#1、什么是Makefile" class="headerlink" title="1、什么是Makefile"></a>1、什么是Makefile</h2><p>​        特别是在 Unix 下的软件编译，如果你正在开发一个大型的工程，你就不能不自己写Makefile了。</p><p>​        因为，Makefile关系到了整个代码工程的编译规则。一个工程中的源文件不计数，按类型、功能、模块分别放在若干个目录中，Makefile定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行其他更加复杂的操作。Makefile就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。</p><p>​        Makefile带来的好处就是——“自动化编译”，一旦你写好了Makefile，只需要一个<code>make </code>命令，整个工程就会完全自动编译，极大的提高了软件开发效率。</p><p>​        在我还刚接触Makefile的时候，我常常苦恼于找不到易读好懂的Makefile教程。本篇仅仅快速描述一个简单的Makefile应该是什么样子的，介绍一些基本的指令和语法，便于快速熟悉相关的指令。</p><h2 id="2、Makefile的一些基本规则"><a href="#2、Makefile的一些基本规则" class="headerlink" title="2、Makefile的一些基本规则"></a>2、Makefile的一些基本规则</h2><ul><li>本篇将以C语言的源码为基础，默认使用gcc编译器，需要有相关的前置知识</li></ul><p>make 命令执行时，需要一个Makefile文件，以告诉 make 命令需要怎么样的去编译和链接程序。 文件名只能用makefile、Makefile或者GNUmakefile 。最常用的是<code>makefile</code>、<code>Makefile</code>。</p><p>(如果你非要使用别的名字来命名Makefile，需要使用指令make后加参数<code>-f</code>/<code>--file</code>，如 <code>make -f your_makefile_name.md</code> )</p><ul><li>Makefile 的基本规则。<ul><li>如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。 </li><li>如果这个工程的某几个 C 文件被修改，那么我们只会编译被修改的 C 文件，并链接目标程序。 </li><li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件， 并链接目标程序。</li></ul></li></ul><h2 id="3、Makefile编写"><a href="#3、Makefile编写" class="headerlink" title="3、Makefile编写"></a>3、Makefile编写</h2><h3 id="3-1-来写一个最简单的Makefile"><a href="#3-1-来写一个最简单的Makefile" class="headerlink" title="3.1 来写一个最简单的Makefile"></a>3.1 来写一个最简单的Makefile</h3><p>我们来看这一段代码<code>a.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void main(){printf("Hello World\n");}//a.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常简单。加入我们要在Linux下编译运行，应该要怎么做</p><p>是的，在shell中使用gcc编译，生成一个可执行的二进制文件。直接执行这个文件就会显示“Hello Worrld”</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc a.c -o a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我要在Makefile里面编译这个a.c的代码，应该怎么写？</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a:a.cgcc a.c -o a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你查阅过和Makefile相关的资料，你可能会看到这段文字</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">target ... : prerequisites ...              command              ...              ...  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 你可以对照上面编译a.c的Makefile代码来看。</p><ul><li><p>target 也就是目标文件，可以是 Object File，也可以是执行文件（比如a.c生成的 a 可执行文件）。还可以是一个标签，标签本章暂不介绍，后续的博客再做介绍。 </p></li><li><p>prerequisites 就是，要生成那个 target 所需要的文件或是目标。 (a 可执行文件的生成需要依赖于 a.c)</p></li><li><p>command 也就是 make 需要执行的命令。（任意的 Shell 命令，比如调用gcc）</p></li></ul><p>而介绍完基本语句，我们就得回头来看一下make的工作方式。</p><h3 id="3-2-make的工作方式"><a href="#3-2-make的工作方式" class="headerlink" title="3.2 make的工作方式"></a>3.2 make的工作方式</h3><p>这段文字放在这里我认为才有便于理解</p><p>在默认的方式下，也就是我们只输入 make 命令。那么：</p><ol><li><p>make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。 </p></li><li><p>如果找到，它会找文件中的第一个目标文件（target）</p><p>比如下面这段Makefile，如果我们需要先把 *.c 文件先编译成 *.o 文件，而不是一步到位的编译成可执行文件，可以将上面<code>gcc a.c -o a</code>的步骤拆分成以下两句：</p></li></ol><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a:a.ogcc a.o -o aa.o:a.cgcc -c a.c -o a.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Makefile会先找到 “a” 这个目标，并把这个文件作为最终的目标文件。其余的各项依赖文件得写在后面，也就是我们的要介绍的：</p><ol start="3"><li><p>如果 a 这个文件不存在，或是 a 所依赖的后面的 [*.o] 文件的文件修改时间要比 a 这个文件新，那么，他就会执行后面所定义的命令，以此生成 a 这个文件。 </p></li><li><p>如果 a 所依赖的 *.o 文件也存在，那么 make 会在当前文件中找目标为 *.o 文件的依赖性，如果找到则再根据那一个规则生成 *.o 文件。（有点像一个堆栈的过程） </p></li><li><p>当然，你的 C 文件和 H 文件等等依赖文件是存在的，于是 make 会生成 *.o 文件，然后再用 *.o  文件完成make 的终极任务，也就是生成执行文件 a 了。</p></li></ol><p>并且和上一次的单个语句编译不同，我们同时还能获得 a.o 的文件</p><h3 id="3-3-多个文件编译"><a href="#3-3-多个文件编译" class="headerlink" title="3.3 多个文件编译"></a>3.3 多个文件编译</h3><p>你现在有一个大工程代码的main代码，是一个计算器，假设你是这样编写的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int mul(int, int);int main(){int a = 2, b = 1;printf("%d+%d=%d\n", a, b, add(a, b));printf("%d-%d=%d\n", a, b, sub(a, b));printf("%d*%d=%d\n", a, b, mul(a, b));return 0;}//main.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，加法，减法，乘法的函数写在其他的文件里面：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int add(int a, int b){return a + b;}//add.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sub(int a, int b){return a - b;}//sub.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int mul(int a, int b){return a*b}//mul.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时我们Makefile就可以这么写：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cal:main.o add.o sub.o mul.ogcc main.o add.o sub.o mul.o -o calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>其中 cal 文件需要<code>main.o add.o sub.o mul.o</code>，而我们各个 *.o 文件需要由各自的 *.c 文件编译而成。</p><p>记住上面这段makefile的样子。我们接下来会介绍很多种方法，简化上面这段makefile。</p><p>比如我们还可以写成这种形式，便于统一管理：</p></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.ocal:main.o add.o sub.o mul.ogcc main.o add.o sub.o mul.o -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果后续我需要加入一个除法功能，或者还要加入其他计算功能，就需要不断地重写Makefile，岂不是很麻烦，于是我们引入：</p><h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h3><p>在makefile中，变量声明的时候需要赋初值。使用的时候在变量名前面加上<code>$</code>号。用小括号或大括号括起来</p><p>(如果你要使用真实的“$”字符，那么你需要用 “$$” 来表示)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.oobjects=main.o add.o sub.o mul.ocal:$(objects)gcc main.o add.o sub.o mul.o -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面这个例子，我们把<code>main.o add.o sub.o mul.o</code>全部放在<code>objects</code>变量底下，使用的时候就可以用<code>$(objects)</code>把里面存的各种变量拿来编译了。变量是可以嵌套使用的，比如：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x = y y = z a := $($(x))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里 := 是赋值的意思，另一种用变量来定义变量的方法，和 = 的区别就是，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。这里的 a 里头存的就是 z 。</p><p>有了变量这个好东西，我们就可以使用：</p><h3 id="3-5-通配符"><a href="#3-5-通配符" class="headerlink" title="3.5 通配符"></a>3.5 通配符</h3><p>我们为了让Makefile自己找被我们更新过的代码，我们可以写成如下形式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.ocal:$(obj)gcc $(obj) -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>wildcard</code>，纸牌游戏中的 “百搭牌” ，计算机里称为 “通配符” 。会在当前目录自己搜索所有匹配 <code>*.c</code>的文件。（如果你需要使用到路径，碍于篇幅，需要自行了解notdir参数，用法为<code>file=$(notdir $(src))</code>）</li><li><code>patsubst</code>，模式字符串替换函数。<ul><li>里面的<code>%</code>是匹配符，假如说我们有<code>main.c add.c sub.c mul.c</code>这几个文件，使用<code>%</code>可以像使用for循环一样，挨个文件名遍历进去<code>*.c</code>里</li><li>后面<code>$(src)</code>表示：希望<code>patsubst</code>可以遍历哪些文件。我们就遍历当前目录<code>$(src)</code>底下的 *.c 文件</li></ul></li></ul><h3 id="3-6-更多便捷的书写方式"><a href="#3-6-更多便捷的书写方式" class="headerlink" title="3.6 更多便捷的书写方式"></a>3.6 更多便捷的书写方式</h3><p>如果我还想更改代码的名称，就需要自己重写makefile，未免有点太麻烦了。如果可以自己去寻找这些文件就好了。所以我们对上面的代码更新了一下，引入自动化变量，功能不变，写成如下形式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))ALL:calmain.o:main.cgcc -c $&lt; -o $@add.o:add.cgcc -c $&lt; -o $@sub.o:sub.cgcc -c $&lt; -o $@mul.o:mul.cgcc -c $&lt; -o $@cal:$(obj)gcc $^ -o $@clean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">符号</th><th align="center">解释</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">$@</td><td align="center">表示要生成的目标文件</td><td align="center">main.o:main.c中的main.o</td></tr><tr><td align="center">$^</td><td align="center">表示全部的依赖文件</td><td align="center">cal:$(obj)中的整个$(obj)</td></tr><tr><td align="center">$&lt;</td><td align="center">表示第一个依赖文件</td><td align="center">main.o:main.c中第一个依赖，也就是main.c</td></tr></tbody></table><p>还有很多其他的自动化变量，如$+,$*,$?等等，不在本篇博客详细解释，感兴趣的话可以自行查阅相关资料</p><p>上面这段代码还可以进一步简化。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))ALL:cal$(obj):%.o:%.cgcc -c $&lt; -o $@cal:$(obj)gcc $^ -o $@clean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的小伙伴会发现这两段代码多出来一个目标<code>clean</code>，如果你希望重新make一遍工程，那就需要先把生成的各项文件删除。用<code>make clean</code>指令就可以自己声明清理函数</p><p>如果你在想，我们又不打算生成clean目标文件，有没有别的书写方案？答案是有的，就需要用到标签中的 “伪目标“ <code>.PHONY</code>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">.PHONY : clean clean : -rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。)</p><p>当然，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。 </p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p><h3 id="3-7-引用文件"><a href="#3-7-引用文件" class="headerlink" title="3.7 引用文件"></a>3.7 引用文件</h3><p>如果我们整个工程的头文件全都在别的文件夹，比如说在<code>./inc</code>目录底下，我们有<code>add.h  mul.h  sub.h</code>三个头文件，应该怎么引用进来呢？</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))ALL:cal$(obj):%.o:%.cgcc -c $&lt; -o $@ -I inccal:$(obj)gcc $^ -o $@ -I incclean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，我们使用<code>-I/</code>或者<code>--include-dir</code>参数，就可以指定头文件所在位置了</p><p>事实上，不只是头文件，有其他的makefile文件，也可以用这个参数导入。make 就会在这个参数所指定的目录下去寻找。如果目录prefix/include（一般是：/usr/local/bin 或/usr/include）存在的话，make 也会去找。</p><p>如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make 不理那些无法读取的文件，而继续执行，你可以像上面的<code>clean</code>目标一样，在 include 前加一个减号“-”。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站的第一篇博客</title>
      <link href="/2022/03/21/first/"/>
      <url>/2022/03/21/first/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="建站以来第一篇博客"><a href="#建站以来第一篇博客" class="headerlink" title="建站以来第一篇博客"></a>建站以来第一篇博客</h1><p>大家好，这里是拓佑豪的博客网站，也是我的第一篇博客。<br>这篇博客没什么营养，留个纪念，也是为了代码调试的时候，可以看看效果<br>就，在这里聊聊几句，简单立个flag。后续会在这个博客网站发布一些技术类文章</p><h1 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h1><p>几年前就有设计自己博客的想法。奈何当时我接触到这方面资讯太少，我就在<code>华为云博客</code>上发了几篇关于OpenCV和Atlas 200DK的文章。但发现对文章归类和修改等等方面我用着不是很习惯（主要也是因为我没坐下来好好整理资料写博客），遂停更了好长一段时间。直到前段时间对静态网站有了大致的了解，就计划从现在开始积累自己的博客，把文章分门别类整理好，来维护好这个博客网站。</p><h1 id="When？什么时候开始写的？"><a href="#When？什么时候开始写的？" class="headerlink" title="When？什么时候开始写的？"></a>When？什么时候开始写的？</h1><p>也没多久，2021年才开始。不过写博客这个计划我会持续坚持下去</p><h1 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h1><p>本博客主要整理和计算机相关的博客，内容会慢慢偏向于人工智能方面，细分下来各种类别的文章可能多多少少都会有点。</p><h1 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h1><p>我会从简单的技术内容开始写起，包括重新整理以前写过的OpenCV类博客，把一些我认为讲的不够清晰的内容再梳理一遍。主要内容还是面向人工智能领域。</p><h1 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h1><p>写博客其实还蛮花时间的，尤其是在任务量多起来的时候。金钱的话就没有开销了，托管在GitHub上，你看我是不是连个域名都没买(Ｔ▽Ｔ)。等博客有了一定的时间、积累一定量比较拿得出手的文章，或许那个时候我会买个域名。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
