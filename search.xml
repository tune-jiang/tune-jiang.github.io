<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL 2：关系数据库</title>
      <link href="/2022/11/18/DataBase-2/"/>
      <url>/2022/11/18/DataBase-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据库2、关系数据库"><a href="#数据库2、关系数据库" class="headerlink" title="数据库2、关系数据库"></a>数据库2、关系数据库</h1><h2 id="一、关系数据结构"><a href="#一、关系数据结构" class="headerlink" title="一、关系数据结构"></a>一、关系数据结构</h2><h3 id="1、关系"><a href="#1、关系" class="headerlink" title="1、关系"></a>1、关系</h3><blockquote><p>关系、就是表。一张扁平的二维表</p></blockquote><ul><li>单一的数据结构——关系</li></ul><p>显示时间的实体以及实体之间的各种联系军用关系来标识</p><ul><li>逻辑结构——二维表</li></ul><p>从用户角度来说，关系模型中数据的逻辑结构是一张二维表</p><h4 id="1-域-domain"><a href="#1-域-domain" class="headerlink" title="1): 域 domain"></a>1): 域 domain</h4><p>域是一组具有相同数据类型的值的集合</p><p>自然数、证书、实数、男女性别、指定长度的字符串集合……都是域</p><h4 id="2-笛卡尔积-cartesian-product"><a href="#2-笛卡尔积-cartesian-product" class="headerlink" title="2): 笛卡尔积 cartesian product"></a>2): 笛卡尔积 cartesian product</h4><p>给一组域$D_1 D_2 … D_n$，每个D就是一个集合。</p><ul><li>所有域的所有取值的一个组合</li><li>不能重复</li></ul><p>这些域的笛卡尔积可以列成一张二维表，其数学语言如下：<br>$$<br>D_1\times D_2\times \cdots \times D_n\<br>={(d_1,d_2,\cdots,d_n)|d_i\in D_i,i=1,2,\cdots,n}<br>$$<br>其中，每一个元素$(d_1,d_2,\cdots,d_n)$叫做一个<strong>n元组（n tuple）</strong>，可以简称为元组</p><p>元素中每一个值di叫做一个<strong>分量（component）</strong></p><blockquote><p>一个域允许的不同取值个数称为这个域的<strong>基数（Cardinal number）</strong></p></blockquote><p>如果$D_i (i=1,2,\cdots,n)$为有限集，基数$m_i (i=1,2,\cdots,n)$，则$D_1\times D_2\times \cdots \times D_n$的基数M为:<br>$$<br>M = \sum^{n}_{i=1}m_i<br>$$</p><hr><p>是不是有点看晕了？举个例子<span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 就能看懂了：</p><p>这里列三个域</p><p>D1=导师={老刘，老陈}</p><p>D2=专业={人工智能，软件工程}</p><p>D3=学生={小刘，小陈}</p><p>D1xD2xD3的笛卡尔积就可以列为一张表：</p><table><thead><tr><th>导师</th><th>专业</th><th></th></tr></thead><tbody><tr><td>老刘</td><td>人工智能</td><td>小刘</td></tr><tr><td>老刘</td><td>人工智能</td><td>小陈</td></tr><tr><td>老刘</td><td>软件工程</td><td>小刘</td></tr><tr><td>老刘</td><td>软件工程</td><td>小陈</td></tr><tr><td>老陈</td><td>人工智能</td><td>小刘宝</td></tr><tr><td>老陈</td><td>人工智能</td><td>小陈</td></tr><tr><td>老陈</td><td>软件工程</td><td>小刘</td></tr><tr><td>老陈</td><td>软件工程</td><td>小陈</td></tr></tbody></table><p>该笛卡尔积的基数为2x2x2=8，也就是说，这个笛卡尔积一共有8个元组。</p><p>老陈、人工智能、软件工程、小刘……就是分量</p><h4 id="3-关系-relation"><a href="#3-关系-relation" class="headerlink" title="3): 关系 relation"></a>3): 关系 relation</h4><h5 id="1-关系"><a href="#1-关系" class="headerlink" title="(1) 关系"></a>(1) 关系</h5><p>$D_1\times D_2\times \cdots \times D_n$的子集叫做在域D1，D2，…，Dn上的关系，表示为  R(D1,D2,…,Dn)</p><p>这里R表示关系的名字，n是关系的目或<strong>度(degree)</strong></p><h5 id="2-元组"><a href="#2-元组" class="headerlink" title="(2) 元组"></a>(2) 元组</h5><p>关系中的每个元素是关系中的元组，通常用t表示</p><ul><li>n=1时，该关系为一元关系或单元关系（unary relation）</li><li>n=2时，该关系为二元关系(binary relation)</li></ul><p>关系是笛卡尔积的有限子集，所以关系也是一张二维表</p><ul><li>表的每一行对应一个元组</li><li>表的每一列对应一个域</li></ul><h5 id="3-属性"><a href="#3-属性" class="headerlink" title="(3) 属性"></a>(3) 属性</h5><p>因为域可以相同，为了区分，给列起个新名字：属性(attribute)</p><p><font style="color:red">n目关系必有n个属性</font></p><h5 id="4-码"><a href="#4-码" class="headerlink" title="(4) 码"></a>(4) 码</h5><ul><li><p>候选码 Candidate key</p><p>若关系中的某一属性组的值能唯一的表示一个元组(其子集不能)，就称该属性为那个组的候选码</p><ul><li>简单的情况：候选码只包含一个属性</li></ul></li><li><p>全码 ALL-key</p><p>最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码</p></li><li><p>主码</p><p>若一个关系有多个候选码，则选定其中一个为<strong>主码（Primary key）</strong></p><p>候选码的诸属性称为主属性（prime attribute）</p><p>不包含在任何候选码中的属性称为非主属性（Non-Prime attribute）</p><p>D1,D2,…,Dn的笛卡尔积的某个自己才有实际含义</p><p>eg: 笛卡尔积介绍部分的表格，并没有实际的意义，取出有实际意义的元组来构造关系</p><p>设关系SAP(supervisor,speciality,postgraduate)，</p><table><thead><tr><th>supervisor</th><th>speciality</th><th>postgraduate</th></tr></thead><tbody><tr><td>老刘</td><td>人工智能</td><td>小刘</td></tr><tr><td>老陈</td><td>软件工程</td><td>小陈</td></tr></tbody></table><p>由于这里的程序我们假定人名为不会重名，所以postgraduate属性的每一个值都唯一标识了一个元组，因此可以作为SAP关系的主码。</p></li></ul><h5 id="5-三类关系"><a href="#5-三类关系" class="headerlink" title="(5) 三类关系"></a>(5) 三类关系</h5><ul><li><p>基本关系（基本表或基表）</p><p>实际存在的表，是实际存储的逻辑表示</p></li><li><p>查询表</p><p>查询对应结果的表</p></li><li><p>视图表</p><p>有基本表或其他试图表导出的表，是虚表，不对应实际存储的数据</p></li></ul><hr><p>由于第二部分我们对笛卡尔积的定义，关系可以是一个无限集合。且由于组成笛卡尔积的域不满足交换律，当关系作为关系数据模型的数据结构时，需要给予如下的限定与扩充：</p><ol><li>无限关系在数据库系统中是没有意义的，现拟定的关系数据模型中的关系必须是有限集合</li><li>通过为关系的每一个列附加一个属性名的方法，取消关系属性的有序性。</li></ol><p>通过上述说明，基本关系有以下六条性质：</p><ul><li><p><font style="color:red">列是同质的(homogeneous)</font></p><p>每一列的分量是同一类型的数据，来自同个域</p></li><li><p><font style="color:red">不同的列可出自同一个域</font></p><ul><li>其中的每一列为一个属性</li><li>不同的属性要给与不同的属性名</li></ul></li><li><p><font style="color:red">任意两个元组的候选码不能取同个值</font></p><p>也就是元组不能重复</p></li><li><p><font style="color:red">列的顺序无所谓</font>，列的次序可以任意交换</p></li><li><p><font style="color:red">行的顺序无所谓</font>，行的次序可以任意交换</p></li><li><p><font style="color:red">分量必须取原子值</font></p><p>也就是每个分量都必须是不可分的数据项，是<strong>最基本的一条</strong></p></li></ul><h3 id="2、关系模式"><a href="#2、关系模式" class="headerlink" title="2、关系模式"></a>2、关系模式</h3><p>数据库中要区分<strong>型</strong>和<strong>值</strong>。关系数据库中，关系模式是<font style="background:yellow">型</font>,关系是<font style="background:yellow">值</font>。关系模式是对关系的描述。</p><p>关系是元组的集合，因此：</p><ul><li><p>关系模式是这个元组集合的结构，包括：</p><ul><li>哪些属性构成</li><li>属性来自于哪些域</li><li>属性与域之间的映像关系。</li></ul></li><li><p>需要完整的约束条件</p></li></ul><p>关系模式可以形式化地表示为：</p><p><font style="background:yellow">R( U , D , DOM , F )</font></p><ul><li><p>R        关系名</p></li><li><p>U        组成该关系的属性名集合</p></li><li><p>D        U中属性所来自的域</p></li><li><p>DOM 属性向域的映像集合</p></li><li><p>F        属性间数据的依赖关系的集合</p></li></ul><p>举个栗子<span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li><p>导师和研究生出自同一个域——人</p></li><li><p>取不同的属性名，并在模式中说明他们分别出自哪个域（定义属性向域的映像）</p><p>DOM(SUPERVISOR-PERSON)</p><p>= DOM(POSTGRADUATE-PERSON)</p><p>= PERSON</p></li></ul><hr><p>关系模式通常可以简单记为：</p><p>R(U) 或 R(A1,A2,…,An)</p><ul><li>R   还是指关系名</li><li>A1,A2,…,An   属性名</li><li>域名及属性向域的映像常常直接说嘛为属性的类型、长度</li></ul><h4 id="关系模式与关系"><a href="#关系模式与关系" class="headerlink" title="关系模式与关系"></a>关系模式与关系</h4><ul><li><p>关系模式：</p><ul><li>对关系的描述</li><li>静态的、稳定的</li></ul></li><li><p>关系</p><ul><li>关系模式在某一时刻的状态或内容</li><li>动态的、随时间不短变化的</li></ul></li><li><p>关系模式和关系往往统称为关系</p><p>通常通过上下文加以区别</p></li></ul><h3 id="3、关系数据库"><a href="#3、关系数据库" class="headerlink" title="3、关系数据库"></a>3、关系数据库</h3><p>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</p><ul><li><p>型</p><p>关系数据库模式，是对应关系数据库的描述</p></li><li><p>值</p><p>关系模式在某一时刻对应的关系的集合，通常称为关系数据库</p></li></ul><h3 id="4、关系模型的存储结构"><a href="#4、关系模型的存储结构" class="headerlink" title="4、关系模型的存储结构"></a>4、关系模型的存储结构</h3><p>关系数据库的物理组织</p><ul><li>有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成。</li><li>有的关系数据库管理系统从操作系统那申请若干个大的文件，自己划分文件空间、组织表、索引等存储结构，并进行存储管理</li></ul><h2 id="二、关系操作"><a href="#二、关系操作" class="headerlink" title="二、关系操作"></a>二、关系操作</h2><p>常见的关系操作</p><ul><li>查询操作：选择、投影、连接、除、并、交、差、笛卡尔积</li><li>数据更新：插入、删除、修改</li></ul><p>关系操作的特点</p><ul><li>集合操作方式：操作的对象和结果都是结合，以此一集合的方式</li></ul><p>关系代数语言</p><ul><li>用对关系的运算来表达查询要求</li><li>代表：ISBL</li></ul><p>关系演算语言：用谓词来表达查询要求</p><ul><li>元组关系演算语言<ul><li>谓词变元的基本对象是元组变量 </li><li>代表：APLHA、QUEL</li></ul></li><li>域关系演算语言<ul><li>谓词边关的基本对象是域变量</li><li>代表：QBE</li></ul></li></ul><p>具有关系代数和关系演算双重特点的语言</p><ul><li>代表：SQL (Structured Query Language)</li></ul><h2 id="三、关系的完整性"><a href="#三、关系的完整性" class="headerlink" title="三、关系的完整性"></a>三、关系的完整性</h2><blockquote><p>实体完整性、参照完整性、用户定义的完整性都都必须满足才行</p></blockquote><p>关系的三类完整性约束</p><ul><li>实体完整性和参照完整性<ul><li>关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持</li></ul></li><li>用户定义的完整性<ul><li>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</li></ul></li></ul><h3 id="1、实体完整性"><a href="#1、实体完整性" class="headerlink" title="1、实体完整性"></a>1、实体完整性</h3><blockquote><p>简单来说，就是主属性不能取空值</p></blockquote><p>规则：实体完整性规则 Entity Integrity</p><ul><li><p>若属性A是基本关系R的<strong>主属性</strong>，则属性A<strong>不能取空值</strong></p></li><li><p>空值就是“不知道”，“不存在”或“无意义”的值</p></li><li><p>说明：</p><ul><li><p>实体完整性规则是针对基本关系而言的。</p><p>一个基本表通常对应现实时间的一个实体集</p></li><li><p>现实世界中的实体是可以区分的，即他们具有某种唯一性标识。</p></li><li><p>关系模型中以主码作为唯一性标识</p></li><li><p>主码中的属性即主属性不能取空值</p><p>主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，与第2点相矛盾，，因此这个规则称为实体完整性</p></li></ul></li></ul><h3 id="2、参照完整性"><a href="#2、参照完整性" class="headerlink" title="2、参照完整性"></a>2、参照完整性</h3><h4 id="1-关系间的引用"><a href="#1-关系间的引用" class="headerlink" title="1): 关系间的引用"></a>1): 关系间的引用</h4><p>在关系模型中实体及实体之间的联系都是用关系来描述的，自然存在着关系与关系间的引用。</p><p>举个栗子<span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>：</p><p>对于学生来说，学号就是唯一标识符，是主码</p><p>在班级中，班长对于学生是“外码”，引用了本关系的“学号”，且班长必须是确实存在的学生的学号</p><h4 id="2-外码"><a href="#2-外码" class="headerlink" title="2): 外码"></a>2): 外码</h4><p>设F是基本关系R的一个或一组属性，但不是关系R的码，若F与基本关系S的主码Ks相对应，则称F是R的外码</p><p>说人话就是，数据库中如果一个关系中的一个属性是另一个关系中的主码，这个属性就是外码。</p><p>基本关系R称为参照关系</p><p>基本关系S称为被参照关系或目标关系</p><p>举个栗子<span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>：</p><p>学生关系的“专业号”与专业关系的主码“专业号”相对应</p><ul><li><p>“专业号”属性是学生的外码</p></li><li><p>专业关系是被参照关系，学生关系是参照关系</p><pre class="mermaid">  graph LRa(学生关系) --&gt;|专业号|b(专业关系)</pre></li></ul><h4 id="3-参照完整性规则"><a href="#3-参照完整性规则" class="headerlink" title="3): 参照完整性规则"></a>3): 参照完整性规则</h4><p>规则：若属性/属性组F是基本关系R的外码，它与基本关系S的主码Ks相对应（R和S可能是相同的），则对于R中每个元组在F上的值必须为以下其中之一：</p><ul><li>空值（F的每个属性值都为空值）</li><li>等于S中某个元组的主码值</li></ul><p>举个栗子<span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>：</p><p>学生关系中每个元组的 “专业号” 属性只取两类值</p><ul><li>空值，还没给这个学生分配专业</li><li>非空值，这个值得是专业关系中某个“专业号”值，毕竟不可能给学生分配一个根本不存在的专业</li></ul><h3 id="3、用户定义的完整性"><a href="#3、用户定义的完整性" class="headerlink" title="3、用户定义的完整性"></a>3、用户定义的完整性</h3><p>针对某一具体关系数据库的<font style="background:yellow">约束条件</font>，它反映某一具体应用所涉及的数据  必须满足的语义要求。</p><p>例如要求某个属性必须去取唯一值，某个非主属性也不能取空值，某个属性的取值范围在0-100之间……</p><p>关系模型应提供定义和检验这类完整性的机制，以便用统一的、系统的方法来处理它们，而不需用程序来承担这个功能。</p><h2 id="四、关系代数"><a href="#四、关系代数" class="headerlink" title="四、关系代数"></a>四、关系代数</h2><blockquote><p>关系代数是一种抽象的查询语言，它用<strong>对关系的</strong>运算来表达查询</p></blockquote><p>关系代数</p><ul><li>运算对象是关系</li><li>运算结果也为关系</li><li>关系代数的运算符有两类<ul><li>集合运算符</li><li>专门的关系运算符</li></ul></li></ul><p>传统的集合运算是从关系的 “水平” 方向（行的角度）进行的</p><p><font style="background:yellow">专门的关系运算不仅涉及行、还涉及列</font></p><table><thead><tr><th>类别</th><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>集合运算符</td><td>∩</td><td>交</td></tr><tr><td></td><td>-</td><td>差</td></tr><tr><td></td><td>∪</td><td>并</td></tr><tr><td></td><td>x</td><td>笛卡尔积</td></tr><tr><td>专门的关系运算符</td><td>σ</td><td>选择</td></tr><tr><td></td><td>π</td><td>投影</td></tr><tr><td></td><td>▷◁</td><td>连接</td></tr><tr><td></td><td>÷</td><td>除</td></tr></tbody></table><h3 id="1、传统的集合运算"><a href="#1、传统的集合运算" class="headerlink" title="1、传统的集合运算"></a>1、传统的集合运算</h3><p>先规定R和S两个表：</p><ul><li>具有相同的目n（即两个关系都有n个属性）</li><li>相应的属性取自同一个域</li></ul><table><thead><tr><th>R</th><th>A</th><th>B</th><th>C</th><th>S</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td></td><td>a1</td><td>b1</td><td>c1</td><td></td><td>a1</td><td>b2</td><td>c2</td></tr><tr><td></td><td>a1</td><td>b2</td><td>c2</td><td></td><td>a1</td><td>b3</td><td>c2</td></tr><tr><td></td><td>a2</td><td>b2</td><td>c1</td><td></td><td>a2</td><td>b2</td><td>c1</td></tr></tbody></table><h4 id="R∪S"><a href="#R∪S" class="headerlink" title="R∪S"></a>R∪S</h4><p>仍为n目关系<br>$$<br>R\cup S={t|t\in R\vee t\in S}<br>$$</p><table><thead><tr><th>R∪S</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td></td><td>a1</td><td>b1</td><td>c1</td></tr><tr><td></td><td>a1</td><td>b2</td><td>c2</td></tr><tr><td></td><td>a2</td><td>b2</td><td>c1</td></tr><tr><td></td><td>a1</td><td>b3</td><td>c2</td></tr></tbody></table><h4 id="R-S"><a href="#R-S" class="headerlink" title="R - S"></a>R - S</h4><table><thead><tr><th>R-S</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td></td><td>a1</td><td>b1</td><td>c1</td></tr></tbody></table><h4 id="R∩S"><a href="#R∩S" class="headerlink" title="R∩S"></a>R∩S</h4><table><thead><tr><th>R∩S</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td></td><td>a1</td><td>b2</td><td>c2</td></tr><tr><td></td><td>a2</td><td>b2</td><td>c1</td></tr></tbody></table><h4 id="RxS"><a href="#RxS" class="headerlink" title="RxS"></a>RxS</h4><p>严格来说应该是广义的笛卡尔积</p><p>R：n目关系，k1个元组</p><p>S：m目关系，k2个元组</p><p>RxS</p><ul><li><p>列 （n+m）列元组的集合</p><ul><li>元组的前n列是关系R的一个元组</li><li>后m列是关系S的一个元组</li></ul></li><li><p>行：k1 x k2个元组</p><ul><li>$$<br>R \times S = {\stackrel\frown{t_rt_s}|t_r\in R\wedge t_s\in S}<br>$$</li></ul></li></ul><p><img src="https://s2.loli.net/2022/11/11/bcxUEKQLTsgz4HM.png"></p><h3 id="2、专门的关系运算"><a href="#2、专门的关系运算" class="headerlink" title="2、专门的关系运算"></a>2、专门的关系运算</h3><p>引入的记号：</p><ul><li><p>(1) R，t∈R，t[Ai]</p><p>设关系模式为R(A1,A2,…,An)</p><p>关系设为R</p><p>t∈R表示t是R的一个元组</p><p>t[Ai]表示元组T中相应于属性Ai的一个分量</p></li><li><p>(2) A , t[A] , $\overline{A}$</p><p>若$A={A_{1k},A_{2k},…,A_{ik}}$，其中$A_{1k},A_{2k},…,A_{ik}$是A1，A2，…，An中的一部分，则A称为属性列或属性组。</p><p>$t[A]=(t[A_{i1}],t[A_{i2}],\cdots ,t[A_{ik}])$表示元组t在属性列上各个分量的集合</p><p>$\overline{A}$表示A1，A2，…，An中去掉$A_{1k},A_{2k},…,A_{ik}$后剩下的属性组。</p></li><li><p>(3) $\stackrel\frown{t_rt_s}$</p><p>R为n目关系，S为m目关系</p><p>tr∈R，ts∈S， $\stackrel\frown{t_rt_s}$称为元组的连接</p><p> $\stackrel\frown{t_rt_s}$是一个n+m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组</p></li><li><p>(4) 象集Zx</p><p>给定一个关系R(X,Z)，X和Z为属性组</p><p>当t[X]=x时，x在R中的象集（Images Set）为：<br>$$<br>Z_x={t[Z]|t\in,t[X]=x}<br>$$<br>它表示R中属性组X上值为x的各个元组在Z上分量的集合</p><p>举个栗子<span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>、有个表R：</p><table><thead><tr><th>x1</th><th>Z1</th></tr></thead><tbody><tr><td>x1</td><td>Z2</td></tr><tr><td>x1</td><td>Z3</td></tr><tr><td>x2</td><td>Z2</td></tr><tr><td>x2</td><td>Z3</td></tr><tr><td>x3</td><td>Z1</td></tr><tr><td>x3</td><td>Z3</td></tr></tbody></table><ul><li><p>x1在R中的象集</p><p>Zx1={Z1，Z2，Z3}</p></li><li><p>x2在R中的象集</p><p>Zx2={Z2，Z3}</p></li><li><p>x3在R中的象集</p><p>Zx3={Z1，Z3}</p></li></ul></li></ul><h4 id="1-选择"><a href="#1-选择" class="headerlink" title="1): 选择"></a>1): 选择</h4><p>选择又称为限制(Restriction)</p><p>选择运算符的含义</p><ul><li><p>在关系R中选择满足给定条件的各个元组<br>$$<br>\sigma_F(R)={t|t\in R\wedge F(t)=’True’}<br>$$</p></li><li><p>F: 选择条件，是一个逻辑表达式，取值为 True 或 False</p><ul><li>基本形式是：X1 θ Y1</li><li>θ 表示比较运算符，可以是＞、≥、＜、≤、= ……</li></ul></li><li><p>选择运算是从行的角度进行运算</p><p><img src="https://s2.loli.net/2022/11/11/FH6swUhOZ1a7lDC.png"></p></li></ul><h4 id="2-投影"><a href="#2-投影" class="headerlink" title="2): 投影"></a>2): 投影</h4><p>从R中选出若干属性列组成新的关系<br>$$<br>\Pi_A(R)={t[A]|t\in R}<br>$$<br>投影操作主要是从列的角度进行运算</p><p><img src="https://s2.loli.net/2022/11/11/N1ZpHXLnUmckVBw.png"></p><p>投影后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）</p><p>可以看到，象集的本质是一次选择运算和一次投影运算。 </p><h4 id="3-连接"><a href="#3-连接" class="headerlink" title="3): 连接"></a>3): 连接</h4><p>连接也称为θ连接</p><p>连接运算中</p><ul><li>从两个关系的笛卡尔积中选取属性见满足一定条件的元组<br>$$<br>R \underset{A\theta B}{\Join}S={\stackrel\frown{t_rt_s}|t_r\in R \wedge t_S \in S\wedge t_r[A]\theta t_s[B]}<br>$$</li></ul><h5 id="1-两种常用的连接运算"><a href="#1-两种常用的连接运算" class="headerlink" title="(1) 两种常用的连接运算"></a>(1) 两种常用的连接运算</h5><ul><li><p>等值连接（equijoin）</p><ul><li><p>θ为 “=” 的连接运算，就称为等值运算</p></li><li><p>从关系R和S的广义笛卡尔积中选取A、B属性相等的那些元组，表示方式为：<br>$$<br>R \underset{A\theta B}{\Join}S={\stackrel\frown{t_rt_s}|t_r\in R \wedge t_S \in S\wedge t_r[A]= t_s[B]}<br>$$</p></li></ul></li><li><p>自然连接（Natureal join）</p><ul><li><p>自然连接是一种特殊的等值连接</p><ul><li>两个关系中进行比较的分量必须是相同的属性组</li><li>在结果中重复的属性列要去掉</li></ul></li><li><p>自然连接的含义</p><ul><li>R和S具有相同的属性组B</li></ul></li></ul></li></ul><p>$$<br>R {\Join}S={\stackrel\frown{t_rt_s}[U-B]|t_r\in R \wedge t_S \in S\wedge t_r[B]= t_s[B]}<br>$$</p><hr><p>一般的连接操作是从行的角度进行运算</p><p><img src="https://s2.loli.net/2022/11/13/8ScUvBuh2LWEIGg.png"></p><p>自然连接还需要取消重复列，所以是同时从行和列的角度进行运算</p><p>举个栗子<span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><blockquote><p>话说我们举了好多个栗子，希望能够便于理解吧</p></blockquote><img src="https://s2.loli.net/2022/11/13/zwLHW2R5tm8eX6B.png" alt="DB-2-5.png" style="zoom:67%;"><p>首先有两个表格，用Markdown画这种有点太麻烦了，直接用图吧</p><p>一般的连接$R \underset{C&lt;E}{\Join}S$的结果如下，满足C&lt;E即可连接：</p><img src="https://s2.loli.net/2022/11/13/JCVXqAtWzFR68U5.png" style="zoom:67%;"><p>等值连接$R \underset{R.B=S.B}{\Join}S$的结果如下，可以看到R表B值和S表B值相同才能连接</p><img src="https://s2.loli.net/2022/11/13/23pl1us7PFemAGj.png" style="zoom:67%;"><p>自然连接，重复的属性列就没有了。 上面的等值连接进行比较的都是B属性， 但还可以进行R.B = S.E等值连接， 而自然连接只能是同名属性组 </p><img src="https://s2.loli.net/2022/11/13/CYtw9ueE6ZlmJ2R.png" alt="DB-2-8.png" style="zoom:67%;"><p>最后总结一下：</p><ol><li><p>等值连接必须要有等值的条件，当条件不同时连接的结果也不相同，两个关系可以没有相同的属性列</p></li><li><p>自然连接必须要有相同的属性列才能进行，即等值连接之后要去除相同的属性列</p></li></ol><h5 id="2-悬浮元组（Dangling-tuple）"><a href="#2-悬浮元组（Dangling-tuple）" class="headerlink" title="(2) 悬浮元组（Dangling tuple）"></a>(2) 悬浮元组（Dangling tuple）</h5><p>两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。</p><h5 id="3-外连接（Outer-Join）"><a href="#3-外连接（Outer-Join）" class="headerlink" title="(3) 外连接（Outer Join）"></a>(3) 外连接（Outer Join）</h5><ul><li>如果把悬浮元组也保存在结果关系中，而在其他属性上填 空值(NULL)，就叫做外连接</li><li>左外连接：只保留左边关系R中的悬浮元组</li><li>右外连接：只保留右边关系S中的悬浮元组</li></ul><p><img src="https://s2.loli.net/2022/11/13/1CQ3aSO2DNPvYwR.png"></p><p>上面R和S生成的外连接表为：</p><p><img src="https://s2.loli.net/2022/11/13/MosfAw5yzFcupbS.png"></p><p>左外连接与右外连接就分别如下（空缺元素就用NULL补上）：</p><p><img src="https://s2.loli.net/2022/11/13/b9dVwtilBgxDCXz.png"></p><h4 id="4-除运算"><a href="#4-除运算" class="headerlink" title="4): 除运算"></a>4): 除运算</h4><p>给定关系R（X,Y）和S（Y,Z），其中X Y Z为属性组</p><ol><li><p>R中的Y &amp; S中的Y可以由不同的属性名，但是要出自相同的域集</p></li><li><p>R与S的除法运算得到一个新的关系P（X）</p></li><li><p>P是R中满足下列条件的元组在X属性列上的投影</p></li><li><p>元组在X上分量x的象集Yx包含S在Y上投影的集合，记作：<br>$$<br>R \div S={t_r[X] | t_r\in R \wedge \Pi_Y(S)\subseteq Y_X}<br>$$<br>Yx: x在R中的象集，$x=t_r[X]$。</p></li></ol><hr><p>除运算是同时从行和列进行运算的</p><p><img src="https://s2.loli.net/2022/11/18/wX2eK1HQi6CSlpx.png"></p><p><img src="https://s2.loli.net/2022/11/18/IvoTlwWmU68psdS.png"></p><p>除法具体计算步骤：</p><ul><li>计算$\Pi_Y(S)$，将结果记为Sy</li><li>计算$\Pi_X(R)$，将结果记为Rx</li><li>遍历Rx中每一个元素a，计算a在关系R中的<strong>象集</strong>，得到Ya</li><li>判断Sy是否为Ya的子集<ul><li>是：将a加入到结果中</li><li>不是：遍历下一个元素</li></ul></li></ul><img src="https://s2.loli.net/2022/11/18/PXtwsMY7EHcRC91.png" style="zoom:80%;"><img src="https://s2.loli.net/2022/11/18/1ZIidLysngXJBV2.png" style="zoom:80%;">]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 1：概念</title>
      <link href="/2022/11/10/DataBase-1/"/>
      <url>/2022/11/10/DataBase-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据库-1、基础"><a href="#数据库-1、基础" class="headerlink" title="数据库 1、基础"></a>数据库 1、基础</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>数据的四个基本概念：</p><ul><li>数据（data）</li><li>数据库（database）</li><li>数据库管理系统（DBMS）</li><li>数据库系统（DBS）</li></ul><h3 id="1-1-数据库"><a href="#1-1-数据库" class="headerlink" title="1.1 数据库"></a>1.1 数据库</h3><p>长期储存、有组织、可共享的大量数据的集合</p><p>特征：</p><ul><li><p>数据按一定的数据模型组织、描述和储存</p></li><li><p>可为各种用户共享</p></li><li><p>冗余度较小</p></li><li><p>数据独立性搞</p></li><li><p>易拓展</p></li></ul><h3 id="1-2-数据库管理系统"><a href="#1-2-数据库管理系统" class="headerlink" title="1.2 数据库管理系统"></a>1.2 数据库管理系统</h3><p>位于用户与操作系统之间的数据管理软件</p><p>用于科学地组织和存储数据、高效获取与维护数据</p><ul><li><p>数据定义功能</p><ul><li>提供数据定义语言<strong>DDL</strong></li><li>定义数据库中的数据对象</li></ul></li><li><p>数据组织、存储和管理</p><ul><li>分类组织、存储和管理各种数据</li><li>确定组织数据的文件结构和存储方式</li><li>实现数据之间的联系</li><li>提供多种存取方法提高存取效率</li></ul></li><li><p>数据操纵功能</p><ul><li>提供数据操纵语言<strong>DML</strong></li><li>实现对数据可的基本操作，增删改查</li></ul></li><li><p>数据库的事物管理和运行管理</p><ul><li>数据库有数据库管理系统统一管理</li><li>保证数据安全性、能够支持多用户对数据的并发使用</li><li>发生故障后的系统恢复</li></ul></li><li><p>具备数据库的建立与维护功能</p><ul><li>包括初始化数据、数据转储、恢复、重组之、性能见识、分析等等</li></ul></li><li><p>其他功能</p><ul><li>数据库管理系统与网络中其他软件系统的通信</li><li>数据库管理系统之间的数据转换</li><li>异构数据库之间的互访和互操作</li></ul></li></ul><h3 id="1-3-数据库系统"><a href="#1-3-数据库系统" class="headerlink" title="1.3 数据库系统"></a>1.3 数据库系统</h3><p>Database System，由<strong>数据库</strong>，<strong>数据库管理系统</strong>、<strong>应用程序</strong>和<strong>数据库管理员</strong>组成的一整套存储、管理、处理和维护数据的系统。</p><p><img src="https://s2.loli.net/2022/11/10/W1fM2e8lmSicrOd.jpg" alt="DB-1-1.jpg"></p><h2 id="二、数据模型"><a href="#二、数据模型" class="headerlink" title="二、数据模型"></a>二、数据模型</h2><p>数据模型，就是对现实世界数据特征的抽象。</p><p>数据模型是数据库系统的核心和基础。</p><h3 id="2-1-两类数据模型"><a href="#2-1-两类数据模型" class="headerlink" title="2.1 两类数据模型"></a>2.1 两类数据模型</h3><h4 id="1、概念模型"><a href="#1、概念模型" class="headerlink" title="1、概念模型"></a>1、概念模型</h4><p>也叫做信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计</p><p>概念模型的一种表示方法：实体-联系方法</p><h4 id="2、逻辑模型和物理模型"><a href="#2、逻辑模型和物理模型" class="headerlink" title="2、逻辑模型和物理模型"></a>2、逻辑模型和物理模型</h4><ul><li><p>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型。对象关系数据模型、半结构化数据模型等等</p><p>按<strong>计算机系统</strong>的观点对数据建模，用于DBMS实现</p></li><li><p>屋里面模型是对是数据最底层的抽象，描述数据在学习通内部的表示方式和储存区方法，在<strong>磁盘或磁带</strong>上的存储方式和存取方法</p></li></ul><h3 id="2-2-概念模型"><a href="#2-2-概念模型" class="headerlink" title="2.2 概念模型"></a>2.2 概念模型</h3><h4 id="1、信息世界基本概念"><a href="#1、信息世界基本概念" class="headerlink" title="1、信息世界基本概念"></a>1、信息世界基本概念</h4><ul><li><p>1、实体（Entity）</p><p>客观存在并可相互区别的事物</p><p>可以是具体的人、事、物或抽象的概念</p></li><li><p>2、属性（Attribute）</p><p>实体所具有的某一特性</p><p>一个实体可以由若干个属性来刻画</p></li><li><p>3、码（Key）</p><p>唯一标识实体的属性集称为码</p></li><li><p>4、实体型（Entity Type）</p><p>分别实体及其属性的类型</p></li><li><p>5、实体集（Entity Set）</p><p>同一类型的实体的集合</p></li><li><p>6、联系（Relationship）</p><p>实体之间的联系通常是指不同实体集之间的联系</p></li></ul><h4 id="2、概念模型的一种表示方法：实体-联系方法"><a href="#2、概念模型的一种表示方法：实体-联系方法" class="headerlink" title="2、概念模型的一种表示方法：实体-联系方法"></a>2、概念模型的一种表示方法：实体-联系方法</h4><p>该方法使用<strong>E-R图</strong>来没描述现实世界的概念模型，<strong>E-R方法也称为E-R模型</strong>。</p><h3 id="2-3-数据模型的组成要素"><a href="#2-3-数据模型的组成要素" class="headerlink" title="2.3 数据模型的组成要素"></a>2.3 数据模型的组成要素</h3><p>数据模型通常由<strong>数据结构、数据操作、数据的完整性约束条件</strong>三部分组成</p><ul><li><p>数据结构</p><p>描述数据库的组成对象，以及对象之间的联系<br>描述的内容：</p><ul><li>与对象的类型、内容、行政有关</li><li>与数据之间联系有关</li></ul><p>数据结构是对系统静态特性的描述</p></li><li><p>数据操作</p><p>对数据库中的各种对象（型）的实例（值）允许执行的操作集合，包括操作和相关的操作规则</p><p>类型：增删改查</p></li><li><p>数据的完整性约束条件</p><ul><li><p>会给一组完整性规则的集合</p><p>完整性规则：给定的数据模型中的制约和依存规则</p><p>用来限制数据状态变化</p></li></ul></li></ul><h3 id="2-4-常用的数据模型"><a href="#2-4-常用的数据模型" class="headerlink" title="2.4 常用的数据模型"></a>2.4 常用的数据模型</h3><ul><li><p>层次模型</p><p>用树形结构表示实体之间的联系</p><p>特点：</p><ul><li>节点的双亲是惟一的</li><li>智能直接处理一对多的试题练习</li><li>每个记录类型可以定义一个排序字段、也称为码字段</li><li>任何记录值只有按其路径查看时，才能显出它的全部意义</li><li>没有一个子女记录值能够脱离双亲记录值而独立存在</li></ul><p>约束条件：</p><ul><li><p>无响应的双亲节点值就不能插入子女节点值</p></li><li><p>如果删除双亲节点值，则相应的子女节点值也同时被删除</p></li><li><p>更新操作时，应更新所有响应记录，以保证数据的一致性</p></li></ul><p>优点：</p><ul><li>层次模型的数据结构比较简单清晰</li><li>查询效率搞，性能优于关系模型，不低于网状模型</li><li>层次数据模型提供了良好的完整性支持</li></ul><p>缺点：</p><ul><li>节点之间的多对多联系表示不自然</li><li>对插入删除操作的限制多，应用程序的辨析比较复杂</li><li>查询子女节点必须通过双亲节点</li><li>层次命令趋于程序化</li></ul></li><li><p>网状模型</p><p>条件：</p><ul><li>允许一个以上的节点无双亲</li><li>一个节点可以由多于一个的双亲</li></ul><p>优点：</p><ul><li>更直接描述现实世界，如一个节点可以由多个双亲</li><li>有良好的性能，存取效率较高</li></ul><p>缺点：</p><ul><li>结构比较复杂，不利于最终用户掌握</li><li>DDL、DML语言复杂，用户不易使用</li><li>记录之间联系是通过存取路径实现的，用户必须了解系统结构的细节</li></ul></li><li><p>关系模型</p><p>关系模型中数据的逻辑结构是一张二维表</p><ul><li><p>域（domain）</p><p>是一组具有相同数据类型的值的集合。</p></li></ul></li></ul><table><thead><tr><th>关系术语</th><th>一般表格术语</th></tr></thead><tbody><tr><td>关系名</td><td>表名</td></tr><tr><td>关系模式</td><td>表头（表格的描述）</td></tr><tr><td>关系</td><td>（一张）二维表</td></tr><tr><td>元组</td><td>记录或行</td></tr><tr><td>属性</td><td>列</td></tr><tr><td>属性名</td><td>列明</td></tr><tr><td>属性值</td><td>列值</td></tr><tr><td>分量</td><td>一条记录中的一个列值</td></tr><tr><td>非规范关系</td><td>表中嵌套的表</td></tr></tbody></table><p>关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项，也就是表格中不可以有嵌套</p><h2 id="三、数据库系统的结构"><a href="#三、数据库系统的结构" class="headerlink" title="三、数据库系统的结构"></a>三、数据库系统的结构</h2><p>从数据库最终用户角度看，数据库系统的结构分为：</p><ul><li>单用户结构</li><li>主从式结构</li><li>分布式结构</li><li>客户-服务器</li><li>浏览器-应用服务器/数据库多层结构等等</li></ul><h3 id="3-1-模式概念"><a href="#3-1-模式概念" class="headerlink" title="3.1 模式概念"></a>3.1 模式概念</h3><p>数据模型中有型（Type）和值（Value）的概念。</p><p>模式schema</p><ul><li>数据库逻辑结构和特征的描述</li><li>是型的描述，不涉及具体值</li><li>反映的是数据的结构机器联系</li><li>模式是相对稳定的</li></ul><p>实例 (Instance)</p><ul><li>模式的一个具体值</li><li>反映数据库某一时刻的状态</li><li>同一个模式可以由很多实例</li><li>实例岁数据库中的数据的更新而变动</li></ul><p>模式只设计型的描述，不涉及具体的值。模式的一个具体值称为模式的一个实例。同一个模式可以由很多的实例。</p><p>模式是相对稳定的，而实例是相对变动的。</p><h3 id="3-2-三级模式结构"><a href="#3-2-三级模式结构" class="headerlink" title="3.2 三级模式结构"></a>3.2 三级模式结构</h3><p><img src="https://s2.loli.net/2022/11/10/HjlNMCUYG5LFcvr.jpg" alt="DB-1-2.jpg"></p><h4 id="1、模式（schema）"><a href="#1、模式（schema）" class="headerlink" title="1、模式（schema）"></a>1、模式（schema）</h4><p>模式也称为<strong>逻辑模式</strong></p><ul><li><p>是数据库中全体数据的逻辑结构和特征的描述</p><p>是数据库系统模式结构的中间层</p></li><li><p>是所有用户的公共数据视图</p></li><li><p>一个数据库就只有一个模式</p></li><li><p>模式是数据库系统模式结构中的中间层</p><ul><li>与数据的物理存储细节和硬件环境无关</li><li>与具体的应用程序、开发工具及程序语言无关</li></ul></li></ul><p>模式的定义：</p><ul><li>数据的逻辑结构（数据项名字、类型、取值范围……）</li><li>数据之间的联系</li><li>数据有关的安全性、完整性要求</li></ul><p>数据库管理系统提供模式数据定义语言（模式DDL）来严格地定义模式。</p><h4 id="2、外模式-External-Schema"><a href="#2、外模式-External-Schema" class="headerlink" title="2、外模式(External Schema)"></a>2、外模式(External Schema)</h4><p>外模式、也称为子模式或用户模式</p><ul><li>数据库用户（包括应用程序员和最终用户）使用的<strong>局部</strong>数据的逻辑结构和特征的描述</li><li>数据库用户的数据视图，是与某一应用有关的数据逻辑表示</li></ul><p>外模式的地位：结余模式与应用之间</p><ul><li>模式与外模式的关系：一对多<ul><li>外模式通常是模式的子集。</li><li>一个数据库可以有很多个外模式，反映不同的用户的应用需求、看待数据的方式、对数据保密的要求</li><li>模式中同样的数据，在不同外模式中宝妈咪级别可以是不一样的</li></ul></li><li>模式与应用的关系：一对多<ul><li>同一外模式也可以为某一用于的多个应用系统所使用的</li><li>但一个应用程序只能用一个外模式</li></ul></li><li>外模式的用途：<ul><li>是保证数据库安全性的一个有力措施。</li><li>每个用户只能看见和访问对应外模式中的数据，其余数据不可见。</li></ul></li></ul><p>同模式，可以用DDL定义开发</p><h4 id="3、内模式-Internal-Schema"><a href="#3、内模式-Internal-Schema" class="headerlink" title="3、内模式(Internal Schema)"></a>3、内模式(Internal Schema)</h4><p>也称为<strong>存储模式（Storage Schema）</strong></p><ul><li>是数据物理结构和存储方式的描述</li><li>是数据在数据库内部的表示方式<ul><li>记录的存储方式（按照顺序存储、B树结构存储、hash方法存储等等）</li><li>所以的组织方式</li><li>数据是否压缩存储</li><li>数据是否加密</li><li>数据存储记录结构的规定</li></ul></li><li>一个数据库只能有一个内模式</li></ul><h3 id="3-3-数据库的二级映像与数据独立性"><a href="#3-3-数据库的二级映像与数据独立性" class="headerlink" title="3.3 数据库的二级映像与数据独立性"></a>3.3 数据库的二级映像与数据独立性</h3><p>数据库系统的三级模式是数据的三个抽象级别</p><p>二级映像在数据库管理系统内部实现这三个抽象层次的联系和转换</p><ul><li>外模式/模式映像</li><li>内模式/内模式映像</li></ul><h4 id="1、外模式-x2F-模式映像"><a href="#1、外模式-x2F-模式映像" class="headerlink" title="1、外模式/模式映像"></a>1、外模式/模式映像</h4><blockquote><p>模式：描述的是数据的全局逻辑结构</p><p>外模式：描述的是数据的局部逻辑结构</p><p>而同一个模式下可以有很多个外模式</p></blockquote><p>每一个外模式，数据库系统都有一个外模式/模式映像，定义外模式与模式之间的对应关系</p><p>映像定义通常包含在各自外模式的描述当中</p><ul><li>保证了数据的<strong>逻辑</strong>独立性<ul><li>当模式改变时，由数据库管理员对各个外模式/模式映像做相应的改变，可以使外模式保持不变。</li><li>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li></ul></li></ul><h4 id="2、内模式-x2F-内模式映像"><a href="#2、内模式-x2F-内模式映像" class="headerlink" title="2、内模式/内模式映像"></a>2、内模式/内模式映像</h4><p>模式/内模式映像定义了数据全局逻辑结构与存储结构之间的对应关系</p><ul><li>eg：说明逻辑记录和字段在内部是如何表示的</li></ul><p><strong>数据库中模式/内模式映像是唯一的</strong></p><p>该映像定义通常包含在模式描述中</p><ul><li>保证了数据的<strong>物理</strong>独立性<ul><li>当数据库的存储结构改变了（如选用另一种存储结构），数据库管理员修改模式/内模式映像，使模式保持不变</li><li>应用程序不受影响，保证了数据与程序的物理独立性，简称数据的物理独立性</li></ul></li></ul><p>数据库模式：</p><ul><li>全局逻辑结构是数据库的中心与关键</li><li>独立于数据库的其他层次</li><li>设计数据库模式结构时应首先确定数据库的逻辑模式</li></ul><p>数据库的内模式：</p><ul><li>依赖于它的全局逻辑结构</li><li>独立于数据库的用户试图（外模式）</li><li>独立于具体的存储设备</li><li>将全局逻辑结构中所定义的数据结构机器联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率</li></ul><p>数据库的外模式：</p><ul><li>面向具体的应用程序</li><li>定义在逻辑模式之上</li><li>独立于存储模式和存储双设备</li><li>当应用需求变化较大，对应的外模式不能满足需求的时候，这个外模式需要改变</li><li>设计外模式需要考虑到应用的扩展性</li></ul><p>特定的应用程序</p><ul><li>在外模式描述的数据结构上编制的</li><li>依赖于特定的外模式</li><li>与数据库的模式和存储结构独立</li><li>不同的应用程序有事可以共用一个外模式</li></ul><p>数据库的二级映像</p><ul><li>保证了数据库外模式的稳定性</li><li>从底层保证了应用程序的稳定性，除非应用需求本身有变化，否则应用程序一般不需要修改</li></ul><p>数据与程序之间的独立性，使得数据的定义和描述可以冲应用程序中分离出去</p><p>数据的存取由数据库管理系统管理</p><ul><li>简化了应用程序的编制</li><li>减少应用程序的维护和修改</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware文件拖拽报错</title>
      <link href="/2022/08/27/error-Fix-VMware-drag-and-drop-failure/"/>
      <url>/2022/08/27/error-Fix-VMware-drag-and-drop-failure/</url>
      
        <content type="html"><![CDATA[<p>在使用vmware linux时，有时候会出现如下情况：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">open-vm-tools Error when getting information for file "//tmp/VMwareDnD/3jTONh/:xxx: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会导致无法复制文件，拖拽也不行的情况。</p><p>参考VMware的<a href="https://kb.vmware.com/s/article/74671">文章</a>，在文件拖拽和复制、粘贴，需要挂载一个特殊的文件系统：<code>vmblock-fuse</code>，先查看这个文件系统挂载服务的情况，如果有类似这样的输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl status run-vmblock\\x2dfuse.mount● run-vmblock\x2dfuse.mount - VMware vmblock fuse mount     Loaded: loaded (/lib/systemd/system/run-vmblock\x2dfuse.mount; disabled; vendor preset: enabled)     Active: inactive (dead)      Where: /run/vmblock-fuse       What: vmware-vmblock-fuse       Docs: https://github.com/vmware/open-vm-tools/blob/master/open-vm-tools/vmblock-fuse/design.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个服务处于<code>inactive</code>状态并且是<code>disabled</code>状态，就是该服务没有启动，并且重启后也不会自启。</p><p>解决方法：</p><ol><li>开机自启</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl enable run-vmblock\\x2dfuse.mount   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>启动服务</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl start run-vmblock\\x2dfuse.mount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在来查看服务状态，会有如下输出。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl status run-vmblock\\x2dfuse.mount● run-vmblock\x2dfuse.mount - /run/vmblock-fuse   Loaded: loaded (/proc/self/mountinfo)   Active: active (mounted) since Sat 2022-08-27 12:04:26 CST; 12min ago    Where: /run/vmblock-fuse     What: vmware-vmblock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是此时仍然无法复制粘贴，还需要再重启vmware-tools服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl restart vmware-tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，VMware可以随意复制粘贴文件了。</p>]]></content>
      
      
      <categories>
          
          <category> 报错排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA 2.3：核函数计时</title>
      <link href="/2022/08/18/cuda-2-3-Timing-kernel-function/"/>
      <url>/2022/08/18/cuda-2-3-Timing-kernel-function/</url>
      
        <content type="html"><![CDATA[<h1>CUDA 2.3 给核函数计时</h1><p>在内核的性能转换过程中，了解核函数的执行需要多长时间是很有帮助并且十分关键的。</p><p>衡量核函数性能的方法有很多。最简单的方法是在主机端使用一个CPU或GPU计时器来计算内核的执行时间。</p><p>本节我们从计时器入手，了解如何在CPU或GPU获取代码的运行时长，并了解性能调优的基本概念</p><h2 id="一、用CPU计时器计时">一、用CPU计时器计时</h2><p>C语言中，平时大家最常用的是<code>time.h</code>的头文件来计时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">clock_t start,end;start = clock();//要被计算的函数end = clock();duration = (double)(end - start) / CLOCKS_PER_SEC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，clock函数测出来的时间为进程运行时间，单位为滴答数(ticks)</p><p>我们还可以使用<code>gettimeofday</code>系统调用来创建一个CPU计时器获取系统的时钟时间，它将返回从<strong>1970年1月1日零点</strong>开始到现在的秒数。</p><p>因为<code>gettimeofday</code>是linux下的一个库函数，程序中需要添加<code>sys/time.h</code>头文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys/time.h&gt;double cpuSecond(){  struct timeval tp;  gettimeofday(&amp;tp,NULL);  return((double)tp.tv_sec+(double)tp.tv_usec*1e-6);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后这个函数就可以用来计时了。我们可以用来给核函数计时，看看他运行了多长时间：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">double iStart,iElaps;iStart=cpuSecond();sumArraysGPU&lt;&lt;&lt;grid,block&gt;&gt;&gt;(a_d,b_d,res_d,nElem);cudaDeviceSynchronize();iElaps=cpuSecond()-iStart;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>变量iElaps表示程序运行的时间，就像用手表记录的核函数的执行时间（用秒计算）。</p></blockquote><p>由于核函数调用与主机端程序是异步的，就需要用<code>cudaDeviceSynchronize</code>函数来等待所有的GPU线程运行结束。</p><ul><li><p>如果不加这个同步函数，那么计时的时间是从调用核函数，到核函数返回给主机线程的时间段，而不是核函数的执行时间</p></li><li><p>用<code>cudaDeviceSynchronize</code>函数后，计时是从调用核函数开始，到核函数执行完并返回给主机的时间段</p></li></ul><img src="https://s2.loli.net/2022/08/18/HBVYMKIEAQolNsu.png" alt="cuda-2-6.png" style="zoom:67%;"><p>我们可以从上图大概分析下核函数启动到结束的过程：</p><ol><li>主机线程启动核函数</li><li>核函数启动成功</li><li>控制返回主机线程</li><li>核函数执行完毕</li><li>主机同步函数侦测到核函数执行完成</li></ol><p>我们要测试的是2~4的时间，但是用CPU计时方法，只能测试1~5的时间，所以测试得到的时间偏长。</p><h2 id="二、代码实现-2">二、代码实现</h2><p>现在，通过设置数据集大小来对一个有16M个元素的大向量进行测试，直接用左移比特位来设置：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int nElem = 1 &lt;&lt; 24;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们编写核函数的时候，由于GPU的可扩展性，使得我们需要借助块和线程的索引来计算一个按行优先的数组索引<code> i</code>，并对核函数进行修改。</p><p>需要添加限定条件**（i＜N）**来检验索引值是否越界</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ void sumArraysOnGPU(float *A, float *B, float *C, const int N){    int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; N) C[i] = A[i] + B[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了解决创建的线程总数大于向量元素总数的情况，我们还需要限制内核不能非法访问全局内存，也就是<code>向量元素总数＜线程总数</code></p><p>我们除了上面这个核函数我们需要调整以外，只需要写主函数了，这里只介绍主函数编写。</p><p>同时我们把这个排错用的函数定义放在头文件里了，加载头文件后直接<code>CHECK()</code>调用即可：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define CHECK(call)                                                            \{                                                                              \    const cudaError_t error = call;                                            \    if (error != cudaSuccess)                                                  \    {                                                                          \        fprintf(stderr, "Error: %s:%d, ", __FILE__, __LINE__);                 \        fprintf(stderr, "code: %d, reason: %s\n", error,                       \                cudaGetErrorString(error));                                    \        exit(1);                                                               \    }                                                                          \}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化数据</p><ul><li>设置GPU设备</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int dev = 0;cudaDeviceProp deviceProp;CHECK(cudaGetDeviceProperties(&amp;deviceProp, dev));printf("Using Device %d: %s\n", dev, deviceProp.name);CHECK(cudaSetDevice(dev));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置向量的大小</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int nElem = 1 &lt;&lt; 24;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-1-CPU端的执行方式">2.1 CPU端的执行方式</h3><ul><li>申请内存空间</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">float *h_A, *h_B, *hostRef, *gpuRef;h_A     = (float *)malloc(nBytes);h_B     = (float *)malloc(nBytes);hostRef = (float *)malloc(nBytes);gpuRef  = (float *)malloc(nBytes);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>初始化CPU端的数据</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">double iStart, iElaps;iStart = seconds();initialData(h_A, nElem);initialData(h_B, nElem);iElaps = seconds() - iStart;printf("initialData Time elapsed %f sec\n", iElaps);memset(hostRef, 0, nBytes);memset(gpuRef,  0, nBytes);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>计算CPU端运行相加花费的时间。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">iStart = seconds();sumArraysOnHost(h_A, h_B, hostRef, nElem);iElaps = seconds() - iStart;printf("sumArraysOnHost Time elapsed %f sec\n", iElaps);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-GPU端的执行方式">2.2 GPU端的执行方式</h3><ul><li>申请内存</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">float *d_A, *d_B, *d_C;CHECK(cudaMalloc((float**)&amp;d_A, nBytes));CHECK(cudaMalloc((float**)&amp;d_B, nBytes));CHECK(cudaMalloc((float**)&amp;d_C, nBytes));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>赋值传数据</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">CHECK(cudaMemcpy(d_A, h_A, nBytes, cudaMemcpyHostToDevice));CHECK(cudaMemcpy(d_B, h_B, nBytes, cudaMemcpyHostToDevice));CHECK(cudaMemcpy(d_C, gpuRef, nBytes, cudaMemcpyHostToDevice));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>定义网络和块</p><p>这里的配置设置为一个包含32768个块的一维网格，每个块包含512个线程。</p><p>可以自行调整这里的iLen值，试试看1024个线程和512个线程之间性能会提升多少（1.19倍）</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int iLen = 512;dim3 block (iLen);dim3 grid  ((nElem + block.x - 1) / block.x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>计算GPU运行函数所花费的时间：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">iStart = seconds();sumArraysOnGPU&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_A, d_B, d_C, nElem);CHECK(cudaDeviceSynchronize());iElaps = seconds() - iStart;printf("sumArraysOnGPU&lt;&lt;&lt;%d, %d&gt;&gt;&gt; Time elapsed %f sec\n",        grid.x,block.x, iElaps);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>收尾工作，拷贝计算结果并释放内存空间</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">CHECK(cudaGetLastError()) ;CHECK(cudaMemcpy(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost));checkResult(hostRef, gpuRef, nElem);CHECK(cudaFree(d_A));CHECK(cudaFree(d_B));CHECK(cudaFree(d_C));free(h_A);free(h_B);free(hostRef);free(gpuRef);return(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里在调整执行配置时需要了解的一个关键点是对网格和块维度的限制。线程层次结构中每个层级的最大尺寸取决于设备。</p><p>总代码放在文末</p><h2 id="三、用nvprof工具计时">三、用nvprof工具计时</h2><p>自CUDA 5.0以来，NVIDIA提供了一个名为nvprof的命令行分析工具，可以帮助从应用程序的CPU和GPU活动情况中获取时间线信息，其包括内核执行、内存传输以及CUDA API的调用。其用法如下。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nvprof [nvporp_args] &lt;application&gt; [application_args]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以用这个命令测试内核：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nvprof ./test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>不过吧，计算能力为8.0及以上的设备不支持nvprof。使用<code>sudo apt install nvidia-nsight</code>下载nsight工具。如果下载出现NO_PUBKEY错误，用下列语句解决：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo gpg --keyserver keyserver.ubuntu.com --recv-keys 467B942D3A79BD29<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>使用工具nvprof的计算结果更为精确，因为CPU计时器测量的时间中包含了来自nvprof附加的时间。 工具不仅给出了kernel执行的时间，比例，还有其他cuda函数的执行时间。由nvprof得到的计数器可以帮助我们获取应用程序的指令和内存吞吐量。</p><p>主机和设备之间的数据传输需要的时间比内核执行的时间要多。对于HPC工作负载，理解程序中通信比的计算是非常重要的。</p><p>如果应用程序用于计算的时间大于数据传输所用的时间，那么或许可以压缩这些操作，并完全隐藏与传输数据有关的延迟。如果应用程序用于计算的时间少于数据传输所用的时间，那么需要尽量减少主机和设备之间的传输。</p><h2 id="四、理论界限最大化">四、理论界限最大化</h2><p>在进行程序优化时，如何将应用程序和理论界限进行比较是很重要的。</p><p>如果将应用程序的测量值与理论峰值进行比较，可以判定你的应用程序的性能是受限于算法还是受限于内存带宽的。</p><p>我们得到了实际操作值之后，就需要知道能优化的极限值是多少，也就是机器的理论计算极限。这个极限我们永远也达不到，但是我们必须明确的是，比如理论极限是2秒，我们已经从10秒优化到2.01秒了，基本就没有必要再继续优化速度了，而应该考虑买更多的机器或者更新的设备。</p><p>我们以Tesla K10为例，可以得到理论上的比率：</p><ul><li><p>Tesla K10单精度峰值浮点运算次数</p><p>745 MHz核心频率*2 GPU/芯片*（8个多处理器*192个浮点单元*32核心/多处理器）*2</p><p>OPS/周期＝4.58 TFLOPS（FLOPS表示每秒浮点运算次数）</p></li><li><p>Tesla K10内存带宽峰值2 GPU/芯片*256位*2500 MHz内存时钟*2 DDR/8位/字节＝320 GB/s</p></li><li><p>指令比∶字节</p><p>4.58 TFLOPS/320 GB/s，也就是13.6个指令：1个字节</p></li></ul><p>对于Tesla K10而言，如果你的应用程序每访问一个字节所产生的指令数多于13.6，那么应用程序受算法性能限制。大多数HPC工作负载受内存带宽的限制。</p><hr><p>完整代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include "../common.h" //CHECK所在头文件#include &lt;cuda_runtime.h&gt;#include &lt;stdio.h&gt;void checkResult(float *hostRef, float *gpuRef, const int N){    double epsilon = 1.0E-8;    bool match = 1;    for (int i = 0; i &lt; N; i++)    {        //检测到误差过大，就指出错误对应的维度        //并把flag置为false        if (abs(hostRef[i] - gpuRef[i]) &gt; epsilon)        {            match = 0;            printf("Arrays do not match!\n");            printf("host %5.2f gpu %5.2f at current %d\n", hostRef[i],                   gpuRef[i], i);            break;        }    }    if (match) printf("Arrays match.\n\n");    return;}void initialData(float *ip, int size){    // 为随机数生成不同的种子    time_t t;    srand((unsigned) time(&amp;t));    for (int i = 0; i &lt; size; i++)    {        ip[i] = (float)(rand() &amp; 0xFF) / 10.0f;    }    return;}void sumArraysOnHost(float *A, float *B, float *C, const int N){    //主机用for循环计算结果    for (int idx = 0; idx &lt; N; idx++)        C[idx] = A[idx] + B[idx];}__global__ void sumArraysOnGPU(float *A, float *B, float *C, const int N){    //cuda核函数计算向量相加    int i = blockIdx.x * blockDim.x + threadIdx.x;    if (i &lt; N) C[i] = A[i] + B[i];}int main(int argc, char **argv){    printf("%s Starting...\n", argv[0]);    int dev = 0;    cudaDeviceProp deviceProp;    CHECK(cudaGetDeviceProperties(&amp;deviceProp, dev));    printf("Using Device %d: %s\n", dev, deviceProp.name);    CHECK(cudaSetDevice(dev));    int nElem = 1 &lt;&lt; 24;    printf("Vector size %d\n", nElem);    size_t nBytes = nElem * sizeof(float);    float *h_A, *h_B, *hostRef, *gpuRef;    h_A     = (float *)malloc(nBytes);    h_B     = (float *)malloc(nBytes);    hostRef = (float *)malloc(nBytes);    gpuRef  = (float *)malloc(nBytes);    double iStart, iElaps;    iStart = seconds();    initialData(h_A, nElem);    initialData(h_B, nElem);    iElaps = seconds() - iStart;    printf("initialData Time elapsed %f sec\n", iElaps);        memset(hostRef, 0, nBytes);    memset(gpuRef,  0, nBytes);    iStart = seconds();    sumArraysOnHost(h_A, h_B, hostRef, nElem);    iElaps = seconds() - iStart;    printf("sumArraysOnHost Time elapsed %f sec\n", iElaps);    float *d_A, *d_B, *d_C;    CHECK(cudaMalloc((float**)&amp;d_A, nBytes));    CHECK(cudaMalloc((float**)&amp;d_B, nBytes));    CHECK(cudaMalloc((float**)&amp;d_C, nBytes));    CHECK(cudaMemcpy(d_A, h_A, nBytes, cudaMemcpyHostToDevice));    CHECK(cudaMemcpy(d_B, h_B, nBytes, cudaMemcpyHostToDevice));    CHECK(cudaMemcpy(d_C, gpuRef, nBytes, cudaMemcpyHostToDevice));    int iLen = 512;    dim3 block (iLen);    dim3 grid  ((nElem + block.x - 1) / block.x);    iStart = seconds();    sumArraysOnGPU&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_A, d_B, d_C, nElem);    CHECK(cudaDeviceSynchronize());    iElaps = seconds() - iStart;    printf("sumArraysOnGPU&lt;&lt;&lt;%d, %d&gt;&gt;&gt; Time elapsed %f sec\n",            grid.x,block.x, iElaps);    CHECK(cudaGetLastError()) ;    CHECK(cudaMemcpy(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost));        checkResult(hostRef, gpuRef, nElem);    CHECK(cudaFree(d_A));    CHECK(cudaFree(d_B));    CHECK(cudaFree(d_C));    free(h_A);    free(h_B);    free(hostRef);    free(gpuRef);    return(0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA 2.2：编程模型概述(二)</title>
      <link href="/2022/08/15/cuda-2-2-Threads-and-kernel-functions/"/>
      <url>/2022/08/15/cuda-2-2-Threads-and-kernel-functions/</url>
      
        <content type="html"><![CDATA[<h1>CUDA 2.2：线程与核函数</h1><blockquote><p>本篇承接上一篇文章：<a href="https://tuoyou-hao.github.io/2022/08/13/cuda-2-1-CUDA-model-and-memory-allocation/#4%E3%80%81%E4%BB%A3%E7%A0%81">CUDA 2.1 CUDA模型与内存分配</a></p></blockquote><h2 id="一、线程管理">一、线程管理</h2><p>当核函数在主机端启动时，它的执行会移动到设备上，此时设备中会产生大量的线程 ，并且每个线程都执行由核函数指定的语句。CUDA明确了线程层次抽象的概念，以便于我们组织线程。</p><p>这是一个两层的线程层次结构，由线程块和线程块网格构成。</p><ul><li><p>由一个内核启动所产生的所有线程统称为一个网格。</p><p>同一网格中的所有线程共享相同的全局内存空间。</p></li><li><p>一个网格由多个线程块构成</p><p>一个线程块包含一组线程。</p></li></ul><p>同一线程块block内的线程协作可以通过以下方式来实现。</p><ul><li>同步</li><li>共享内存</li></ul><blockquote><p>不同块内线程不能相互影响，他们是物理隔离的！</p></blockquote><p>我们必须明确，一个核函数只能有一个<strong>网络（grid）</strong>，一个网络可以有很多个<strong>块（block）</strong>，每个块可以有很多的线程。</p><p><img src="https://s2.loli.net/2022/08/13/V7xz6Q5dEmB2gNt.png" alt=""></p><p>线程依靠以下两个坐标变量来区分彼此。这里的<code>Idx</code>是<code>index</code>的缩写</p><ul><li><p>blockIdx（线程块在线程格内的索引）</p></li><li><p>threadIdx（块内的线程索引）</p></li></ul><p>这些变量是核函数中需要预初始化的内置变量。当执行一个核函数时，CUDA运行时为每个线程分配坐标变量<code>blockIdx</code>和<code>threadIdx</code>。基于坐标，可以将部分数据分配给不同的线程。</p><p>该坐标变量基于<code>uint3</code>定义的、CUDA内置的向量类型。是一个包含3个无符号整数的结构，可以通过x、y、z三个字段来指定。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">blockIdx.xblockIdx.yblockIdx.zthreadIdx.xthreadIdx.ythreadIdx.z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网格和块的维度一般是二维和三维的，也就是说一个网格通常被分成二维的块，而每个块常被分成三维的线程。</p><p>CUDA可以组织三维的网格和块。如上图，是一个包含二维块的二维网格。</p><p>网格和块的维度由下列两个内置变量指定：</p><ul><li><p>blockDim（线程块的维度，用每个线程块中的线程数来表示）</p></li><li><p>gridDim（线程格的维度，用每个线程格中的线程数来表示）</p></li></ul><p>它们是<code>dim3</code>类型的变量，是基于<code>uint3</code>定义的整数型向量，用来表示维度。当定义一个<code>dim3</code>类型的变量时，所有未指定的元素都被初始化为1。<code>dim3</code>类型变量中的每个组件可以通过它的x、y、z字段获得。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">blockDim.xblockDim.yblockDim.z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>dim3是手工定义的，主机端可见。uint3是设备端在执行的时候可见的，不可以在核函数运行时修改，初始化完成后uint3值就不变了。他们是有区别的！这一点必须要注意。</p></blockquote><h3 id="1、网格和线程块的维度">1、网格和线程块的维度</h3><p>通常，一个线程格会被组织成线程块的二维数组形式，一个线程块会被组织成线程的三维数组形式。</p><p>线程格和线程块均使用3个<code>dim3</code>类型的无符号整型字段，而未使用的字段将被初始化为1且忽略不计。</p><p>我们可以通过以下demo进一步了解块的索引和维度。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;cuda_runtime.h&gt;#include &lt;stdio.h&gt;__global__ void checkIndex(void){    //每个线程都会输出自己的索引和维度  printf("threadIdx:(%d,%d,%d) blockIdx:(%d,%d,%d) blockDim:(%d,%d,%d)\    gridDim(%d,%d,%d)\n",        threadIdx.x,threadIdx.y,threadIdx.z,    blockIdx.x,blockIdx.y,blockIdx.z,blockDim.x,blockDim.y,blockDim.z,    gridDim.x,gridDim.y,gridDim.z);}int main(int argc,char **argv){    //定义一个较小的数据    int nElem=6;    //定义尺寸    dim3 block(3);    //网格大小是块大小的倍数,后续会解释    dim3 grid((nElem+block.x-1)/block.x);    printf("grid.x %d grid.y %d grid.z %d\n",grid.x,grid.y,grid.z);    printf("block.x %d block.y %d block.z %d\n",block.x,block.y,block.z);    checkIndex&lt;&lt;&lt;grid,block&gt;&gt;&gt;();    cudaDeviceReset();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译输出后：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">grid.x 2 grid.y 1 grid.z 1block.x 3 block.y 1 block.z 1threadIdx:(0,0,0) blockIdx:(0,0,0) blockDim:(3,1,1)    gridDim(2,1,1)threadIdx:(1,0,0) blockIdx:(0,0,0) blockDim:(3,1,1)    gridDim(2,1,1)threadIdx:(2,0,0) blockIdx:(0,0,0) blockDim:(3,1,1)    gridDim(2,1,1)threadIdx:(0,0,0) blockIdx:(1,0,0) blockDim:(3,1,1)    gridDim(2,1,1)threadIdx:(1,0,0) blockIdx:(1,0,0) blockDim:(3,1,1)    gridDim(2,1,1)threadIdx:(2,0,0) blockIdx:(1,0,0) blockDim:(3,1,1)    gridDim(2,1,1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，每个线程都有自己的坐标，所有的线程都有相同的块维度和网格维度。</p><h3 id="2、主机端和设备端访问-网格-块-变量">2、主机端和设备端访问(网格/块)变量</h3><p>区分主机端和设备端的网格和块变量的访问是很重要的</p><p>对于一个给定的数据大小，确定网格和块尺寸的一般步骤为：</p><ul><li><p>确定块的大小</p></li><li><p>在已知数据大小和块大小的基础上计算网格维度要确定块尺寸，通常需要考虑：</p></li><li><p>内核的性能特性</p></li><li><p>GPU资源的限制</p></li></ul><p>以下demo介绍如何在主机上定义网格和块的大小</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;cuda_runtime.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv){    int nElem = 1024;    dim3 block (1024);    dim3 grid  ((nElem + block.x - 1) / block.x);    printf("grid.x %d block.x %d \n", grid.x, block.x);    // reset block    block.x = 512;    grid.x  = (nElem + block.x - 1) / block.x;    printf("grid.x %d block.x %d \n", grid.x, block.x);    // reset block    block.x = 256;    grid.x  = (nElem + block.x - 1) / block.x;    printf("grid.x %d block.x %d \n", grid.x, block.x);    // reset block    block.x = 128;    grid.x  = (nElem + block.x - 1) / block.x;    printf("grid.x %d block.x %d \n", grid.x, block.x);    cudaDeviceReset();    return(0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于应用程序中的数据大小是固定的，因此当块的大小发生改变时，相应的网格尺寸也会发生改变。</p><blockquote><p>CUDA的特点之一就是通过编程模型揭示了一个两层的线程层次结构。由于一个内核启动的网格和块的维数会影响性能，所以我们在优化程序的时候要考虑到这一途径。</p><p>网格和块从逻辑上表示了一个核函数的线程层次结构。在CUDA执行模型部分中，你就会发现这种线程组织方式能够在不同的设备上执行相同的程序代码，且每一个线程组织具有不同数量的计算和内存资源。</p></blockquote><h2 id="二、核函数概念">二、核函数概念</h2><p>在C语言中调用函数是使用如下方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">function_name(argument list);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CUDA核函数调用外加了三个尖括号，<code>&lt;&lt;&lt;&gt;&gt;&gt;</code>运算符内是核函数的执行配置。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">kernel_name&lt;&lt;&lt;grid,block&gt;&gt;&gt;(argument list)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行配置的第一个值是网格维度，也就是启动块的数目。第二个值是块维度，也就是每个块中线程的数目。</p><p>通过指定网格和块的维度，你可以进行以下配置：</p><ul><li><p>内核中线程的数目</p></li><li><p>内核中使用的线程布局</p></li></ul><p>同一个块中的线程之间可以相互协作，不同块内的线程不能协作。</p><p>对于一个给定的问题，可以使用不同的网格和块布局来组织你的线程。</p><p>例如，假设你有32个数据元素用于计算，每8个元素一个块，需要启动4个块：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">kernel_name&lt;&lt;&lt;4,8&gt;&gt;&gt;(argument list)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在这里，我们可以使用int类型的变量，或者常量直接初始化。</p></blockquote><p>上述代码的线程布局如下：</p><p><img src="https://s2.loli.net/2022/08/14/H9fWA7S5ZEBDYnw.png" alt=""></p><p>核函数是同时复制到多个线程执行的，为了让多线程按照我们的意愿对应到不同的数据，就要给线程一个唯一的标识。</p><p>由于数据在全局内存中是线性存储的，我们可以用变量<code>blockIdx.x</code>和<code>threadId.x</code>来进行以下操作</p><ul><li><p>在网格中标识一个唯一的线程</p></li><li><p>建立线程和数据元素之间的映射关系</p></li></ul><blockquote><p>补充：如果把所有32个元素放到一个块里，那么只会得到<strong>一个块</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">kernel_name&lt;&lt;&lt;1,32&gt;&gt;&gt;(argument list)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果每个块只含有一个元素，那么会有<strong>32个块</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">kernel_name&lt;&lt;&lt;32,1&gt;&gt;&gt;(argument list)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述代码如果没有特殊结构在核函数中，执行结果应该一致，但是有些效率会一直比较低。</p></blockquote><p>上面这些是启动部分，核函数的调用与主机线程是异步的。核函数调用结束后，控制权立刻返回给主机端。 也就是说，当主机启动了核函数，控制权马上回到主机，而不是主机等待设备完成核函数的运行</p><p>想要主机等待设备端执行可以用下面这个函数，来强制主机端程序等待所有的核函数执行结束：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cudaError_t cudaDeviceSynchronize(void);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是一个显示的方法，对应的也就有隐式方法。</p><p>隐式方法就是不明确说明主机要等待设备端，而是设备端不执行完，主机没办法进行，比如内存拷贝函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cudaError_t cudaMemcpy(void* dst,const void * src,  size_t count,cudaMemcpyKind kind);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个函数在上文有介绍过，当核函数启动后的下一条指令就是从设备复制数据回主机端，那么主机端必须要等待设备端计算完成。</p><blockquote><p>这里再做一次强调：不同于C语言的函数调用，所有的CUDA核函数的启动都是异步的。CUDA内核调用完成后，控制权立刻返回给CPU。</p></blockquote><h2 id="三、编写核函数">三、编写核函数</h2><p>我们会启动核函数了，接下来就是自己定义属于自己的核函数了。</p><p>核函数也是一个函数，但是声明核函数有一个比较模板化的方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ void kernel_name(argument list);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：声明和定义是不同的，这点CUDA与C语言是一致的</p></blockquote><p>在C语言函数前没有的限定符<code>__global__ </code>,CUDA C中还有一些其他我们在C中没有的限定符，如下：</p><table><thead><tr><th style="text-align:center">限定符</th><th style="text-align:center">执行</th><th style="text-align:center">调用</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>global</strong></td><td style="text-align:center">设备端执行</td><td style="text-align:center">可以从主机调用也可以从计算能力3以上的设备调用</td><td style="text-align:center">必须有一个void的返回类型</td></tr><tr><td style="text-align:center"><strong>device</strong></td><td style="text-align:center">设备端执行</td><td style="text-align:center">设备端调用</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>host</strong></td><td style="text-align:center">主机端执行</td><td style="text-align:center">主机调用</td><td style="text-align:center">可以省略</td></tr></tbody></table><p>其中，<code>__device__</code>和<code>__host__</code>限定符可以一起使用，这样函数可以同时在主机和设备端进行编译。</p><p>CUDA  Kernel核函数有以下几个限制，适用于所有核函数：</p><ul><li><p>只能访问设备内存</p></li><li><p>必须具有void返回类型</p></li><li><p>不支持可变数量的参数</p></li><li><p>不支持静态变量</p></li><li><p>显示异步行为</p></li></ul><p>介绍完规则，我们来看一下并行程序经常出现的一种优化现象：把串行代码并行化时对串行代码块for的操作，也就是把for并行化。</p><p>例如在串行条件下，我们会这么写循环：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void sumArraysOnHost(float *A, float *B, float *C, const int N) {  for (int i = 0; i &lt; N; i++)    C[i] = A[i] + B[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在并行情况，我们可以这么写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ void sumArraysOnGPU(float *A, float *B, float *C) {      int i = threadIdx.x;      C[i] = A[i] + B[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>你可能已经注意到循环体已经消失了，内置的线程坐标变量替换了数组索引，由于N是被隐式定义用来启动N个线程的，所以N就没有什么参考价值了。</p><p>假设有一个长度为32个元素的向量，你可以按以下方法用32个线程来调用核函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sumArraysOnGPU&lt;&lt;&lt;1,32&gt;&gt;&gt;(float *A, float *B, float *C)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="四、处理错误">四、处理错误</h2><p>由于许多CUDA调用是异步的，所以有时会很难确定某个错误是由哪一步程序引起的。</p><p>我们可以定义一个错误处理宏封装所有的CUDA API调用，简化了错误检查过程：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define CHECK(call)                                                            \{                                                                              \    const cudaError_t error = call;                                            \    if (error != cudaSuccess)                                                  \    {                                                                          \        fprintf(stderr, "Error: %s:%d, ", __FILE__, __LINE__);                 \        fprintf(stderr, "code: %d, reason: %s\n", error,                       \                cudaGetErrorString(error));                                    \        exit(1);                                                               \    }                                                                          \}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，可以在以下代码中使用宏：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">CHECK(cudaMemcpy(d_C, gpuRef, nBytes, cudaMemcpyHostToDevice));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果内存拷贝或之前的异步操作产生了错误，这个宏会帮我们报告错误代码，并输出一个可读信息。</p><p>也可以用下述方法，在核函数调用后检查核函数错误：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">kernel_function&lt;&lt;&lt;grid,block&gt;&gt;&gt;(argument list);CHECK(cudaDeviceSynchronize());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>CHECK(cudaDeviceSynchronize())</code>会阻塞主机端线程的运行，直到设备端所有的请求任务都结束，并保证最后核函数的启动部分不会出错。</p><p><strong>以上仅是以调试为目的的</strong>，因为在核函数启动后添加这个检查点会阻塞主机端线程，使该检查点成为全局屏障。</p><h2 id="五、完善demo">五、完善demo</h2><p>在上一篇文章中，我们用普通C语言实现一个demo，并尝试换用一部分cuda内存分配的api。</p><blockquote><p>实现目标：两个数组的相加</p><p>数组a的第一个元素与数组b的第一个元素相加，得到的结果作为数组c的第一个元素，重复这个过程直到数组中的所有元素都进行了一次运算。</p></blockquote><p>我们在这里把该demo完善一下：</p><p>先写最简单的初始化数据：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void initialData(float *ip, int size){    // 为随机数生成不同的种子    time_t t;    srand((unsigned) time(&amp;t));    //给每个维度都设置随机数    for (int i = 0; i &lt; size; i++)    {        ip[i] = (float)(rand() &amp; 0xFF) / 10.0f;    }    return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include "../common/common.h" //CHECK所在头文件#include &lt;cuda_runtime.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv){    printf("%s Starting...\n", argv[0]);    // 设置设备    int dev = 0;    CHECK(cudaSetDevice(dev));    // 设置向量的数据大小    int nElem = 1 &lt;&lt; 5;    printf("Vector size %d\n", nElem);    // malloc主机内存    size_t nBytes = nElem * sizeof(float);    float *h_A, *h_B, *hostRef, *gpuRef;    h_A     = (float *)malloc(nBytes);    h_B     = (float *)malloc(nBytes);    hostRef = (float *)malloc(nBytes);    gpuRef  = (float *)malloc(nBytes);    // 在主机端初始化数据    initialData(h_A, nElem);    initialData(h_B, nElem);    memset(hostRef, 0, nBytes);    memset(gpuRef,  0, nBytes);    // malloc设备全局内存    float *d_A, *d_B, *d_C;    CHECK(cudaMalloc((float**)&amp;d_A, nBytes));    CHECK(cudaMalloc((float**)&amp;d_B, nBytes));    CHECK(cudaMalloc((float**)&amp;d_C, nBytes));    // 将数据从主机传输到设备    CHECK(cudaMemcpy(d_A, h_A, nBytes, cudaMemcpyHostToDevice));    CHECK(cudaMemcpy(d_B, h_B, nBytes, cudaMemcpyHostToDevice));    CHECK(cudaMemcpy(d_C, gpuRef, nBytes, cudaMemcpyHostToDevice));    // 在主机端调用内核    dim3 block (nElem);    dim3 grid  (1);    sumArraysOnGPU&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_A, d_B, d_C, nElem);    printf("Execution configure &lt;&lt;&lt;%d, %d&gt;&gt;&gt;\n", grid.x, block.x);    // 将内核结果复制回主机端    CHECK(cudaMemcpy(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost));    // 在主机端添加向量用来进行结果检查    sumArraysOnHost(h_A, h_B, hostRef, nElem);    // 检查设备结果    checkResult(hostRef, gpuRef, nElem);    // 释放设备全局内存    CHECK(cudaFree(d_A));    CHECK(cudaFree(d_B));    CHECK(cudaFree(d_C));    // 释放主机内存    free(h_A);    free(h_B);    free(hostRef);    free(gpuRef);    CHECK(cudaDeviceReset());    return(0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义主机计算向量的函数，用来当正确答案用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void sumArraysOnHost(float *A, float *B, float *C, const int N){    //主机用for循环计算结果    for (int idx = 0; idx &lt; N; idx++)        C[idx] = A[idx] + B[idx];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写核函数的向量计算：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ void sumArraysOnGPU(float *A, float *B, float *C, const int N){    //cuda核函数计算向量相加    int i = threadIdx.x;    if (i &lt; N) C[i] = A[i] + B[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后封装一下检验答案的函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void checkResult(float *hostRef, float *gpuRef, const int N){    //定义误差值    double epsilon = 1.0E-8;    //定义flag    bool match = 1;    //hostRef是主机计算的正确答案,    //gpuRef是GPU计算的答案     //int N是输入维度    for (int i = 0; i &lt; N; i++)    {        //检测到误差过大，就指出错误对应的维度        //并把flag置为false        if (abs(hostRef[i] - gpuRef[i]) &gt; epsilon)        {            match = 0;            printf("Arrays do not match!\n");            printf("host %5.2f gpu %5.2f at current %d\n", hostRef[i],                   gpuRef[i], i);            break;        }    }    if (match) printf("Arrays match.\n\n");    return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本篇CUDA编程模型的概述就到这里结束。下一篇开始会具体介绍CUDA编程模型中的核函数计时，并行线程，设备管理等内容。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA 2.1：编程模型概述(一)</title>
      <link href="/2022/08/13/cuda-2-1-CUDA-model-and-memory-allocation/"/>
      <url>/2022/08/13/cuda-2-1-CUDA-model-and-memory-allocation/</url>
      
        <content type="html"><![CDATA[<h1>CUDA 2.1：CUDA模型与内存分配</h1><p>CUDA编程模型为应用和硬件设备之间的桥梁，所以要知道，CUDA C是编译型语言，不是解释型语言。 下面的结构图片能形象的表现程序和编程模型实现之间的抽象结构的重要。</p><blockquote><p>通信抽象，是编程模型和编译器，库函数之间的分界线。</p><p>我们要用到的语法，内存结构，线程结构等这些我们写程序时我们自己控制的部分，控制了异构计算设备的工作模式，都是属于编程模型。</p><p>它通过<strong>专业的硬件原语</strong>和<strong>操作系统的编译器</strong>或<strong>库</strong>来实现。</p><p>利用编程模型所编写的程序指定了程序的各组成部分是如何共享信息及相互协作的。编程模型从逻辑上提供了一个特定的计算机架构，通常它体现在编程语言或编程环境中。</p></blockquote><p><img src="https://s2.loli.net/2022/08/12/fVNzPAktewZ9JaH.png" alt=""></p><blockquote><p>GPU中大致可以分为：</p><ol><li><p>核函数</p></li><li><p>内存管理</p></li><li><p>线程管理</p></li><li><p>流</p></li></ol><p>等几个关键部分。</p></blockquote><p>以上这些理论同时也适用于其他非CPU+GPU异构的组合。</p><blockquote><p>GPU架构下有几个特有的功能：</p><ul><li><p>通过组织层次结构在GPU上组织<strong>线程</strong>的方法</p></li><li><p>通过组织层次结构在GPU上组织<strong>内存</strong>的方法</p></li></ul></blockquote><p>从宏观上我们可以从以下几个环节完成CUDA应用开发：</p><ol><li>领域层</li><li>逻辑层</li><li>硬件层</li></ol><ul><li><p>在第一步、编程与算法设计的过程中，我们最关心的是<strong>在领域层如何解析数据和函数</strong>，以便在并行环境中正确、高效地解决问题。</p></li><li><p>编程阶段中，我们的关注点应转向<strong>如何组织并发线程</strong>。 这个阶段要从<strong>逻辑层面</strong>思考。</p></li></ul><p>在C语言并行编程中，需要使用<code>pthreads</code>或<code>OpenMP</code>技术来显式地管理线程。CUDA提出了一个线程层次结构抽象的概念，以允许控制线程行为。</p><p>这个抽象为并行变成提供了良好的可扩展性（一个CUDA程序可以在不同的GPU机器上运行，即使计算能力不同）。</p><p>所以说，理解在硬件层上，<strong>线程是如何映射到机器上</strong>就很重要了。这能帮助我们提高性能。</p><h2 id="1、CUDA编程结构">1、CUDA编程结构</h2><p>一个异构环境，通常有<strong>多个CPU</strong>&amp;<strong>多个GPU</strong>。他们都通过PCIe总线相互通信，也是通过PCIe总线分隔开的。所以我们要区分一下两种设备的内存：</p><ul><li>主机(Host)：CPU及其内存</li><li>设备(Device)：GPU及其内存</li></ul><p><strong>这两个内存从硬件到软件都是隔离的</strong>（CUDA6.0 以后支持统一寻址，可使用单个指针访问CPU和GPU内存）</p><p>我们暂时先把统一寻址放一边，先用内存来回拷贝的方法来编写调试程序，以巩固对两个内存隔离这个事实的理解。</p><hr><p>内核（kernel）是CUDA编程模型的一个重要组成部分，其代码在GPU上运行。</p><p>多数情况下，主机可以独立地对设备进行操作。内核一旦被启动，管理权立刻返回给主机，释放CPU来执行<strong>由设备上运行的并行代码实现的</strong>额外的任务。</p><p>CUDA编程模型主要是异步的，因此在GPU上进行的运算可以与主机-设备通信重叠。一个典型的CUDA程序包括由并行代码互补的串行代码。</p><p>如下图，串行代码（及任务并行代码）在主机CPU上执行，而并行代码在GPU上执行。主机代码按照ANSI C标准进行编写，而设备代码使用CUDA C进行编写。</p><p>一个典型的CUDA程序实现流程遵循以下模式，参考下图：</p><p>1.把数据从CPU内存拷贝到GPU内存。</p><p>2.调用核函数对存储在GPU内存中的数据进行操作。</p><p>3.将数据从GPU内存传送回到CPU内存。</p><p><img src="https://s2.loli.net/2022/08/12/vSRwoEmJOIQG6Dc.png" alt=""></p><h2 id="2、内存管理">2、内存管理</h2><p>内存管理在传统串行程序是很常见的。寄存器空间，栈空间内的内存由机器自己管理，堆空间由用户控制分配和释放。</p><p>CUDA程序同样，只是CUDA提供的API<strong>可以分配管理<code>设备</code>上的内存，也可以用CUDA管理<code>主机</code>上的内存。</strong></p><p>用于GPU内存分配的是<code>cudaMalloc</code>函数，其函数原型为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cudaError_t cudaMalloc (void** devPtr, size_t size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数负责向设备分配一定字节的线性内存，并以<code>devPtr</code>的形式返回指向所分配内存<strong>的指针</strong>。</p><p><code>cudaMalloc</code>与标准C语言中的<code>malloc</code>函数基本是一样的，只是这个函数在GPU的内存里分配内存。</p><p>通过充分保持与标准C语言运行库中的接口一致性，可以实现CUDA应用程序的轻松接入。</p><p>下面表格有一些主机API和CUDA C的API的对比：</p><table><thead><tr><th style="text-align:center">标准C函数</th><th style="text-align:center">CUDA C 函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">malloc</td><td style="text-align:center">cudaMalloc</td><td style="text-align:center">内存分配</td></tr><tr><td style="text-align:center">memcpy</td><td style="text-align:center">cudaMemcpy</td><td style="text-align:center">内存复制</td></tr><tr><td style="text-align:center">memset</td><td style="text-align:center">cudaMemset</td><td style="text-align:center">内存设置</td></tr><tr><td style="text-align:center">free</td><td style="text-align:center">cudaFree</td><td style="text-align:center">释放内存</td></tr></tbody></table><p>我们来研究这个表格里最关键的一步，这一步要走总线的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cudaError_t cudaMemcpy(void * dst,const void * src,size_t count,  cudaMemcpyKind kind)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数是内存拷贝过程，可以完成以下几种过程（cudaMemcpyKind kind）</p><ul><li>cudaMemcpyHostToHost</li><li>cudaMemcpyHostToDevice</li><li>cudaMemcpyDeviceToHost</li><li>cudaMemcpyDeviceToDevice</li></ul><p>这四个过程的方向可以清楚的从字面上看出来了</p><p>这个函数以同步方式执行，因为在<code>cudaMemcpy</code>函数返回以及传输操作完成之前，主机应用程序是阻塞的。除了内核启动之外的CUDA调用都会返回一个错误的枚举类型<code>cudaError_t</code>。</p><p>如果GPU内存分配执行成功，则会返回 cudaSuccess ；否则返回 cudaErrorMemoryAllocation</p><p>可以使用以下CUDA运行时函数将错误代码转化为可读的错误消息：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char* cudaGetErrorString(cudaError_t error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、内存层次结构">3、内存层次结构</h2><p>CUDA编程模型最显著的一个特点就是揭示了内存层次结构。每一个GPU设备都有用于不同用途的存储类型。</p><p>在GPU内存层次结构中，最主要的两种内存是<strong>全局内存</strong>和<strong>共享内存</strong>。</p><ul><li><strong>全局</strong>内存类似于CPU的<strong>系统内存</strong></li><li><strong>共享</strong>内存类似于CPU的<strong>缓存</strong>。</li></ul><p>然而GPU的共享内存可以由CUDA C的内核直接控制。</p><p><img src="https://s2.loli.net/2022/08/12/KGO98S3lsnvbj54.png" alt=""></p><p>我们通过一个两个数组相加的例子来学习如何在主机和设备之间进行数据传输，以及如何用CUDA C编程。</p><h2 id="4、代码">4、代码</h2><p>看了这么久的理论，看一下代码放松一下吧<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><blockquote><p>实现目标：两个数组的相加</p><p>数组a的第一个元素与数组b的第一个元素相加，得到的结果作为数组c的第一个元素，重复这个过程直到数组中的所有元素都进行了一次运算。</p></blockquote><p>1、编写主函数。</p><p>我们先把各个变量初始化一下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main(int argc, char **argv){    // 初始化数组大小    int nElem = 1024;    size_t nBytes = nElem * sizeof(float);    // 分配三个同样大小的空间    float *h_A, *h_B, *h_C;    h_A = (float *)malloc(nBytes);    h_B = (float *)malloc(nBytes);    h_C = (float *)malloc(nBytes);    // 生成随机数    initialData(h_A, nElem);     initialData(h_B, nElem);    // 相加    sumArraysOnHost(h_A, h_B, h_C, nElem);     // 释放空间    free(h_A);    free(h_B);    free(h_C);    return(0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中随机数的函数定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void initialData(float *ip, int size){    //随机种子    time_t t;    srand((unsigned) time(&amp;t));    for (int i = 0; i &lt; size; i++)    {        ip[i] = (float)(rand() &amp; 0xFF) / 10.0f;    }    return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后是相加函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void sumArraysOnHost(float *A, float *B, float *C, const int N){    for (int idx = 0; idx &lt; N; idx++)    {        C[idx] = A[idx] + B[idx];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以用gcc之类的C语言编译，也可以使用前一篇介绍的nvcc编译方式编译：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nvcc -Xcompiler -std=c99 sum.c -o sum./sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>-Xcompiler用于指定命令行选项是指向C编译器还是预处理器。</p><p>这里的例子中，将-std=c99传递给编译器，因为这里的C程序是按照C99标准编写的。</p><p>可以在这个网站找到编译器选项：<a href="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html">cuda c</a></p></blockquote><p><strong>改成CUDA代码！</strong></p><p>现在，聪明的你可以在GPU上修改代码来进行数组加法运算，用我们刚刚了解到的<code>cudaMalloc</code>在GPU上申请内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">float *d_A, *d_B, *d_C;cudaMalloc((float**)&amp;d_A, nBytes);cudaMalloc((float**)&amp;d_B, nBytes);cudaMalloc((float**)&amp;d_C, nBytes);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，可以使用cudaMemcpy函数把数据从主机内存拷贝到GPU的全局内存中，参数<code>cudaMemcpyHostToDevice</code>指定了数据拷贝方向。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cudaMemcpy(d_A, h_A, nBytes, cudaMemcpyHostToDevice);cudaMemcpy(d_B, h_B, nBytes, cudaMemcpyHostToDevice);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当数据被转移到GPU的全局内存后，主机端调用核函数在GPU上进行数组求和。</p><p>一旦内核被调用，控制权立刻被传回主机，这样的话，当核函数在GPU上运行时，主机可以执行其他函数。因此，内核与主机是异步的。</p><p>当内核在GPU上完成了对所有数组元素的处理后，其结果将以数组d_C的形式存储在GPU的全局内存中，然后用cudaMemcpy函数把结果从GPU复制回到主机的数组gpuRef中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cudaMemcpy(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>cudaMemcpy的调用会导致主机运行阻塞。cudaMemcpyDeviceToHost的作用就是将存储在GPU上的数组d_c中的结果复制到gpuRef中。最后，调用cudaFree释放GPU的内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cudaFree(d_A);cudaFree(d_B);cudaFree(d_C);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>在这补充一点：CUDA C编程一个经常会发生的错误就是：混用设备和主机的内存地址</p><p>如果你执行了错误的内存分配，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">gpuRef = d_C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而不是正确的方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cudaMemcpy(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应用程序就会崩溃</p><p>为了区分设备和主机端内存，我们可以给变量加后缀或者前缀<code>h_</code>表示host，<code>d_</code>表示device</p><p>并且为了避免这类错误，CUDA 6.0提出了统一寻址，使用一个指针来访问CPU和GPU的内</p><p>存。（当然是以后再介绍了）</p></blockquote><p>很明显，现在我们只是入门了基本的内存处理，要想完善这个demo，我们还需要学习很多。下一篇我们会接着介绍CUDA线程管理</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA 1：并行基础概念</title>
      <link href="/2022/08/11/cuda-1-intro/"/>
      <url>/2022/08/11/cuda-1-intro/</url>
      
        <content type="html"><![CDATA[<h1>CUDA 1：并行基础概念</h1><p>我们传统的计算机结构一般是哈佛体系结构（后来演变出冯·诺依曼结构）</p><p>主要分成三部分：</p><ul><li>内存（指令内存，数据内存）</li><li>中央处理单元（控制单元和算数逻辑单元）</li><li>输入、输出接口</li></ul><p><img src="https://s2.loli.net/2022/08/09/T6uGVtqsW4kQChm.png" alt=""></p><blockquote><p>写并行程序的时候，需要对硬件有一定的了解。</p></blockquote><h2 id="一、并行性">一、并行性</h2><p><strong>写并行程序可以分解任务</strong>。我们一般把一个程序看成是指令和数据的组合。</p><p>并行分为以下两种：</p><ul><li><p>任务并行</p><p>许多任务或函数可以独立地、大规模地并行执行。任务并行的重点在于利用多核系统对任务进行分配</p></li><li><p>数据并行</p><p>同事处理多个数据。数据并行的重点在于利用多核系统对数据进行分配</p></li></ul><blockquote><p>而CUDA就很适合解决数据并行计算的问题</p></blockquote><hr><p>数据并行设计，第一步就是把数据，依据线程进行划分。</p><p>数据并行有两种方案，块划分和周期划分：</p><ul><li><p>块划分（block partitioning）</p><ul><li><p>一组连续的数据放在一个块里，把这一整块数据切成小块</p></li><li><p>每个小块随机的划分给一个线程，每个块的执行顺序随机</p></li><li><p>线程通常在同一个时间内只处理一个数据块</p></li></ul><table><thead><tr><th style="text-align:center">thread</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">block</td><td style="text-align:center">1 2 3</td><td style="text-align:center">4 5 6</td><td style="text-align:center">7 8 9</td><td style="text-align:center">10 11 12</td><td style="text-align:center">13 14 15</td></tr></tbody></table></li><li><p>周期划分（cyclic partitioning）</p><ul><li><p>更少的数据被分到在一个块中，相邻的线程处理相邻的数据块。</p></li><li><p>每个线程可以处理多个数据块。</p></li><li><p>比如我们有五个线程，线程1执行块1，线程2执行块2……线程5执行块5，线程1执行块6</p></li></ul><table><thead><tr><th style="text-align:center">thread</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">block</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">11</td><td style="text-align:center">12</td><td style="text-align:center">13</td><td style="text-align:center">14</td><td style="text-align:center">15</td></tr></tbody></table></li></ul><blockquote><p>如下图所示：</p><ul><li><p>块划分中，每个线程只需要处理数据的一部分</p><p>通常这些数据大小相同</p></li><li><p>周期划分中，每个线程要处理数据的多个部分</p></li></ul><p>颜色相同的块使用的同一个线程，从执行顺序上看如下：</p><p><img src="https://s2.loli.net/2022/08/09/G1fNa6u5CLDBZAT.png" alt=""></p><p><img src="https://s2.loli.net/2022/08/09/6Y3fCOXhxQaDK8d.png" alt=""></p><p>程序的性能对块的大小比较敏感，不同的数据划分严重影响程序性能。</p><p>针对不同的问题和不同计算机结构，我们要通过和理论和试验共同来决定最终最优的数据划分。</p></blockquote><h2 id="二、计算机架构">二、计算机架构</h2><h3 id="1、佛林分类法">1、佛林分类法</h3><p>有多种不同的方法可以对计算机架构进行分类。一个广泛使用的分类方法是弗林分类法（Flynn’s Taxonomy），它根据指令和数据进入CPU的方式，将计算机架构分为4种不同的类型</p><ul><li><p>单指令单数据（SISD）</p><p>传统串行计算机</p></li><li><p>单指令多数据（SIMD）</p><p>并行架构，有多个核心。</p><p>比如向量机，所有核心指令唯一，但是数据不同，现在CPU基本都有这类的向量指令</p></li><li><p>多指令单数据（MISD）</p><p>比较少见，多个指令群殴一个数据</p></li><li><p>多指令多数据（MIMD）</p><p>并行架构，多核心，多指令，异步处理多个数据流，从而实现空间上的并行，MIMD多数情况下包含SIMD，就是MIMD有很多计算核，计算核支持SIMD</p></li></ul><p><img src="https://s2.loli.net/2022/08/09/nYc621kodBQlqvX.png" alt=""></p><p>为了提高并行的计算能力，我们要从架构上实现以下这些性能的提升：</p><ul><li><p>降低延迟</p><ul><li><p>其中，延迟是指操作从开始到结束所需要的时间。</p><p>一般用微秒计算，延迟越低越好。</p></li></ul></li><li><p>提高带宽</p><ul><li>带宽是单位时间内处理的数据量，一般用MB/s或者GB/s表示。</li></ul></li><li><p>提高吞吐量</p><ul><li><p>吞吐量是单位时间内成功处理的运算数量，一般用gflops来表示（十亿次浮点计算）</p><p>吞吐量和延迟有一定关系，都是反映计算速度的，一个是时间除以运算次数，得到的是单位次数用的时间–延迟，一个是运算次数除以时间，得到的是单位时间执行次数–吞吐量。</p></li></ul></li></ul><h3 id="2、根据内存划分">2、根据内存划分</h3><p>计算机架构也可以根据内存进行划分：</p><ol><li><strong>分布式内存</strong>的多节点系统</li><li><strong>共享内存</strong>的多处理器系统</li></ol><p>第一种<strong>分布式内存</strong>的，通常叫做集群。</p><p>可以理解为有好多台电脑，每个电脑都是完整的，有内存处理器电源等一些列硬件。这些电脑通过网络连接互动，这就是分布式。</p><p><img src="https://s2.loli.net/2022/08/09/3DFrjmgIhvexA92.png" alt=""></p><p>第二种<strong>共享内存</strong>的，是单个主板有多个处理器，他们共享相同的主板上的内存，内存寻址空间相同，通过PCIe和内存互动。</p><p><img src="https://s2.loli.net/2022/08/09/DH2QBVuzdao3yWi.png" alt=""></p><p>多个处理器可以分多片处理器，和单片多核（众核many-core），也就是有些主板上挂了好多个处理器，也有的是一个主板上就一个处理器，但是这个处理器里面有几百个核。<br>GPU就属于众核系统。当然现在CPU也都是多核的了，但是他们还是有很大区别的：</p><ul><li>CPU适合执行复杂的逻辑，比如多分支，其核心比较重（复杂），以优化串行程序执行</li><li>GPU适合执行简单的逻辑，大量的数据并行计算，其吞吐量更高，但是核心比较轻（结构简单）</li></ul><h2 id="三、异构计算">三、异构计算</h2><p><strong>不同的计算机架构就是异构</strong></p><p>x86 CPU+GPU的这种异构应该是最常见的，也有CPU+FPGA，CPU+DSP等各种组合。当然超级计算机大部分也采用异构计算的方式来提高吞吐量。</p><p>异构架构虽然比传统的同构架构运算量更大，但是其应用复杂度更高，因为要在两个设备上进行计算，控制，传输，这些都需要人为干预，而同构的架构下，硬件部分自己完成控制，不需要人为设计。</p><h2 id="四、异构架构">四、异构架构</h2><h3 id="4-1-CPU与GPU">4.1 CPU与GPU</h3><p>一个典型的异构计算节点包括两个多核CPU插槽和两个或更多个的众核GPU。</p><p>GPU不是一个独立运行的平台，而是CPU的协处理器。因此，GPU必须通过PCIe总线与基于CPU的主机相连来进行操作，</p><p>如下图，这就是为什么CPU所在的位置被称作主机端，而GPU所在的位置被称作设备端。</p><p>CPU和GPU之间通过PCIe总线连接，用于传递指令和数据，这部分也是后面要讨论的性能瓶颈之一。</p><p><img src="https://s2.loli.net/2022/08/10/Qn8c2hSmFuvDVqJ.png" alt=""></p><p>上面这张图能大致反应CPU和GPU的架构不同。</p><ul><li><p>左图：一个四核CPU一般有四个ALU（算数逻辑单元，可以做数学运算和逻辑运算）也是我们平时说四核八核的核，控制单元，缓存也在片上，DRAM是内存，CPU一般通过总线访问内存。</p></li><li><p>右图：GPU，绿色小方块是ALU，需要注意以下红色框部分<code>SM</code>，这一组ALU公用一个Control单元和Cache，这个部分相当于一个完整的多核CPU，但是不同的是ALU多了，control部分变小，可以看到计算能力提升了，相对的控制能力减弱了</p><p>所以对于控制（逻辑）复杂的程序，一个GPU的SM是没办法和CPU比较的，但是面对逻辑简单，数据量大的任务，GPU更高效。并且一个GPU会有好多个SM。</p></li></ul><hr><p>一个异构应用包括两个部分。</p><ul><li><p>主机代码</p></li><li><p>设备代码</p></li></ul><p>主机代码在主机端运行，被编译成主机架构的机器码，设备端的在设备上执行，被编译成设备架构的机器码。</p><p>所以主机端的机器码和设备端的机器码是隔离的，自己执行自己的，没办法交换执行。</p><p>主机端代码主要是控制设备，完成数据传输等控制类工作，设备端主要的任务就是计算。</p><p>因为当没有GPU的时候CPU也能完成这些计算，只是速度会慢很多，所以可以把GPU看成<strong>CPU的一个加速设备</strong>。</p><h3 id="4-2-GPU计算平台">4.2 GPU计算平台</h3><p>NVIDIA目前的计算平台（不是架构）有：</p><ul><li>Tegra</li><li>Geforce</li><li>Quadro</li><li>Tesla</li></ul><blockquote><p>每个平台针对不同的应用场景，比如：</p><ul><li><p>Tegra用于嵌入式、大规模的并行计算</p></li><li><p>Geforce面向图形用户,平时打游戏用到</p></li><li><p>Quadro用于专业绘图设计</p></li><li><p>Fermi是Tesla系列产品中的一种，用作GPU加速器，近来在高性能计算中获得了广泛应用</p></li></ul></blockquote><p>以下是描述GPU容量的两个重要特征。</p><ul><li><p>CUDA核心数量</p></li><li><p>内存大小</p></li></ul><p>相应的，有两种不同的指标来评估GPU的性能。</p><ul><li><p>峰值计算性能</p><p>峰值计算性能是用来评估计算容量的一个指标，通常定义为每秒能处理的单精度或双精度浮点运算的数量。峰值性能通常用GFlops（每秒十亿次浮点运算）或TFlops（每秒万亿次浮点运算）来表示。</p></li><li><p>内存带宽</p><p>内存带宽是从内存中读取或写入数据的比率。内存带宽通常用 GB/s表示。</p></li></ul><p>nvidia自己有一套描述GPU计算能力的代码，名字是“计算能力”。主要区分不同的架构</p><table><thead><tr><th style="text-align:left">计算能力</th><th style="text-align:left">架构名</th></tr></thead><tbody><tr><td style="text-align:left">1.x</td><td style="text-align:left">Tesla</td></tr><tr><td style="text-align:left">2.x</td><td style="text-align:left">Fermi</td></tr><tr><td style="text-align:left">3.x</td><td style="text-align:left">Kepler</td></tr><tr><td style="text-align:left">4.x</td><td style="text-align:left">Maxwell</td></tr><tr><td style="text-align:left">5.x</td><td style="text-align:left">Pascal</td></tr><tr><td style="text-align:left">6.x</td><td style="text-align:left">Volta</td></tr></tbody></table><blockquote><p>这里的Tesla架构，与上面的Tesla平台不同，不要混淆，一个是平台名字，一个是架构名字</p></blockquote><h2 id="五、异构范例">五、异构范例</h2><p><img src="https://s2.loli.net/2022/08/10/9G2ZsWu7cNP6mTM.png" alt=""></p><p>CPU和GPU相互配合，各有所长，各有所短</p><ul><li><p>低并行逻辑复杂的程序适合用CPU</p></li><li><p>高并行逻辑简单的大数据计算适合GPU</p></li></ul><p>因为CPU和GPU的功能互补性导致了CPU＋GPU的异构并行计算架构的发展，这两种处理器的类型能使应用程序获得最佳的运行效果。</p><p>因此，为了获得最佳性能，你可以同时使用CPU和GPU来执行你的应用程序，在CPU上执行串行部分或任务并行部分，在GPU上执行数据密集型并行部分</p><p><img src="https://s2.loli.net/2022/08/10/6hBqz5QIs2pO9Yc.png" alt=""></p><p>CPU和GPU线程的区别：</p><ol><li>CPU线程是重量级实体，操作系统交替执行线程，线程上下文切换的花销很大</li><li>GPU线程是轻量级的，GPU应用一般包含成千上万的线程，多数在排队状态，线程之间切换基本没有开销。</li><li>CPU的核被设计用来尽可能减少一个或两个线程运行时间的延迟，而GPU核则是大量线程，最大幅度提高吞吐量</li></ol><p>这种代码的编写方式能保证GPU与CPU相辅相成，从而使CPU＋GPU系统的计算能力得以充分利用。为了支持使用CPU＋GPU异构系统架构来执行应用程序，NVIDIA设计了一个被称为CUDA的编程模型</p><h2 id="六、CUDA">六、CUDA</h2><p>CUDA平台不是单单指软件或者硬件，而是建立在Nvidia GPU上的一整套平台，并扩展出多语言支持</p><p><img src="https://s2.loli.net/2022/08/10/Nw3FEmUvuTHM7Bq.png" alt=""></p><p>CUDA C 是标准ANSI C语言的扩展，扩展出一些语法和关键字来编写设备端代码，而且CUDA库本身提供了大量API来操作设备完成计算。</p><p>对于API也有两种不同的层次，一种相对交高层，一种相对底层。</p><ul><li>CUDA驱动API</li><li>CUDA运行时API</li></ul><p><img src="https://s2.loli.net/2022/08/10/VZ8y7pm5JPKFd3l.png" alt=""></p><p>驱动API是低级的API，使用相对困难，运行时API是高级API使用简单，其实现基于驱动API。<br>这两种API是互斥的，也就是你只能用一个。两者之间的函数不可以混合调用，只能用其中的一个库。</p><p>一个CUDA应用通常可以分解为两部分，</p><ul><li>CPU 主机端代码</li><li>GPU 设备端代码</li></ul><p>CUDA nvcc编译器会自动分离你代码里面的不同部分</p><p>如下图，主机代码用C写成，使用本地的C语言编译器编译。设备端代码，也就是核函数，用CUDA C编写，通过nvcc编译，链接阶段，在内核程序调用或者明显的GPU设备操作时，添加运行时库。</p><p><strong>核函数是设备上执行的程序段</strong></p><p><img src="https://s2.loli.net/2022/08/10/HUjEedtPL2ryCOc.png" alt=""></p><p>其中，CUDA nvcc编译器是从LLVM开源编译系统为基础开发的。</p><p><img src="https://s2.loli.net/2022/08/10/OfWcYUVRF3rPw5x.png" alt=""></p><p>CUDA为C和C++开发人员提供了一个综合的开发环境。CUDA工具包包括编译器、数学库，以及调试和优化应用程序性能的工具。</p><p><img src="https://s2.loli.net/2022/08/10/LhAIcz4W5s6lJHi.png" alt=""></p><h2 id="七、CUDA-“Hello-World”">七、CUDA “Hello World”</h2><p>关于CUDA环境配置，本篇不做介绍。不同操作系统需要安装的CUDA和驱动都不一样，本篇使用的是<code>linux</code>系统。具体请参考官网：<a href="https://developer.nvidia.com/">https://developer.nvidia.com/</a></p><p>以下就是CUDA的Hello World。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;__global__ void helloFromGPU(){    printf("Hello World from GPU!\n");}int main(int argc, char **argv){    printf("Hello World from CPU!\n");    helloFromGPU&lt;&lt;&lt;1, 10&gt;&gt;&gt;();    cudaDeviceReset();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li><p><code> __global__</code>的功能是，告诉编译器这个函数将会从CPU中调用，然后在GPU上执行， 是个可以在设备上执行的核函数。</p></li><li><p><code>&lt;&lt;&lt;&gt;&gt;&gt;</code>是c语言没有的，指从主线程到设备端代码的调用。里面的参数是执行配置，用来说明使用多少线程来执行内核函数。</p><p>在这个例子中，有10个GPU线程被调用。</p></li><li><p><code>cudaDeviceRest（）</code>用来显式地释放和清空当前进程中与当前设备有关的所有资源。</p><p>这句话如果没有，则不能正常的运行，因为这句话包含了隐式同步，GPU和CPU执行程序是异步的，核函数调用后成立刻会到主机线程继续，而不管GPU端核函数是否执行完毕，所以上面的程序就是GPU刚开始执行，CPU已经退出程序了，所以我们要等GPU执行完了，再退出主机线程。</p></li></ul><h3 id="编译">编译</h3><p>可以在LINUX命令行使用以下语句编译：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nvcc hello.cu -o hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个使用方式和gcc比较接近</p><p>前面介绍过，nvidia显卡有不同的架构</p><p>使用 NVCC 编译时，可以使用arch 标志 (’ <strong><code>-arch</code></strong>’) 指定了 CUDA 文件将为其编译的 NVIDIA GPU 架构的名称。</p><p>以下是 NVIDIA 架构名称的列表，以及它们具有哪些计算能力：</p><table><thead><tr><th>Fermi</th><th>Kepler</th><th>Maxwell</th><th>Pascal</th><th>Volta</th><th>Turing</th><th>Ampere</th><th><a href="https://www.nvidia.com/en-us/data-center/hopper-architecture/">Hopper</a>*</th><th>Lovelace?</th></tr></thead><tbody><tr><td>sm_20</td><td>sm_30</td><td>sm_50</td><td>sm_60</td><td>sm_70</td><td>sm_75</td><td>sm_80</td><td>sm_90</td><td>sm_100?</td></tr><tr><td></td><td>sm_35</td><td>sm_52</td><td>sm_61</td><td>sm_72</td><td></td><td>sm_86</td><td></td><td></td></tr><tr><td></td><td>sm_37</td><td>sm_53</td><td>sm_62</td><td></td><td></td><td>sm_87</td><td></td><td></td></tr></tbody></table><blockquote><p>其中：</p><p>Fermi 和 Kepler 从 CUDA 9 和 11 起已弃用<br>Maxwell 从 CUDA 11.6 起已弃用<br>Hopper 是 NVIDIA 的“tesla-next”系列，采用 5nm 工艺，取代 Ampere。</p></blockquote><p>所以我们也可以使用以下语句编译，指定所需的架构：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nvcc -arch=sm_60 hello.cu -o hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们还可以使用Makefile来编译：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">APPS=helloall: ${APPS}%: %.cunvcc -O2 -arch=sm_60 -o $@ $&lt;clean:rm -f ${APPS}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行">运行</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ./helloHello World from CPU!Hello World from GPU!Hello World from GPU!Hello World from GPU!Hello World from GPU!Hello World from GPU!Hello World from GPU!Hello World from GPU!Hello World from GPU!Hello World from GPU!Hello World from GPU!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、总结">八、总结</h2><p>一般CUDA程序分成下面这些步骤：</p><ol><li>分配GPU内存</li><li>拷贝内存到设备</li><li>调用CUDA内核函数来执行计算</li><li>把计算完成数据拷贝回主机端</li><li>内存销毁</li></ol><blockquote><p>而上面的Hello World只到第三步，没有进行到内存交换部分。</p></blockquote><p>CPU与GPU的编程主要区别在于对GPU架构的熟悉程度，是否理解机器结构对编程效率影响非常大</p><p>一定要了解你的机器，才能写出优秀的代码。且目前计算设备的架构决定了局部性将会严重影响效率。</p><ul><li><p>数据局部性分为两种</p><ul><li><p>空间局部性：当一个数据被使用，其附近的数据将很快会被使用</p></li><li><p>时间局部性：数据可能会在短时间内被重复使用。</p></li></ul></li><li><p>CUDA中有两个模型是决定性能的：</p><ul><li><p>内存层次结构</p></li><li><p>线程层次结构</p><p>CUDA C写核函数的时候我们只写一小段串行代码，但是这段代码会被成千上万的线程执行，所有线程执行的代码都是相同的。CUDA编程模型提供了一个层次化的组织线程，会直接影响GPU上的执行顺序。</p></li></ul></li><li><p>CUDA抽象了硬件实现：</p><ol><li>线程组的层次结构</li><li>内存的层次结构</li><li>障碍同步</li></ol></li></ul><p>其中，线程、内存将是CUDA编程主要研究的对象</p><p>为此，NVIDIA提供了很多工具：</p><ul><li>Nvidia Nsight集成开发环境</li><li>CUDA-GDB 命令行调试器</li><li>性能分析可视化工具</li><li>CUDA-MEMCHECK工具</li><li>GPU设备管理工具</li></ul><p>后续内容会围绕CUDA展开介绍</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 十二、认识并安装ROS2</title>
      <link href="/2022/08/09/ros-12-ros2-intro-install/"/>
      <url>/2022/08/09/ros-12-ros2-intro-install/</url>
      
        <content type="html"><![CDATA[<h1>ROS 12：引入ROS2</h1><h2 id="一、认识ROS2">一、认识ROS2</h2><p>ROS在需求量增加之后，需要实现：</p><ul><li>多机器人系统</li><li>跨平台</li><li>实时性</li><li>网络连接</li><li>产品化</li><li>项目管理</li></ul><p>ROS2因此出现了。</p><p>ROS2有以下几个特点：</p><blockquote><ul><li><p>ROS1 只支持Linux和MacOS，而 ROS2 支持Linux/Windows/MacOS/RTOS</p></li><li><p>架构的颠覆：</p><p>ROS1的通讯基于TCPROS/UDPROS，所有节点都要经过ROS Master</p><p>ROS2使用基于DDS的Discovery机制，自发现后建立稳定的链接，实现真正的分布式架构</p><ul><li>ROS DDS由ROS Middleware中间件定义接口，使用不同厂商的DDS时，只需安装另一个DDS，代码无需再修改</li></ul></li><li><p>节点模型不同</p><p>ROS1：publish/subscribe</p><p>ROS2：discovery</p></li><li><p>进程模型不同</p><p>ROS1：Nodelet</p><p>ROS2：Intra-process</p></li><li><p>编译系统升级</p><p>ROS1使用rosbuild，catkin管理项目</p><p>ROS2使用升级版的ament，colcon</p></li><li><p>ROS2 支持实时控制</p></li><li><p>ROS2 广泛使用C++11，和Python3.5以上</p></li><li><p>在 ROS2 上通过ros_bridge和 ROS1 进行通信</p></li><li><p>ROS2 使用托管启动：用户可以指定节点启动顺序</p></li><li><p>ROS2 取消了 nodelet 的概念，支持多节点初始化</p></li><li><p>ROS2 launch文件使用 python 编写，相比于 xml 拓展了功能性</p></li><li><p>……</p></li></ul></blockquote><p><img src="https://s2.loli.net/2022/08/09/J5U6qIusKpZQbWe.png" alt=""></p><h2 id="二、安装">二、安装</h2><blockquote><p>以下是按照Ubuntu22.04版本安装</p><p>ROS2在Ubuntu只支持22.04与20.04，其中20.04需要源码安装</p></blockquote><p>设置编码</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt update &amp;&amp; sudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>添加源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt update &amp;&amp; sudo apt install curl gnupg lsb-release sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果添加源出现<code>Failed to connect to raw.githubusercontent.com</code>的报错，按照以下步骤即可：</p><p>登录网站：<a href="https://www.ipaddress.com/">https://www.ipaddress.com</a></p><p>在打开的网站中将“<a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a>”复制到查询栏中进行搜索，可以看到域名对应的IP地址信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo chmod 777 /etc/hosts <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用编辑器打开这个文件，<strong>在文末添加你查询到的结果</strong>，比如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">151.101.84.133 raw.githubusercontent.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存退出，改回权限：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo chmod 644 /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可正常使用</p></blockquote><p>安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt updatesudo apt upgradesudo apt install ros-humble-desktop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>环境变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source /opt/ros/humble/setup.bashecho " source /opt/ros/humble/setup.bash" &gt;&gt; ~/.bashrc <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>测试：</p><h3 id="测试1">测试1</h3><p>创建一个发布者：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ros2 run demo_nodes_cpp talker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再创建一个监听者：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ros2 run demo_nodes_py listener<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到两个中断可以正常打印数据即可</p><h3 id="测试2">测试2</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ros2 run turtlesim turtlesim_noderos2 run turtlesim turtle_teleop_key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>观察到可以正常运行即可</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows设置汇总</title>
      <link href="/2022/08/08/win1011_setting_summary/"/>
      <url>/2022/08/08/win1011_setting_summary/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Window-设置汇总"><a href="#Window-设置汇总" class="headerlink" title="Window 设置汇总"></a>Window 设置汇总</h1><p>这里汇总一些Win11（Win10也差不多）的操作小技(fei)巧(hua)，不定期更新<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="1、cmd指令补全"><a href="#1、cmd指令补全" class="headerlink" title="1、cmd指令补全"></a>1、cmd指令补全</h2><p><kbd>win</kbd>+<kbd>r</kbd>输入<code>regedit</code></p><p> 进入<code>HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Command Processor</code>，选择CompletionChar </p><p>数值选择9，选择十进制，然后重启电脑即可</p><h2 id="2、菜单栏改成经典菜单"><a href="#2、菜单栏改成经典菜单" class="headerlink" title="2、菜单栏改成经典菜单"></a>2、菜单栏改成经典菜单</h2><p>管理员身份运行<code>cmd</code>，输入：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">reg add "HKCU\SOFTWARE\CLASSES\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32" /f /ve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、桌面路径改到d盘"><a href="#3、桌面路径改到d盘" class="headerlink" title="3、桌面路径改到d盘"></a>3、桌面路径改到d盘</h2><blockquote><p>注意备份文件哦</p></blockquote><p><kbd>win</kbd>+<kbd>r</kbd>输入<code>regedit</code></p><p>进入<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code></p><p>右侧找到<code>Desktop</code>，双击打开</p><p>将里面的值改为<code>D:\Desktop</code>即可</p><h2 id="4、磁盘分配空间"><a href="#4、磁盘分配空间" class="headerlink" title="4、磁盘分配空间"></a>4、磁盘分配空间</h2><p>右键 “此电脑” ，菜单栏选择 “管理” ，选择 “磁盘管理” 即可。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 十一、命名空间</title>
      <link href="/2022/08/08/ros-11-namespace/"/>
      <url>/2022/08/08/ros-11-namespace/</url>
      
        <content type="html"><![CDATA[<h1>ROS 十一: 命名空间</h1><p>如果你熟悉c++代码，一定对这句话很熟悉</p><p><code>using namespace std;</code></p><p>这一句话表示的是，使用std这个命名空间，此时就可以直接使用<code>cout</code>，而不用完整写上<code>std::cout</code>。</p><p>在ROS中，命名空间的概念是相似的，同样也是为了区分名称，这个名称包括<u>节点名称、话题名称、参数名称</u>等等</p><p>比如查询topic列表时：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ rostopic list/rosout/rosout_agg/tf/tf_static/turtle1/cmd_vel/turtle1/color_sensor/turtle1/pose/turtle2/cmd_vel/turtle2/color_sensor/turtle2/pose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到同时有两个叫pose的topic，但是因为在pose前面添加了一层命名空间，使其避免了冲突，这样就可以很方便地使用同一份代码在多个节点上运行了，实现的节点的复用。</p><h2 id="1、计算图源">1、计算图源</h2><p>根据前面的学习，在ROS系统中这些节点、话题、服务和参数等概念，在ROS系统统称为计算图源。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::init(argc, argv, "pokemon_server"); ros::NodeHandle ser_pokemon_node; Callback ros::ServiceServer pokemon_server = ser_pokemon_node.advertiseService("/pokemon_show", Callback);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参考上面的代码，其中第三行的<code>/pokemon_show</code>就是一种命名空间名称的方式</p><h2 id="2、计算图源名称的命名规则">2、计算图源名称的命名规则</h2><p>在ROS系统中无论是节点还是话题都有自己的名称，如C++语言中的标识符一样，在ROS中命名也有自己的规则：<br>1）首字符必须是字母（A-Z|a-z）、波浪线（~）或者左斜杆（/）<br>2）后续字符可以是字母和数字、下划线或者左斜杠</p><h2 id="3、计算图源名称的分类">3、计算图源名称的分类</h2><h3 id="1）全局名称：-global-name：即在任何地方（包括代码、命令行工具、图形界面工具等的任何地方）都可以使用">1）全局名称：/global/name：即在任何地方（包括代码、命令行工具、图形界面工具等的任何地方）都可以使用</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::init(argc, argv, "publish_node_A");ros::NodeHandle nh;ros::Publisher sub_pub = nh.advertise&lt;std_msgs::string&gt;("/A/chatterA",1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>以“/”开头的名称是<strong>全局名称</strong>——它们被认为是完全解析的。 ros系统的根命名空间是"/"</li></ul><h3 id="2）相对名称：relative-name；">2）相对名称：relative/name；</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::init(argc, argv, "publish_node_A");ros::NodeHandle nh;ros::Publisher sub_pub = nh.advertise&lt;std_msgs::string&gt;("A/chatterA",1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>相对名称</strong>则是在创建的时候没有左斜杠（/）的计算图源名称，ROS在解析相对名称的时候需要将其转化为全局名称，而转换的方式就是将其默认的命名空间的名称加在相对名称之前。</li><li>确定默认命名空间有三种方式：<ul><li>1）通过命令参数设置：调用ros::init()的ROS的ROS程序会接收名为<code>_ns</code>命令行参数，赋值的方式为： <code>_ns:=name</code></li><li>2）在launch文件中设置</li><li>3） 使用环境变量设置</li></ul></li></ul><h3 id="3）私有名称：-private-name；">3）私有名称：~private/name；</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::init(argc, argv, "publish_node_A");ros::NodeHandle nh("~");ros::Publisher sub_pub = nh.advertise&lt;std_msgs::string&gt;("chatterA",1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>以“~”开头的名称是<strong>私有名称</strong>。他们将节点的名称转换为命名空间。例如，命名空间<code>/wg</code> 中的<code>node1</code>具有私有命名空间<code>/wg/node1</code>。私有名称在<strong>通过参数服务器将参数传递给特定节点</strong>很有用。</li><li>私有名称是一个节点的内部私有的资源名称，只会在节点内部使用。</li><li>默认情况下，解析是相对于节点的命名空间完成的。例如，节点<code>/wg/node1</code>具有命名空间<code>/wg</code>，因此名称<code>node2</code>将解析为<code>/wg/node2</code>。</li></ul><h3 id="4）基础名称：base">4）基础名称：base</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::init(argc, argv, "publish_node_A");ros::NodeHandle nh;ros::Publisher sub_pub = nh.advertise&lt;std_msgs::string&gt;("chatterA",1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>没有命名空间限定符的名称是<strong>基本名称</strong>。基本名称实际上是相对名称的子类，并且具有相同的解析规则。基本名称最常用于初始化节点名称。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 十、Launch入门</title>
      <link href="/2022/08/08/ros-10-launch-flie/"/>
      <url>/2022/08/08/ros-10-launch-flie/</url>
      
        <content type="html"><![CDATA[<h1>ROS 十：launch文件入门</h1><p>launch文件是一种以xml为主要语法的描述文件</p><p><strong>启动launch文件可以自动启动ROS Master。</strong></p><h2 id="一、基本语法">一、基本语法</h2><ul><li><code>&lt;launch&gt;</code>: launch文件中的更元素使用这个标签阿莱定义</li><li><code>&lt;node&gt;</code>:启动节点<ul><li><p>pkg：节点所在的功能包名称</p></li><li><p>type：节点的可执行文件名称</p></li><li><p>name：节点运行时的名称</p></li><li><p>output：(可选) “log | screen” 。 默认值为“log”。</p><ul><li>‘screen’，stdout / stderr从节点将被发送到屏幕。</li><li>“log”，stdout / stderr输出将被发送到$ ROS_HOME/ log中的日志文件，stderr将继续发送到屏幕。</li></ul></li><li><p>respawn：(可选)  布尔值</p><p>如果节点退出，则自动重新启动节点。</p><p>对于每个节点，设置复位属性为真的时候， respawn=”true”，这样当节点停止的时候，roslaunch会重新启动该节点。</p><p>比如在某个节点因为软件崩溃或硬件故障以及其他原因导致过早退出系统的时候会起到作用。</p><ul><li><p>respawn_delay (可选，默认为0)</p><p>如果respawn为true，roslaunch尝试重新启动之前，检测到节点故障后等待respawn_delay秒</p></li></ul></li><li><p>required：(可选) 布尔值</p><p>当一个required node终止后，所有其他的nodes都会终止，并退出。这种命令有时很有用。比如，当一个很重要的node失败后，整个会话都会被扔掉，那些加上了respawn属性的nodes也会停止。</p></li><li><p>ns：(可选)节点的命名空间</p><p>在设置的命名空间中启动节点。前提是节点的代码在创建 发布者 和 订阅者 对象时使用了像 <code>turtle1/pose</code> 这样的相对名称 (而不是<code>/turtle1/pose</code> 这样的全局名称)。</p><p>同样，启动文件中的节点名称是相对名称。</p></li><li><p>args：(可选)</p><p>args =“arg1 arg2 …… argn”。传递参数到节点。</p></li><li><p>machine：(可选)</p><p>在指定机器上启动节点。</p></li><li><p>clear_params ：(可选)</p><p>在启动前删除节点的私有命名空间中的所有参数。</p></li><li><p>launch-prefix：(可选)</p><p>用于预先添加到节点的启动参数的命令/参数。</p></li></ul></li></ul><p>可以在<code>&lt;node&gt;</code>标记中使用以下XML 标签：</p><ul><li><p><code>&lt;env&gt;</code>——为节点设置环境变量。</p></li><li><p><code>&lt;group&gt;</code>——标签可以对节点分组，具有 ns 属性，可以让节点归属某个命名空间</p></li><li><p><code>&lt;remap&gt;</code>——为此节点设置重新映射参数。</p><p>重映射是基于替换的思想，每个重映射包含一个原始名称和一个新名称。每当节点使用重映射中的原始名称时，ROS客户端库就会将它默默地替换成其对应的新名称。</p><p>例如，运行一个 turtlesim 的实例， 如果想要把海龟的姿态数据发布到话题/tim 而不是/turtle1/pose，就可以使用如下命令：</p><p><code>rosrun turtlesim turtlesim_node turtle1/pose:=tim</code></p><p>通过启动文件的方式，只需在启动文件内使用重映射（remap）元素即可：</p><p><code>&lt;remap from=”turtle1/pose”to ”tim”/&gt;</code></p></li><li><p><code>&lt;rosparam&gt;</code>——将rosparam文件加载到此节点的 ~/ local命名空间中。</p></li><li><p><code>&lt;param&gt;</code>——在节点的 ~/ local命名空间中设置一个参数。</p></li></ul><h2 id="二、demo">二、demo</h2><p>以上一篇小海龟tf案例为例，海龟2会一直跟随海龟1一直运动</p><p>具体案例和代码可参考：<a href="https://tuoyou-hao.github.io/2022/08/02/ros-9-tf-introduction/">tf坐标系简介</a></p><blockquote><p>参考第一部分的介绍，来看以下的demo</p></blockquote><p><strong>c++</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim_node<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sim<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle_teleop_key<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teleop<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>True<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>learn-tf<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>broadcaster<span class="token punctuation">"</span></span> <span class="token attr-name">args</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/turtle1<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle_tf_b1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>learn-tf<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>broadcaster<span class="token punctuation">"</span></span> <span class="token attr-name">args</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/turtle2<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle_tf_b2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>learn-tf<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listener<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listener<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>python</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim_node<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sim<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle_teleop_key<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teleop<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>True<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle1_tf_broadcaster<span class="token punctuation">"</span></span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>learn-tf<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>broadcaster.py<span class="token punctuation">"</span></span> <span class="token attr-name">respawn</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>node</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle2_tf_broadcaster<span class="token punctuation">"</span></span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>learn-tf<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>broadcaster.py<span class="token punctuation">"</span></span> <span class="token attr-name">respawn</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle2<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>node</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>learn-tf<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listener.py<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listener<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写完毕后，直接使用<code>roslaunch &lt;路径/launch文件名&gt;</code>即可直接运行，并无需启动ROS Master。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 九、坐标管理系统Tf简介</title>
      <link href="/2022/08/02/ros-9-tf-introduction/"/>
      <url>/2022/08/02/ros-9-tf-introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS-九：坐标管理系统tf简介"><a href="#ROS-九：坐标管理系统tf简介" class="headerlink" title="ROS 九：坐标管理系统tf简介"></a>ROS 九：坐标管理系统tf简介</h1><p>关于机器人学中的坐标变换，原本计划在本篇介绍，奈何整理过后的篇幅过长，还烦请移步<a href="https://tuoyou-hao.github.io/2022/08/02/slam-1-Fundamentals-of-three-dimensional-space-mathematics/">三维坐标介绍</a>了解相关的前置知识。</p><h2 id="一、tf简介"><a href="#一、tf简介" class="headerlink" title="一、tf简介"></a>一、tf简介</h2><p>由于机器人上会安装相当多的组件，比如激光雷达、摄像机等等，他们都会组装在机器人外壳上的不同位置，因此他们拥有各自不同的坐标系。</p><p>而当一个机器人设计的很庞大的时候，就会有忒儿多的坐标系要我们管理，需要运算相当多的矩阵。</p><p>tf功能包会帮助我们管理坐标系，把底层的数学计算都封装好了，我们无需再实现数学计算功能。tf会广播和监听坐标变换，这和我们之前了解到的Publisher与Service这两套通讯方式是不一样的。</p><p>tf会记录10秒内机器人所有坐标系的位置关系。所有坐标系都会以树形数据结构存储（tf tree）。</p><h2 id="二、tf安装与demo运行"><a href="#二、tf安装与demo运行" class="headerlink" title="二、tf安装与demo运行"></a>二、tf安装与demo运行</h2><ul><li>安装turtle tf。本教程用的是melodic版本的ROS，需要根据版本号</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install ros-melodic-turtle-tf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>运行demo。分别用不同的终端来运行。</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">roslaunch turtle_tf turtle_tf_demo.launch#运行launch脚本rosrun turtlesim turtle_teleop_key#控制小海龟移动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>其中，<code>roslaunch</code>是ROS启动launch脚本使用的指令，后续会介绍launch文件的编程</p></li><li><p>启动后，通过<code>turtle_teleop_key</code>控制小海龟移动，可以看到第二只小海龟会比较第一只海龟的坐标，然后会一直跟随第一只小海龟。</p></li></ul><h3 id="2-1-tf的工具"><a href="#2-1-tf的工具" class="headerlink" title="2.1 tf的工具"></a>2.1 tf的工具</h3><h4 id="1、view-frames"><a href="#1、view-frames" class="headerlink" title="1、view_frames"></a>1、view_frames</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosrun tf view_frames#查看目前tf之间的关系的可视化工具<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>tf的<code>view_frames</code>是查看tf之间关系的可视化工具。他会先监听五秒钟，然后保存这些图到一个pdf文件。这个文件会放在终端的当前目录下。</li></ul><p><img src="https://s2.loli.net/2022/08/02/aWkiRvHZDuFnAfV.png" alt="tf-view_frames"></p><p>world坐标系是一个全局的坐标系，记录整个仿真器的坐标原点。两个turtle是两个会移动的坐标系。上面的<strong>tf tree</strong>图就记录了三个坐标系之间的关系。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#rosrun tf tf_echo &lt;node1&gt; ... &lt;node n&gt;rosrun tf tf_echo turtle1 turtle2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2、tf-echo"><a href="#2、tf-echo" class="headerlink" title="2、tf_echo"></a>2、tf_echo</h4><p><code>tf_echo</code>是一个命令行工具，可以直接帮我们查询几个坐标系之间的关系。他会有类似如下输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">At time 1659434555.866- Translation: [0.000, 0.000, 0.000]- Rotation: in Quaternion [0.000, 0.000, 0.707, 0.707]            in RPY (radian) [0.000, -0.000, 1.571]            in RPY (degree) [0.000, -0.000, 90.000]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Translation：是指在XYZ坐标上的平移，三个值分别代表X,Y,Z</p></li><li><p>Rotation：是指如何旋转会得到一样的姿态。里面三行数据是等价的，知识用三种不同的描述方式展示出来：</p><ul><li>Quaternion是指四元数，用XYZW表示。</li><li>RPY是指分别按照x轴，y轴，z轴旋转<ul><li>radian是通过弧度表示</li><li>degree是通过角度表示</li></ul></li></ul></li></ul><h4 id="3、rviz"><a href="#3、rviz" class="headerlink" title="3、rviz"></a>3、rviz</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosrun rviz rviz -d 'rospack find turtle_tf' /rivz/turtle_rivz.rivz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后要在rviz界面左侧的<code>Fixed Frame</code>选项选择<code>world</code>，在左下角<code>add</code>选项打开菜单，滑到最底下勾选<code>tf</code>，就可以看到前demo正在运行的两只小海龟了。可以试着使用<code>turtle_teleop_key</code>控制小海龟，看rviz的实时效果。</p><p>对于两个turtle的坐标关系来说，可以用如下式子计算，是两个4x4矩阵的乘法：<br>$$<br>T_{turtle1-turtle2}=T_{turtle1-world}\times T_{world-turtle2}<br>$$</p><h2 id="三、编程实现"><a href="#三、编程实现" class="headerlink" title="三、编程实现"></a>三、编程实现</h2><h3 id="1、tf广播器-Broadcaster"><a href="#1、tf广播器-Broadcaster" class="headerlink" title="1、tf广播器(Broadcaster)"></a>1、tf广播器(Broadcaster)</h3><h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><p>头文件和全局变量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;ros/ros.h&gt;#include&lt;tf/transform_broadcaster.h&gt;#include&lt;turtlesim/Pose.h&gt;std::string turtle_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc,char **argv){    ros::init(argc,argv,"tf_broadcaster");        //检查输入的参数，并保存下来    if(argc!=2){        ROS_ERROR("Need turtle name as argument!");        return -1;    }    turtle_name = argv[1];    ros::NodeHandle tf_b_node;    //初始化订阅者    ros::Subscriber tf_sub = tf_b_node.subscribe(turtle_name+"/pose",10,&amp;TfPoseCallback);    ros::spin();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回调函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void TfPoseCallback(const turtlesim::PoseConstPtr&amp; msg){    //创建一个广播器    static tf::TransformBroadcaster tf_broadcaster;    //设置平移的向量参数    tf::Transform transform;    //把平移值放到transform里    transform.setOrigin(tf::Vector3(msg-&gt;x,msg-&gt;y,0.0));        //设置旋转四元数    tf::Quaternion q;    q.setRPY(0,0,msg-&gt;theta);    //把四元数值放到transform里    transform.setRotation(q);   //广播数据，并将数据放在tf tree里    //函数：StampedTransform(存的变量，时间戳(now)，坐标系1，坐标系2)    tf_broadcaster.sendTransform(tf::StampedTransform        (transform,ros::Time::now(),"world",turtle_name));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cmake</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_executable(broadcaster src/broadcaster.cpp)target_link_libraries(broadcaster ${catkin_LIBRARIES})add_executable(listener src/listener.cpp)target_link_libraries(listener ${catkin_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyimport roslibroslib.load_manifest('learn-tf')import tfimport turtlesim.msgdef handle_turtle_pose(msg,turtlename):    #定义广播器    tf_broadcaster = tf.TransformBroadcaster()    #广播数据    tf_broadcaster.sendTransform((msg.x,msg.y,0),        tf.transformations.quaternion_from_euler(0, 0, msg.theta),        rospy.Time.now(),        turtlename,        "world")if __name__ == '__main__':    rospy.init_node('tf_broadcaster_py')    #从超参获取海龟名字    turtlename = rospy.get_param('~turtle')    rospy.Subscriber('/%s/pose'%turtlename,        turtlesim.msg.Pose,        handle_turtle_pose,        turtlename)    rospy.spin()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、监听器"><a href="#2、监听器" class="headerlink" title="2、监听器"></a>2、监听器</h3><h4 id="c-1"><a href="#c-1" class="headerlink" title="c++"></a>c++</h4><p>头文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include &lt;tf/transform_listener.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;turtlesim/Spawn.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>主函数</p><p>先请求生成turtle2</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::init(argc,argv,"tf_listener");ros::NodeHandle tf_l_node;ros::service::waitForService("/spawn");ros::ServiceClient add_turtle = tf_l_node.serviceClient&lt;turtlesim::Spawn&gt;("/spawn");turtlesim::Spawn srv;add_turtle.call(srv);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再创建发布控制turtle2的发布者</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::Publisher turtle_vel = tf_l_node.advertise&lt;geometry_msgs::Twist&gt;("/turtle2/cmd_vel",10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建tf的监听器</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">tf::TransformListener listener;ros::Rate rate(10.0);while(tf_l_node.ok()){    //获取turtle1与turtle2坐标系之间的tf数据    //保存期平移旋转数据    tf::StampedTransform transform;    try    {        //等待变换        //传入变量(两个坐标系、查询的时间戳(当前的时间)、超时的阈值(这里是3s))    listener.waitForTransform("/turtle2","turtle1",ros::Time(0),ros::Duration(3.0));        //查询变换        //传入变量(两个坐标、查询的时间戳(当前的时间)、查询结果存放的变量)    listener.lookupTransform("/turtle2","turtle1",ros::Time(0),transform);    }    catch(tf::TransformException &amp;ex)    {        ROS_ERROR("%s",ex.what());        ros::Duration(1.0).sleep();        continue;    }        //计算欧氏距离，乘以设置的时间系数    geometry_msgs::Twist vel_msg;    // 希望用0.25秒时间完成转动    // (0.25) * y/x的反正切值    vel_msg.angular.z = 4.0 * atan2(transform.getOrigin().y(),    transform.getOrigin().x());    // 希望用2秒时间完成移动    // (1/2) * √x^2+y^2    vel_msg.linear.x = 0.5 * sqrt(pow(transform.getOrigin().x(), 2) +    pow(transform.getOrigin().y(), 2));    //发布turtle2的控制指令    turtle_vel.publish(vel_msg);    rate.sleep();}return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyimport mathimport tfimport geometry_msgs.msgimport turtlesim.srvimport roslibroslib.load_manifest('learn-tf')def py_listener():    rospy.init_node('turtle_tf_listener')    listener = tf.TransformListener()    rospy.wait_for_service('spawn')    spawner = rospy.ServiceProxy('spawn',turtlesim.srv.Spawn)    spawner(4,2,0,'turtle2')    turtle_vel = rospy.Publisher('turtle2/cmd_vel',geometry_msgs.msg.Twist,queue_size=1)    rate=rospy.Rate(10.0)    while not rospy.is_shutdown():        try:            (trans,rot)=listener.lookupTransform('/turtle2','turtle1',rospy.Time(0))        except(tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):            continue        angular = 4 * math.atan2(trans[1], trans[0])        linear = 0.5 * math.sqrt(trans[0] ** 2 + trans[1] ** 2)        cmd = geometry_msgs.msg.Twist()        cmd.linear.x = linear        cmd.angular.z = angular        turtle_vel.publish(cmd)        rate.sleep()if __name__ == '__main__':    py_listener()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、运行"><a href="#3、运行" class="headerlink" title="3、运行"></a>3、运行</h3><p>在终端运行的方式：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ~/ros_ws #进入工作空间根目录catkin_makesource devel/setup.bashroscorerosrun turtlesim turtlesim_node#下面rosrun的是自己定义功能包的名称和代码#是自己起名的，配置如下，供参考#catkin_create_pkg learn-tf roscpp rospy tf turtlesim# __name的重映射会把我们设置的明智直接取代代码中ros::init设置的节点名# rosrun learn-tf broadcaster 重映射机制 输入的参数(海龟的名字)rosrun learn-tf broadcaster __name:=turtle1_broadcaster /turtle1rosrun learn-tf broadcaster __name:=turtle2_broadcaster /turtle2rosrun learn-tf listenerrosrun turtlesim turtle_teleop_key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为这里需要开启很多终端、输入很得多指令，实际启动项目的时候不可能如此繁琐地启动这么多指令。所以下一章将介绍如何使用launch文件快速启动本篇中c++和python的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM：三维空间数学基础</title>
      <link href="/2022/08/02/slam-1-Fundamentals-of-three-dimensional-space-mathematics/"/>
      <url>/2022/08/02/slam-1-Fundamentals-of-three-dimensional-space-mathematics/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>警告：本篇含有大量数学公式，请尽量在网络良好的状态下访问<br>网络较差的情况下，数学公式渲染容易出问题</p></blockquote><h1 id="三维空间刚体运动基础"><a href="#三维空间刚体运动基础" class="headerlink" title="三维空间刚体运动基础"></a>三维空间刚体运动基础</h1><p>在机器人学中，有一个很重要的知识点叫做坐标系变换。</p><p>本篇将简单涉及一下坐标系的相关知识</p><p>我们日常生活中的空间是三维的，我们使用的坐标系如下图：</p><p><img src="https://s2.loli.net/2022/07/31/qROvSx3TeG2NH7t.png" alt="坐标系"></p><blockquote><p><strong>我们对坐标系的几点说明：</strong></p><ul><li>像题图那样的彩色坐标系，若无特别说明，都是<strong>rgb(红绿蓝）依次对应*xyz*</strong></li><li>当我们说绕某一个轴旋转多少角度时，正方向的确定用<strong>右手定则</strong>，如下图：</li></ul><p><img src="https://s2.loli.net/2022/08/01/g3LdsNK1aMxPQeu.png"></p><ul><li>我们用的都是<strong>右手坐标系</strong>，即<strong>绕<em>z</em>轴旋转时，<em>y</em>轴在<em>x</em>轴的+90度方向</strong>，其他轴类似，<strong>四指弯曲的方向即为正方向</strong></li><li>提到某一个坐标系，比如坐标系A时，我们说<strong>frame{A}<strong>，用</strong>大括号</strong>表示</li><li>提到任意需要指明参照系的量时，我们<strong>将坐标系写在左上角</strong>，如坐标系{A}中点P的位置向量写作$^{A}P$</li><li>我们<strong>将物体/点的名称写在右下角</strong>，如坐标系{A}中点O的位置向量写作$^{A}P_{O}$</li><li>提到一个量是相对于某个坐标系时，比如{A}，我们说<strong>with respect to</strong> {A}，或简写为<strong>w.r.t</strong> {A}。</li><li>本文及以后的文章中<strong>所有向量都是列向量，所有向量的转置都是行向量</strong></li><li>以上是一套比较常用的标记系统(convention)，始终遵循同一套convention有助于在混乱的坐标变换中找到清晰的思路；如果你已经有常用的记法，那么保持你自己的记法也是可以的</li></ul></blockquote><h2 id="1、向量与坐标系"><a href="#1、向量与坐标系" class="headerlink" title="1、向量与坐标系"></a>1、向量与坐标系</h2><p>回到原题，我们用线性代数的知识来说，三维空间中某个点的坐标可以用$\mathbb R^{3}$来描述。我们找到该空间的一组基<sup class="refplus-num"><a href="#ref-ji">[1]</a></sup>，那么，任意向量a就有这么个坐标如下：$$a = \begin{bmatrix}  e1 &amp; e2 &amp; e3\end{bmatrix}\begin{bmatrix} a1\\\\ a2\\\\ a3\end{bmatrix}= a1e1 + a2e2 + a3e3$$这里$(a1,a2,a3)^{T}$成为a在此基下的坐标。对于$a,b\in \mathbb R^{3}$，通常意义下的**内积**是：$$a \cdot b = a^{T}b = \sum_{i=1}^{3}a_{i}b_{i}=|a||b|\cos \left \langle a,b \right \rangle $$其中$\left \langle a,b \right \rangle $为向量a，b的夹角。内积也可以描述向量间的投影关系，外积则是这样的$$a\times b = \begin{Vmatrix} e_{1} &amp; e_{2} &amp; e_{3}\\\\ a_{1} &amp; a_{2} &amp; a_{3}\\\\ b_{1} &amp; b_{2} &amp; b_{3}\end{Vmatrix}= \begin{bmatrix} a_{2}b_{3} - a_{3}b_{2}\\\\ a_{3}b_{1} - a_{1}b_{3}\\\\ a_{1}b_{2} - a_{2}b_{1}\end{bmatrix}=\begin{bmatrix} 0 &amp; -a_{3} &amp; a_{2}\\\\ a_{3} &amp; 0 &amp; -a_{1}\\\\ -a_{2} &amp; a_{1} &amp; 0\end{bmatrix}b\overset{\mathrm{def}}{=}a^{\wedge} b$$</p><ul id="refplus" style="display:none;"><li id="ref-ji" data-num="1">[1]   基就是张成这个空间的一组线性无关的向量，有些其他的说法叫 “基底”</li></ul><br>外积的结果是一个向量，方向垂直于这两个向量，大小是$|a||b|\sin \left \langle a,b \right \rangle $，是两个向量张成的四边形的有向面积。<p></p><p>外积运算我们用<code>^</code>符号来表示，把<code>a</code>写成一个矩阵，这就是<strong>反对称矩阵</strong>。反对称矩阵满足$A^{T} = -A$这样就把外积$a\times b$写成了矩阵与向量的乘法<code>a^b</code>，变成了线性运算。此符号是一个一一映射，也就是说，任意向量都有唯一一个反对称矩阵，反之亦然。<br>$$<br>a^{\wedge} =<br>\begin{bmatrix}<br> 0 &amp; -a_{3} &amp; a_{2}\\<br> a_{3} &amp; 0 &amp; -a_{1}\\<br> -a_{2} &amp; a_{1} &amp; 0<br>\end{bmatrix}<br>$$</p><h2 id="2、坐标系间欧式变换"><a href="#2、坐标系间欧式变换" class="headerlink" title="2、坐标系间欧式变换"></a>2、坐标系间欧式变换</h2><p>在机器人学中，会给每一个连杆和关节定义他们的坐标系。如果考虑移动的机器人，常见的方法是设定一个世界坐标系，我们可以认为，他是不会移动的，如下图中的$x_{w},y_{w},z_{w}$定义的坐标系。同时，机器人是一个移动的坐标系，如$x_{c},y_{c},z_{c}$定义的坐标系。</p><p><img src="https://s2.loli.net/2022/08/01/M8Ij2t7wUnZ6akO.png" alt="对于同一个向量p，在世界坐标下的坐标pw，和相机坐标系下的坐标pc是不一样的。这个变换由变换矩阵T描述"></p><p>两个坐标系之间的运动由一个旋转加上一个平移组成，这种运动称之为<strong>刚体运动</strong>。相机在视界坐标系的运动就是一种刚体运动。刚体运动过程中，同一个向量在各个坐标系下的长度和夹角都不会改变。毕竟相机不会像棉花糖一样，会被压扁拉长，此时，我们说相机坐标系到世界坐标系之间，相差了一个<strong>欧式变换</strong>。</p><p>因为欧式变换由旋转和平移组成，我们先看一下旋转：</p><p>设某个单位正交基$(e_{1},e_{2},e_{3})$经过一次旋转变成$(e^{\backprime}_{1},e^{\backprime}_{2},e^{\backprime}_{3})$，那对同一个向量a（因为只讨论旋转，他也没运动），他在两个坐标系下的坐标是$[a_{1},a_{2},a_{3}]^{T}$和$[a^{\backprime}_{1},a^{\backprime}_{2},a^{\backprime}_{3}]^{T}$。因为向量本身没变，就有下列式子：</p><p><img src="https://s2.loli.net/2022/08/01/RqwLs7rZpQafhI6.png"></p><p>为了描述两个坐标之间的关系，对上面等式的左右两边同时左乘$\begin{bmatrix}<br>e_{1}^{T} \\<br>e_{2}^{T} \\<br>e_{3}^{T}<br>\end{bmatrix}$，那左边的系数就变成单位矩阵：<br>$$<br>\begin{bmatrix}<br>a_{1} \\<br>a_{2} \\<br>a_{3}<br>\end{bmatrix}=\begin{bmatrix}<br> e_{1}^{T}e_{1}^{\backprime} &amp; e_{1}^{T}e_{2}^{\backprime} &amp; e_{1}^{T}e_{3}^{\backprime}\\<br> e_{2}^{T}e_{1}^{\backprime} &amp; e_{2}^{T}e_{2}^{\backprime} &amp; e_{2}^{T}e_{3}^{\backprime}\\<br> e_{3}^{T}e_{1}^{\backprime} &amp; e_{3}^{T}e_{2}^{\backprime} &amp; e_{3}^{T}e_{3}^{\backprime}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_{1}^{\backprime} \\<br>a_{2}^{\backprime} \\<br>a_{3}^{\backprime}<br>\end{bmatrix}<br>\overset{\mathrm{def}}{=}Ra^{\backprime}<br>$$<br>中间3x3的矩阵拿出来，给他起名叫做<strong>R</strong>，这个矩阵有两组基之间的内积组成，说明了前后同一个向量的坐标变换关系。只要这个旋转操作一样，这个矩阵就是一样的，矩阵R描述了旋转本身，使用给他起个名字，叫<strong>旋转矩阵</strong>。</p><blockquote><p>补充: 这个旋转矩阵，各分量是两个坐标系基的内积，因为基长度为1，所以实际上是各个积向量夹角的余弦值。所以这个矩阵也叫<strong>方向余弦矩阵</strong>。本篇还是将其称作<strong>旋转矩阵</strong>。</p></blockquote><p>事实上，旋转矩阵是一个行列式为1的正交矩阵，那行列式为1的正交矩阵就是一个旋转矩阵。所以把n维旋转矩阵的集合定义如下：<br>$$<br>SO(n)=\left \{ R \in \mathbb R ^{n \times n} | RR^{T}=I,det(R)=1\right \}<br>$$</p><blockquote><p>SO(n)是特殊正交群：</p><blockquote><p>群是一种集合加上一种运算的代数结构，如果集合为A，运算为+，那么可以记为群G=（A , +）。群要求这个运算要满足以下几个条件：</p><p>封闭性：$\forall a,b \in A,a1 \cdot a2 \in A $</p><p>结合律：$\forall a,b,c \in A,(a1 \cdot a2)\cdot a3=a1 \cdot (a2 \cdot a3)$</p><p>幺元：$\exists a0 \in A,s.t. \forall a\in A,a_{0}\cdot a=a\cdot a_{0}=a$</p><p>逆：$\forall a \in A,\exists a^{-1} \in A, s.t.: a\cdot a^{-1}=a_{0}$</p><p>可以巧记为：封结幺逆（凤姐要你）</p><blockquote><p>实在不好理解的话，可以把群类比成一个魔方，魔方的旋转就是运算，得到的运算结果（集合中的元素们）就是旋转魔方后，魔方上面整体的颜色分布。</p><p>魔方一共就那些颜色排列组合，把所有魔方颜色分布的排列组合集合起来，就是整个集合，在满足 “旋转” 这个运算的前提下，这些集合就构成群（因为如果你选择把魔方拆开这个运算，那得到的一定是散成一片的方块，该状态就不在上述魔方例子的集合内）</p></blockquote><p>易得，旋转矩阵集合和矩阵乘法构成群，后面要介绍的变换矩阵<code>SE(n)</code>和矩阵乘法也构成群。正因为如此，才能称他们为旋转矩阵群和变换矩阵群。</p><p><strong>李群</strong>是指具有连续（光滑）性质的群。</p><ul><li><p>像整数群$\left \langle \mathbb Z,+ \right \rangle $就是离散的，并不是李群。</p></li><li><p>像SO(n)，SE(n)，在实数空间上是连续的，我们可以稍微想象一下，一个刚体在空间中连续的旋转，所以这种算是李群。</p></li></ul><p>关于李群李代数，在本篇中就不展开介绍了，后续再详细介绍。</p></blockquote><p>根据上面的补充资料，我们可以知道，SO(n)是由n维空间的旋转矩阵组成，所以说，SO(3)就是特指三维空间了。通过这个旋转矩阵，我们可以直接讨论两个坐标系之间的旋转变换了。</p></blockquote><p>因为旋转矩阵是正交矩阵，那他的逆就描述了一个相反的旋转。<br>$$<br>a^{\backprime}=R^{-1}a=R^{T}a<br>$$<br>在欧式变换中，除了刚刚咱讨论的旋转，还有平移。把旋转和平移合在一起，就可以用公式：<br>$$<br>a^{\backprime}=Ra+t<br>$$<br>t自然就是指平移向量了。相比前面旋转的部分，平移只需要直接把平移向量加上去就好了，看上去非常简单。在实际应用中，我们会定义坐标系1，坐标系2，那么向量a在两个坐标系下的坐标a1，a2的关系如下：<br>$$<br>a_{1}=R_{12}a_{2}+t_{12}<br>$$<br>这里<code>R12</code>是指<strong>把坐标系2的向量变换到坐标系1</strong>，因为向量乘在这个矩阵的右边，下标要从右往左读的。</p><p>对于平移<code>t12</code>，虽然确实是<strong>指从1到2的向量</strong>，但要注意，反过来的<code>t21</code>并不等于<code>-t12</code>，<strong>这两个向量的坐标值并不是相反数。</strong></p><h2 id="3、变换矩阵与齐次坐标"><a href="#3、变换矩阵与齐次坐标" class="headerlink" title="3、变换矩阵与齐次坐标"></a>3、变换矩阵与齐次坐标</h2><p>就上面我们讨论过的式子来说，虽然可以完美表达欧式空间的旋转与平移，不过还有一个问题：<strong>这里的变换并不是一个线性关系</strong></p><p>假设我们进行2次变换：<code>R1、t1</code>与<code>R2、t2</code><br>$$<br>b=R_{1}a+t_{1},c=R_{2}b+t_{2}<br>$$<br>那，从a到c的变换就是：<br>$$<br>c=R_{2}(R_{1}a+t)+t_{2}<br>$$<br>这样的形式面对实际应用中多次的变换，会显得很繁琐。所以引入了齐次坐标和变换矩阵，重写的式子如下:<br>$$<br>\begin{bmatrix}<br> a^{\backprime}\\<br> 1<br>\end{bmatrix}=<br>\begin{bmatrix}<br> R &amp; t\\<br> 0^{T} &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br> a\\<br> 1<br>\end{bmatrix}<br>\overset{\mathrm{def}}{=}<br>T\begin{bmatrix}<br> a\\<br> 1<br>\end{bmatrix}<br>$$<br>我们在三维向量的末尾添加1，让他变成四维向量，称之为<strong>齐次坐标</strong>。对于这个四维向量，我们可以把旋转和平移写在一个矩阵里，<strong>使得整个关系变成线性关系</strong>。我们把式子末尾大写T称之为<strong>变换矩阵</strong>。</p><p>如果我们暂时使用$\overset{\sim }{a}$表示为a的齐次坐标，那对于该标题头两次变换的例子来说，可以写成如下式子：<br>$$<br>\overset{\sim }{b}=T_{1}\overset{\sim }{a},\overset{\sim }{c}=T_{2}\overset{\sim }{b} \rightarrow \overset{\sim }{c}=T_{2}T_{1}\overset{\sim }{a}<br>$$<br>在不引起歧义的前提下，我们可以适(tou)当(lan)简写成$b=Ta$的样子，默认里面已经进行了其次坐标变换</p><blockquote><p>需要注意的是，不进行齐次坐标变换的时候，这边的乘法在矩阵维度上是不成立的</p></blockquote><p>这个变换矩阵T很有意思：左上角是旋转矩阵，右上角是平移向量，左下角是0向量，右下角是1。这种矩阵又称为<strong>特殊欧氏群</strong><br>$$<br>SE(3)=\left \{ T=<br>\begin{bmatrix}<br> R &amp; t\\<br> 0^{T} &amp; 1<br>\end{bmatrix}<br>\in \mathbb R^{4 \times 4} |<br>R\in SO(3),t\in \mathbb R^{3}<br>\right \}<br>$$<br>和那个SO(3)，一样，该矩阵的逆就表示一个反向的变换：<br>$$<br>T^{-1}=<br>\begin{bmatrix}<br> R^{T} &amp; -R^{T}t\\<br> 0^{T} &amp; 1<br>\end{bmatrix}<br>$$<br>我们也用$T_{12}$的写法来表示从2到1的变换。</p><h2 id="4、旋转向量"><a href="#4、旋转向量" class="headerlink" title="4、旋转向量"></a>4、旋转向量</h2><p>有了旋转向量来描述旋转，有了变换矩阵描述一个6自由度的三维刚体运动，但是聪明的你一定注意到了，上面这种矩阵的方式至少有这两个缺点：</p><ul><li>SO(3)的旋转矩阵有9个量，但一次旋转就只有三个自由度，这种表达方式有点冗余</li><li>旋转矩阵必须是正交矩阵，且行列式为1！变换矩阵也是这样。如果想估计或者优化一个旋转矩阵、变换矩阵的时候，这些约束对于邱洁问题来说会变得更加困难。</li></ul><p>所以，我们希望有一种方式可以紧凑地描述旋转平移，比如就用一个六维的向量来表示变换，有没有这样一种方式呢？</p><p>事实上，任意旋转都可以用一个旋转轴和一个旋转角来描述。咱用一个向量，方向和旋转轴一致，长度等同于旋转角，这种向量我们叫它<strong>旋转向量</strong></p><p>同样的，对于变换矩阵来说，我们用一个旋转向量加平移向量就可以表达一次变换了，这时的变换维度正好是六维。</p><p>设旋转轴为一个单位长度的向量n，角度θ，那向量θn也可以描述这个旋转，那旋转矩阵和旋转向量之间有一个什么联系呢？</p><p>从旋转向量到旋转矩阵只需要用<strong>罗德里格斯公式</strong>就可以了。</p><blockquote><p>罗德里格斯公式的推导如下：</p><img src="https://s2.loli.net/2022/08/01/w8jG4mheA6TKSVn.png" style="zoom:50%;"><p>假设v在三维空间中，绕单位旋转轴 k（<strong>我们后面用f表示这个轴</strong>），旋转θ。<br>从上图可以看出，对于向量v可以分出两个分向量： v平行和v垂直</p><img src="https://s2.loli.net/2022/08/01/PyNTz3VXjLc5uJ2.png" alt="ros-9-6.png" style="zoom:67%;"><p>从上图可看到，v 向量旋转了 θ 角到 v’ 向量，我们要求的是这个旋转后的 v‘ 向量，这个可以用f，v，theta表示出来</p><ul><li><p>其中需要说明的是，f的完整形式应该是$[f_x,f_y,f_z]^T$。如果算上一个绕着的θ，这样就有四个变量（自由度）了。</p><p>但是像欧拉角，其实就三个变量（自由度）。 为了消除旋转轴 f 模长这个多余的自由度 ， 我们可以规定旋转轴 f 的模长为<br>$$<br>\parallel f  \parallel =\sqrt{f_x^2+f_y^2+f_z^2}=1<br>$$<br>因为限定了模长已知，这样就可以知道其中两个变量 f 去求第三个变量了。 也可以说 f 是一个单位向量。，后面推导更方便</p></li><li><p>我们把v向量正交分解开来，就有一个v平行和一个v垂直向量。v平行就是在f上的投影向量。</p></li></ul><p><img src="https://s2.loli.net/2022/08/01/gU8KwtjV76NJYdI.png"></p><p>这个v平行可以写成如下形式：<br>$$<br>v_{||} =\frac{f \cdot v}{f \cdot f}f=\frac{f\cdot v}{\parallel f \parallel ^{2}}f=(f\cdot v)f<br>$$<br>其中，分子是f和v的点积相乘，分母就是f的模长，然后后面乘一个f，相当于乘了向量的方向。因为模长是1，所以最后可以化简为：f点积v乘一个f</p><p>因为根据向量的运算，$v=v_{||}+v_{\bot }$，所以$v_{\bot }=v-v{||}$。展开可得：<br>$$<br>v{\bot}=v-(f\cdot v)f<br>$$<br>绕着v平行旋转的话，因为v平行和f轴平行，所以旋转后和旋转前都一样。<code>v平行’ = v平行</code>。</p><p>v⊥正交于f 的 ，这个旋转可以看做是平面内的旋转。因为旋转不改变 v ⊥ 的长度，所以路径是一个圆。 下面是这个旋转的示意图，右侧的为俯视图。 </p><p><img src="https://s2.loli.net/2022/08/01/CWiJGLAYequSZhr.png"></p><p>由于在这个平面上我们只有一个向量 v ⊥ ，用它来表示一个旋转是不够的，我们还需要构造一个同时正交于 u和 v 的向量 w，这个可以通过叉乘来获得：$w=f \times v\bot$<br>$$<br>\parallel w \parallel = \parallel f\times v_{\bot} \parallel<br>=\parallel f \parallel \times \parallel v_{\bot} \parallel \times sin\frac{\pi }{2}=\parallel v_{\bot} \parallel<br>$$<br>因为夹角是f和v⊥的夹角，因为这俩是正交的，显然角度是$\frac{\pi }{2}$。</p><p>也就是说，w 和 v⊥ 的模长是相同的，所以，w 也位于圆上。<br>有了这个新的向量 w，就相当于我们在平面内有了两个坐标轴。</p><p>我们现在可以把 v ′ ⊥ 投影到 w  和 v ⊥ 上，将其分解为$v_{v}^{\backprime}$和$v_{w}^{\backprime}$。那就是$v_{\bot}^{\backprime}=v_{v}^{\backprime}+v_{w}^{\backprime}$。使用一点三角的知识我们就能得到：<br>$$<br>v_{\bot}^{\backprime}=\cos{\theta}\cdot v_{\bot}+\sin{\theta}\cdot w=\cos{\theta}\cdot v_{\bot}+\sin{\theta}\cdot(f\times v\bot)<br>$$<br>将上面两个结果加起来，就是：<br>$$<br>v^{\backprime}=v_{\parallel}^{\backprime}+v_{\bot}^{\backprime}=v_{\parallel}^{\backprime}+\cos{\theta}\cdot v_{\bot}+\sin{\theta}\cdot(f\times v\bot)<br>$$<br>因为我们前面说过：<br>$$<br>v_{\parallel}=(f\cdot v)f,v{\bot}=v-(f\cdot v)f<br>$$<br>然后 f 轴又和 v平行 平行，叉乘得0，可得：<br>$$<br>f\times v_{\bot}=f\times (v-v_{\parallel})=f\times v+f\times v_{\parallel}=f\times v-0<br>$$<br>最终可得：<br>$$<br>v^{\backprime}=(f\cdot v)f+\cos{\theta}(v-(f\cdot v)\cdot f)+\sin{\theta}(f\times v)<br>$$<br>化简一下：<br>$$<br>v^{\backprime}=\cos{\theta}v+(1-\cos{\theta})(f\cdot v)\cdot f+\sin{\theta}(f\times v)<br>$$<br>至此，公式推导完毕</p></blockquote><p>但扯皮这么长的公式，我们得代数进来。需要参考前面讲过的公式了。</p><blockquote><p>$$<br>Rv=\cos{\theta}v+(1-\cos{\theta})(f\cdot v)\cdot f+\sin{\theta}(f^{\wedge}v)<br>$$</p><p>因为 (<strong>v</strong>·<strong>f</strong>)·<strong>f</strong> = <strong>f</strong>·(<strong>v</strong>·<strong>f</strong>) ， 然后由于<strong>v</strong>·<strong>f</strong> = <strong>fT</strong>·<strong>v</strong> ，所以原式转化为<strong>f</strong>·<strong>fT</strong>·<strong>v</strong> </p><p>所以可得：<br>$$<br>Rv=\cos{\theta}v+(1-\cos{\theta})(f^{T}f)v+\sin{\theta}(f^{\wedge}v)<br>$$<br>化简可得：<br>$$<br>R=\cos{\theta}I+(1-\cos{\theta})(f^{T}f)+\sin{\theta}(f^{\wedge})<br>$$</p></blockquote><p>对于转角theta，取两边的迹：<br>$$<br>tr\left (R\right )=\cos{\theta}tr(I)+(1-\cos{\theta})tr(f^{T}f)+\sin{\theta}tr(f^{\wedge})=3\cos\theta+(1-\cos\theta)=1+2\cos\theta<br>$$<br>因此：<br>$$<br>\theta=\arccos\frac{tr\left(R\right)-1}{2}<br>$$<br>关于转换公式，还可以自行了解李代数，可以发现它们和SO(3)上李群与李代数之间的对应关系。</p><h2 id="5、欧拉角"><a href="#5、欧拉角" class="headerlink" title="5、欧拉角"></a>5、欧拉角</h2><p>欧拉角就不太展开介绍了，就是<strong>三个分离的转角</strong>，把一个旋转分解成3次让不同轴的旋转。长相如下。</p><p><img src="https://s2.loli.net/2022/08/01/UXYwR7djrvLHcAZ.png" alt="欧拉角与万向锁"></p><p>上图介绍的是欧拉角的一个重大的缺点：<strong>万向锁问题</strong>。万向锁问题会导致第三次旋转和第一次旋转的效果相同。</p><p>如果上图不好理解的话，可以参考这个动图。可以看到，蓝色轴和绿色轴叠在一起的时候，不管移动绿轴还是蓝轴，都只是在同个方向上转动，直接丢失了一个自由度，形成万向锁。</p><p><img src="https://s2.loli.net/2022/08/01/vkQgsZHxDS2oWuc.gif"></p><p>由于这种<strong>奇异性问题</strong><sup class="refplus-num"><a href="#ref-q">[1]</a></sup>，欧拉角不适用于插值、迭代，往往只适合用于人机交互，这里需要引出我们真正需要使用的：</p><ul id="refplus" style="display:none;"><li id="ref-q" data-num="1">[1]   旋转向量也有奇异性，发生在转角超过2π的时候</li></ul><p></p><h2 id="6、四元数"><a href="#6、四元数" class="headerlink" title="6、四元数"></a>6、四元数</h2><p>旋转矩阵用9个量描述3个自由度的旋转，具有冗余性；</p><p>欧拉角和旋转向量是紧凑的，但具有奇异性。</p><p>事实上，我们是找不到不带奇异性的三维向量描述方式的。</p><p>希望既能保持紧凑性，又能没有奇异性，就需要使用四元数。</p><p>四元数可以类比复数，例如说，我们想将复平面的向量旋转90度，可以给这个复向量乘以$e^{i\theta}$。当他转化为普通形式就是$e^{i\theta}=\cos\theta+i\sin\theta$。</p><p>所以在二维中，旋转可以用单位复数描述。类似，在三维中，我们就使用四元数来描述:<br>$$<br>q = q_{0}+q_{1}i+q_{2}j+q_{3}k<br>$$<br>其中，i、j、k是四元数的三个虚部，满足以下关系：<br>$$<br>\left\{\begin{matrix}<br>i^{2}=j^{2}=k^{2}=-1 \\<br>ij=k;ji=-k \\<br>jk=i;kj=-i \\<br>ki=j;ik=-j<br>\end{matrix}\right.<br>$$<br>如果把ijk看成三个坐标轴，那他们与自己的乘法和复数的乘法一样，相互之间的乘法和外积一样。有时人们也用一个标量和一个向量来表示四元数：<br>$$<br>q=[s,v]^{T},s=q_{0}\in\mathbb R,v=[q_1,q_2,q_3]^{T}\in\mathbb R^3<br>$$<br>s是四元数的实部，v是四元数的虚部。如果一个四元数的虚部为0，则称为<strong>实四元数</strong>；如果实部为0，就是<strong>虚四元数</strong>。</p><h3 id="6-1-四元数运算"><a href="#6-1-四元数运算" class="headerlink" title="6.1 四元数运算"></a>6.1 四元数运算</h3><p>四元数和通常的复数一样，可以进行各种运算。比如四则运算、共轭、求逆、数乘等等。</p><p>设两个四元数$q_a,q_b$，向量$[s_a,v_a],[s_b,v_b]$，或者$q_a=s_a+x_{a}i+y_{a}j+z{a}k$，$q_b=s_b+x_{b}i+y_{b}j+z{b}k$。</p><h4 id="6-1-1加减法"><a href="#6-1-1加减法" class="headerlink" title="6.1.1加减法"></a>6.1.1加减法</h4><p>$$<br>q_a\pm q_b=[s_a\pm s_b,v_a\pm v_b]<br>$$</p><h4 id="6-1-2-乘法"><a href="#6-1-2-乘法" class="headerlink" title="6.1.2 乘法"></a>6.1.2 乘法</h4><p>把qa的每一项和qb的每一项相乘，最后相加。虚部要按照i、j、k三个虚部的运算关系进行：<br>$$<br>q_{a}q_{b}=s_as_b-x_ax_b-y_ay_b-z_az_b\\<br>+(s_ax_b+x_as_b+y_az_b-z_ay_b)i\\<br>+(s_ay_b-x_az_b+y_as_b+z_ax_b)j\\<br>+(s_az_b+x_ay_b-y_ax_b+z_as_b)k<br>$$</p><p>如果写成向量形式并利用内外积运算，会有更加简洁的表达式：<br>$$<br>q_aq_b=[s_as_b-v_a^Tv_b,s_av_b+s_bv_a+v_a\times v_b]^{T}<br>$$</p><p>在这种乘法定义下，俩实四元数乘积和复数一样，仍然是实的。But，由于最后一项外积的存在，四元数乘法通常是不可以交换的，除非$v_a,v_b$在$\mathbb R^3$中共线，外积项变成0，就可以进行乘法交换。</p><h4 id="6-1-3-模长"><a href="#6-1-3-模长" class="headerlink" title="6.1.3 模长"></a>6.1.3 模长</h4><p>两个四元数的模就是模的乘积。（所以单位四元数相乘之后仍然是四元数）<br>$$<br>\parallel q_a \parallel =\sqrt{s_a^2+x_a^2+y_a^2+z_a^2}\\<br>\parallel q_aq_b \parallel = \parallel q_a \parallel \parallel q_b \parallel<br>$$</p><h4 id="6-1-4-共轭"><a href="#6-1-4-共轭" class="headerlink" title="6.1.4 共轭"></a>6.1.4 共轭</h4><p>四元数共轭和本身相乘，会得到一个实四元数，其<strong>实部为模长的平方</strong>。<br>$$<br>q_a^{*}=s_a-x_{a}i-y_{a}j-z_{a}k=[s_a,-v_a]^T\\<br>q^{*}q=qq^{*}=[s_a^2+v^Tv,0]^T<br>$$</p><h4 id="6-1-5-逆"><a href="#6-1-5-逆" class="headerlink" title="6.1.5 逆"></a>6.1.5 逆</h4><p>一个四元数的逆是：<br>$$<br>q^{-1}=q^*/\parallel q \parallel^2<br>$$</p><p>按照这个定义，四元数和自己的逆的乘积为实四元数1：<br>$$<br>qq^{-1}=q^{-1}q=1<br>$$<br>若q是单位四元数，它的逆和共轭就是同一个量。同时，乘积的逆具有和矩阵相似的性质：<br>$$<br>(q_aq_b)^{-1}=q_b^{-1}q_a^{-1}<br>$$</p><h4 id="6-1-6-数乘"><a href="#6-1-6-数乘" class="headerlink" title="6.1.6 数乘"></a>6.1.6 数乘</h4><p>和向量类似，四元数可以与数相乘<br>$$<br>kq=[ks,kv]^T<br>$$</p><h3 id="6-2-四元数表示旋转"><a href="#6-2-四元数表示旋转" class="headerlink" title="6.2 四元数表示旋转"></a>6.2 四元数表示旋转</h3><p>我们可以使用四元数表达对一个点的旋转。</p><p>假设说，有一个点$p=\left [ x,y,z \right ]\in\mathbb R^3$，以及一个由单位四元数q指定的旋转。三维点p经过旋转之后变成p‘，用矩阵的方式描述的话，就是<code>p’=Rp</code>。</p><p>用四元数的方式描述，就是：<br>$$<br>p=[0,x,y,z]^T=[0,v]^T<br>$$</p><p>相当于把四元数的三个虚部和空间中的3个轴对应。旋转后点p’可以这样表示乘积：<br>$$<br>p^{‘}=qpq^{-1}<br>$$<br>这里的乘法就是四元数乘法，得到的结果也将是四元数。计算结果的实部为0，所以是纯虚四元数。</p><h3 id="6-3-四元数到其他旋转表示的转换"><a href="#6-3-四元数到其他旋转表示的转换" class="headerlink" title="6.3 四元数到其他旋转表示的转换"></a>6.3 四元数到其他旋转表示的转换</h3><p>设$q=\left [ s,v \right ]^T $，以下来讨论四元数与旋转向量、旋转矩阵的关系。首先，定义如下的符号：<br>$$<br>q^+=<br>\begin{bmatrix}<br> s &amp; -v^T\\<br> v &amp; sI+v^{\wedge }<br>\end{bmatrix},<br>q^{\oplus}=<br>\begin{bmatrix}<br> s &amp; -v^T\\<br> v &amp; sI-v^{\wedge }<br>\end{bmatrix}<br>$$</p><p>这两个符号把四元数映射成一个4x4的矩阵。</p><p>$$<br>q_1^+q_2=<br>\begin{bmatrix}<br> s &amp; -v^T\\<br> v &amp; sI+v^{\wedge }<br>\end{bmatrix}<br>\begin{bmatrix}<br> s_2\\<br> v_2<br>\end{bmatrix}=<br>\begin{bmatrix}<br> -v_1^Tv_2 + s_1s_2\\<br> s_1v_2+s_2v_1+v_1^{\wedge}v_2<br>\end{bmatrix}=<br>q_1q_2<br>$$</p><p>同理，我们可以证得：</p><p>$$<br>q_1q_2=q_1^+q_2=q_2^{\oplus}q_1<br>$$</p><p>我们考虑到用四元数对空间点进行旋转的问题。参考前面的说法，我们代入上面式子可得：</p><p>$$<br>p^{‘}=qpq^{-1}\\<br>=q^+p^+q^{-1}\\<br>=q^+q^{-1}p<br>$$</p><p>然后代入两个符号对应的矩阵：</p><p>$$<br>q^+(q^{-1})^{\oplus}=<br>\begin{bmatrix}<br> s &amp; -v^T\\<br> v &amp; sI+v^{\wedge }<br>\end{bmatrix}<br>\begin{bmatrix}<br> s &amp; v^T\\<br> -v &amp; sI+v^{\wedge }<br>\end{bmatrix}=<br>\begin{bmatrix}<br> 1 &amp; 0\\<br> 0 &amp; vv^T+s^2I+2sv^{\wedge}+(v^{\wedge})^2<br>\end{bmatrix}(*)<br>$$</p><p>因为 p’ 和 p 都是虚四元数，所以事实上，该矩阵右下角就是给出了<strong>从四元数到旋转矩阵的变换关系</strong></p><p>$$<br>R=vv^T+s^2I+2sv^{\wedge}+(v^{\wedge})^2<br>$$</p><p>然后我们不是还有旋转向量嘛</p><p>为了得到四元数到旋转向量的转换公式，我们对式子左右两边求迹：<br>$$<br>tr\left (R\right)=tr(vv^T)+3s^2+2s\cdot 0+tr((v^{\wedge})^2)\\<br>=v_1^2+v_2^2+v_3^2+3s^2-2(v_1^2+v_2^2+v_3^2)\\<br>=(1-s^2)+3s^2-2(1-s^2)\\<br>=4s^2-1<br>$$<br>因为我们前面计算旋转向量的时候，得到过一个式子，把它代进去：<br>$$<br>\theta = \arccos(\frac{tr \left (R \right )-1}{2})=\arccos(2s^2-1)<br>$$<br>可得：<br>$$<br>\cos\theta=2s^2-1=2\cos^2\frac{\theta}{2}-1<br>$$<br>所以：<br>$$<br>\theta = 2\arccos s<br>$$<br>关于旋转轴，在上面式子<code>(*)</code>中，用q的虚部代替p，就可以知道，q的虚部组成的向量在旋转时是不动的，就构成了旋转轴，所以只要除掉他的模长就可以得出。</p><p>所以，四元数到旋转向量的转换总结如下：<br>$$<br>\left\{\begin{matrix}<br>\theta = 2\arccos q_0 \\<br>\left [ n_x,n_y,n_z \right ]^T=\frac{\left [ q_1,q_2,q_3 \right ]^T}{\sin\frac{\theta}{2}}<br>\end{matrix}\right.<br>$$</p><h3 id="6-4-相似、仿射、射影变换"><a href="#6-4-相似、仿射、射影变换" class="headerlink" title="6.4 相似、仿射、射影变换"></a>6.4 相似、仿射、射影变换</h3><p>处理欧式变换之外，三维空间中还有很多种变换方式</p><p>只是欧式变换最简单，他保持了向量的长度与夹角，相当于说，我们把一个刚体原封不动地进行移动旋转。</p><p>其他的变换方式则是会改变其外形。</p><p>他们都拥有类似的矩阵表示。</p><h4 id="1、相似变换"><a href="#1、相似变换" class="headerlink" title="1、相似变换"></a>1、相似变换</h4><p>比欧式变换多了一个自由度，允许物体进行均匀缩放：<br>$$<br>T_s=<br>\begin{bmatrix}<br> sR &amp; t\\<br> 0^T &amp; 1<br>\end{bmatrix}<br>$$<br>不难看出，旋转部分多了一个缩放因子s，表示对其向量旋转之后，可以在x，y，z坐标上进行均匀缩放。</p><p>可以想象一下，一个边长为1的正方体缩放成边长为10的正方体，差不多是这么个效果。</p><p>三维相似变换的集合也叫做<strong>相似变换群</strong>，记做Sim(3)。</p><h4 id="2、仿射变换"><a href="#2、仿射变换" class="headerlink" title="2、仿射变换"></a>2、仿射变换</h4><p>$$<br>T_a=<br>\begin{bmatrix}<br> A &amp; t\\<br> 0^T &amp; 1<br>\end{bmatrix}<br>$$</p><p>和欧式变换的区别是：方式变换只要求A是一个可逆矩阵，而没必要是正交矩阵。</p><p>仿射变换，也叫做正交投影</p><p>一个立方体，经过仿射变换之后，立方体就不再是正方的了，但各个面仍然是平行四边形。</p><h4 id="3、射影变换"><a href="#3、射影变换" class="headerlink" title="3、射影变换"></a>3、射影变换</h4><p>$$<br>T_p=<br>\begin{bmatrix}<br> A &amp; t\\<br> a^T &amp; v<br>\end{bmatrix}<br>$$</p><p>左下角元素为缩放。由于用了齐次坐标，v≠0时，我们可以对整个矩阵除以v得到一个右下角为1的矩阵，否则右下角为0。</p><p>2维的射影变换有8个自由度，3维的有15个自由度。</p><p>射影变换是现在讲的过程中，形式最一般的。</p><p>可以类比为：从真实世界到相机照片的变换。</p><p>可以想象一下，在相机中拍的正方形可能都不会是正方形了，由于视角以及近大远小，你有时可以拍出不规则的四边形。</p><table><thead><tr><th>变换名称</th><th>自由度</th><th>不变的性质</th></tr></thead><tbody><tr><td>欧式变换</td><td>6</td><td>长度、夹角、体积</td></tr><tr><td>相似变换</td><td>7</td><td>体积比</td></tr><tr><td>仿射变换</td><td>12</td><td>平行性、体积比</td></tr><tr><td>射影变换</td><td>15</td><td>接触平面的相交与相切</td></tr></tbody></table>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 八、参数的使用</title>
      <link href="/2022/07/31/ros-8-rosparam/"/>
      <url>/2022/07/31/ros-8-rosparam/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS-8-参数的使用与编程"><a href="#ROS-8-参数的使用与编程" class="headerlink" title="ROS 8: 参数的使用与编程"></a>ROS 8: 参数的使用与编程</h1><p>在ROS Master中有一个<strong>参数服务器</strong>，它是一个<strong>全局字典</strong>，用来保存各个节点的配置参数的，这些参数是各个节点<strong>都可以全局访问的</strong>。</p><blockquote><p>可以简单理解为，这是一个用来存放<strong>全局变量</strong>的空间</p></blockquote><p>有关参数的使用，有如下命令行工具</p><h2 id="一、参数的命令行工具"><a href="#一、参数的命令行工具" class="headerlink" title="一、参数的命令行工具"></a>一、参数的命令行工具</h2><p>我们在命令行会使用<code>rosparam</code>，用于从ROS参数服务器获取、设置和删除参数。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosparam is a command-line tool for getting, setting, and deleting parameters from the ROS Parameter Server.Commands:        rosparam set    set parameter        rosparam get    get parameter        rosparam load   load parameters from file        rosparam dump   dump parameters to file        rosparam delete delete parameter        rosparam list   list parameter names<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果参数比较多的时候，我们会用<code>*.yaml</code>文件来存参数。</p><p>以下是rosparam在命令行的工具使用介绍</p><ul><li><p>列出参数<code>rosparam list</code></p><blockquote><ul><li>如果此时你运行turtlesim，你可以使用<code>rosparam list</code>看到参数名：</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/rosversion/run_id/turtlesim/background_b/turtlesim/background_g/turtlesim/background_r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>如果你设置了命名空间，还需要在后面加上命名空间的名字，如：<code>rosparam list /namespace</code></p><p>这里的命名空间可以类比为c++中的<code>using namespace xxx</code>中的<code>xxx</code></p><p><strong>具体内容放在第三Part介绍</strong></p></li></ul></blockquote></li><li><p>显示某个参数值<code>rosparam get &lt;param_key&gt;</code></p></li><li><p>设置某个参数值<code>rosparam set &lt;param_key&gt; &lt;param_value&gt;</code></p><blockquote><p>比如要修改turtlesim的background对应的RGB值，输入：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosparam set /turtlesim/background_g 255<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后turtlesim需要收到一次<code>/clear</code>请求，才会重新读取背景值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosservice call /clear "{}"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果此时你正在运行上述代码，你就可以看到，海龟仿真器的背景颜色已经修改了。</p><p>-v：显示详细输出。</p><p>-t <text_file>, –textfile <text_file> ：将参数设置为文本文件的内容。</text_file></text_file></p><p>-b <binary_file>, –binfile <binary_file> ：将参数设置为二进制文件的内容。参数服务器将值存储为XML-RPC二进制类型（基64编码）。</binary_file></binary_file></p></blockquote></li><li><p>保存参数到文件<code>rosparam dump &lt;file_name&gt;</code></p></li><li><p>从文件读取参数<code>rosparam load &lt;file_name&gt;</code></p><blockquote><p>此时，在工作空间使用<code>rosparam dump param.yaml</code>指令，ros就会把当前的参数配置保存到该yaml文件中。</p><p>使用<code>rosparam load param.yaml</code>就可以加载以前保存好的参数</p><p>yaml文件会存储类似于以下的内容，</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">rosdistro: 'melodic  'roslaunch:  uris:    xxx: http://xxx:44429/rosversion: '1.14.10  'run_id: 80cf1b56-0e4b-11ed-9d12-000c29d50405turtlesim:  background_b: 255  background_g: 255  background_r: 255<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p>删除参数<code>rosparam delete &lt;param_key&gt;</code></p><blockquote><p>删除当前系统载入的参数。</p></blockquote></li></ul><h2 id="二、参数在编程上的使用"><a href="#二、参数在编程上的使用" class="headerlink" title="二、参数在编程上的使用"></a>二、参数在编程上的使用</h2><h3 id="c-代码实现"><a href="#c-代码实现" class="headerlink" title="c++代码实现"></a>c++代码实现</h3><h4 id="1、设置参数"><a href="#1、设置参数" class="headerlink" title="1、设置参数"></a>1、设置参数</h4><p><code>ros::NodeHandle::setParam() </code></p><p><code>ros::param::set()</code></p><p><strong>在c++中</strong>，在代码中获取参数时，除了上述代码使用的<code>ros::param::get</code>方法之外，还可以使用句柄来获取参数：<code>ros::NodeHandle::getParam() </code>。需要的参数是一样的：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">//ros::NodeHandle::setParam()ros::NodeHandle nh;nh.setParam("/global_param", 5);nh.setParam("relative_param", "my_string");nh.setParam("bool_param", false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都是需要输入参数名和存放的变量名</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">//ros::param::set()ros::param::set("/global_param", 5);ros::param::set("relative_param", "my_string");ros::param::set("bool_param", false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，如果使用NodeHandle，还需要注意他对应的命名空间。</p><p>对于命名空间来说，节点名前面直接加个<code>/</code>号，代表着这个节点是放在全局的，比如<code>/turltesim</code>。如果需要使用对应命名空间里的节点，需要写上空间名，如：<code>/my/turtlesim</code></p><h4 id="2、检查参数是否存在"><a href="#2、检查参数是否存在" class="headerlink" title="2、检查参数是否存在"></a>2、检查参数是否存在</h4><ul><li><code>ros::NodeHandle::hasParam()</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::NodeHandle nh;if (nh.hasParam("my_param")){...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>ros::param::has()</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">if (ros::param::has("my_param")){...}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、删除参数"><a href="#3、删除参数" class="headerlink" title="3、删除参数"></a>3、删除参数</h4><ul><li><code>ros::NodeHandle::deleteParam()</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::NodeHandle nh;nh.deleteParam("my_param");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>ros::param::del()</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::param::del("my_param");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4、访问私有参数"><a href="#4、访问私有参数" class="headerlink" title="4、访问私有参数"></a>4、访问私有参数</h4><p>根据使用的是“句柄”接口还是“裸”接口，访问私有参数的方式是不一样的。在句柄接口中，您必须创建一个新的<code>ros::NodeHandle</code>以私有命名空间作为其命名空间:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::NodeHandle nh("~");std::string param;nh.getParam("private_name", param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在裸界面中，可以使用描述私有参数的相同符号来访问它们，例如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::string param;ros::param::get("~private_name", param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5、搜索参数键"><a href="#5、搜索参数键" class="headerlink" title="5、搜索参数键"></a>5、搜索参数键</h4><ul><li><code>ros::NodeHandle::searchParam()</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::string key;if (nh.searchParam("bar", key)){  std::string val;  nh.getParam(key, val);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>ros::param::search()</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::string key;if (ros::param::search("bar", key)){  std::string val;  ros::param::get(key, val);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6、demo"><a href="#6、demo" class="headerlink" title="6、demo"></a>6、demo</h4><p>模仿本案例开头的修改turtlesim背景案例，我们所需要的头文件有：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include &lt;string&gt;#include &lt;std_srvs/Empty.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>主函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc,char **argv){    // 初始化ros    ros::init(argc,argv,"param_code");    ros::NodeHandle param_node;    int red,green,blue;    //参数获取，类比命令行rosparam的get    ros::param::get("/turtlesim/background_r",red);    ros::param::get("/turtlesim/background_g",green);    ros::param::get("/turtlesim/background_b",blue);    ROS_INFO("Get Backgroud Color[%d, %d, %d]", red, green, blue);    //参数设置，类比命令行rosparam的set    ros::param::set("/turtlesim/background_r",255);    ros::param::set("/turtlesim/background_g",255);    ros::param::set("/turtlesim/background_b",255);    ROS_INFO("Set Backgroud Color[255, 255, 255]");    //参数获取，类比命令行rosparam的get    ros::param::get("/turtlesim/background_r",red);    ros::param::get("/turtlesim/background_g",green);    ros::param::get("/turtlesim/background_b",blue);    ROS_INFO("Get Backgroud Color[%d, %d, %d]", red, green, blue);    // 参考我们上面讨论的参数使用方法，我们知道turtlesim需要接受/clear请求才会更新turtlesim的参数。    //调用/clear服务，用来刷新背景颜色    ros::service::waitForService("/clear");    ros::ServiceClient clear_background = param_node.serviceClient&lt;std_srvs::Empty&gt;("/clear");    std_srvs::Empty srv;    clear_background.call(srv);    sleep(1);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序编译：</p><p>打开功能包的CMakeLists，使用如下语句即可使用catkin_make</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_executable(learn_param src/learn_param.cpp)target_link_libraries(learn_param ${catkin_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h3><h4 id="1、获取参数"><a href="#1、获取参数" class="headerlink" title="1、获取参数"></a>1、获取参数</h4><p> <code>rospy.get_param(参数名称) </code></p><p> 如果使用<code>get_param()</code>来获取名称空间，则会返回一个字典，其中的键等于该名称空间中的参数值。 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">global_name = rospy.get_param("/global_name")relative_name = rospy.get_param("relative_name")private_param = rospy.get_param('~private_name')default_param = rospy.get_param('default_param', 'default_value')# fetch a group (dictionary) of parametersgains = rospy.get_param('gains')p, i, d = gains['p'], gains['i'], gains['d']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、设置参数"><a href="#2、设置参数" class="headerlink" title="2、设置参数"></a>2、设置参数</h4><p><code>rospy.set_param(参数名称，参数值)</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 使用rospy和原始python对象rospy.set_param('a_string', 'baz')rospy.set_param('~private_int', 2)rospy.set_param('list_of_floats', [1., 2., 3., 4.])rospy.set_param('bool_True', True)rospy.set_param('gains', {'p': 1, 'i': 2, 'd': 3})# 使用rosparam和yaml字符串rosparam.set_param('a_string', 'baz')rosparam.set_param('~private_int', '2')rosparam.set_param('list_of_floats', "[1., 2., 3., 4.]")rosparam.set_param('bool_True', "true")rosparam.set_param('gains', "{'p': 1, 'i': 2, 'd': 3}")rospy.get_param('gains/p') #should return 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、参数存在"><a href="#3、参数存在" class="headerlink" title="3、参数存在"></a>3、参数存在</h4><p><code>rospy.has_param(param_name)</code></p><p>如果存在该参数，返回True，否则False。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if rospy.has_param('to_delete'):rospy.delete_param('to_delete')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4、删除参数"><a href="#4、删除参数" class="headerlink" title="4、删除参数"></a>4、删除参数</h4><p><code>rospy.delete_param(参数名称)</code></p><p>其实就是从参数服务器删除参数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:rospy.delete_param('to_delete')except KeyError:print("value not set")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5、搜索参数键-1"><a href="#5、搜索参数键-1" class="headerlink" title="5、搜索参数键"></a>5、搜索参数键</h4><p><code>rospy.search_param(参数名称)</code></p><p> 查找最接近的参数名，从私有名称空间开始，向上一直搜索到全局名称空间。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">param_name = rospy.search_param('global_example')v = rospy.get_param(param_name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果上面的代码出现在/foo/bar节点中， <code>rospy.search_param</code>会试着按照以下顺序找到参数</p><ol><li><code>/foo/bar/global _example</code></li><li><code>/foo/global _example</code></li><li><code>/global _example</code></li></ol></blockquote><h4 id="6、获取参数名"><a href="#6、获取参数名" class="headerlink" title="6、获取参数名"></a>6、获取参数名</h4><p><code>rospy.get_param_names()</code></p><h4 id="7、demo"><a href="#7、demo" class="headerlink" title="7、demo"></a>7、demo</h4><p>以下demo和c++的功能完全一样。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-import rospyfrom std_srvs.srv import Emptyimport sysdef param_set():    rospy.init_node('param_py')    # 读取背景颜色参数    red   = rospy.get_param('/background_r')    green = rospy.get_param('/background_g')    blue  = rospy.get_param('/background_b')    rospy.loginfo("Get Backgroud Color[%d, %d, %d]", red, green, blue)    # 设置背景颜色参数    ros.set_param('/background_r',100)    ros.set_param('/background_g',100)    ros.set_param('/background_b',100)    rospy.loginfo("Set Backgroud Color[100, 100, 100]")    # 读取背景颜色参数    red   = rospy.get_param('/background_r')    green = rospy.get_param('/background_g')    blue  = rospy.get_param('/background_b')    rospy.loginfo("Get Backgroud Color[%d, %d, %d]", red, green, blue)    rospy.wait_for_service('/clear')    try:        clear_background = rospy.ServiceProxy('/clear', Empty)        # 请求服务调用，输入请求数据        response = clear_background()        return response    except rospy.ServiceException, e:        print "Service call failed: %s"%eif __name__ == '__main__':    param_set()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 七、服务数据的自定义</title>
      <link href="/2022/07/28/ros-7-Custom-service/"/>
      <url>/2022/07/28/ros-7-Custom-service/</url>
      
        <content type="html"><![CDATA[<h1>ROS 7: 服务数据自定义</h1><blockquote><p>​从上一篇文章中，简单介绍了服务端以及客户端的代码实现。这里主要描述自己定义服务的数据类型，并且来使用它。我们仍然使用宝可梦的例子来写代码。</p><p>​在前面自定义topic中，topic会一直发数据。我们现在改善一下上次的宝可梦例子，让它只有在request的时候才会发数据</p><p>​在自定义消息的那一章节中，我们使用<code>*.msg</code>的文件来存储，在服务数据自定义中也是类似的，我们使用<code>*.srv</code>文件在自定义数据类型</p><p>​可以参考自定义消息的笔记: <a href="https://tuoyou-hao.github.io/2022/07/19/ros-5-Customize-message-topics/">ROS5</a></p></blockquote><h2 id="一、定义srv文件-编译头文件">一、定义srv文件,编译头文件</h2><p><code>*.msg</code>文件与<code>*.srv</code>文件的区别在于，由于服务数据除了要定义request，还需要定义response。可以参考<a href="https://tuoyou-hao.github.io/2022/07/21/ros-6-client-server-code/">ROS6</a>.定义消息类型的时候，数据定义需要用<code>---</code>三横线区分开来。</p><p>在功能包里新建一个文件夹<code>srv</code>，touch一个<code>*.srv</code>文件，并输入定义的内容。</p><p>这里在learn_server功能包下新建一个srv文件夹，把Pokemon.srv放在这个目录下</p><pre class="line-numbers language-srv" data-language="srv"><code class="language-srv">string namestring typeuint8  genderuint8 unknown = 0uint8 male    = 1uint8 female  = 2---string result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改CMakeLists.txt，在第十行find_package处修改，主要是最后一行加上<code>message_generation</code>这个功能包依赖</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">find_package(catkin REQUIRED COMPONENTS  geometry_msgs  roscpp  rospy  std_msgs  turtlesim  message_generation)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在CMakeLists.txt再加上以下内容，让编译器知道要根据哪个srv文件产生头文件</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_service_files(FILES Pokemon.srv)generate_messages(DEPENDENCIES std_msgs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在CMakeLists.txt加上以下内容，添加编译依赖</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">catkin_package(#  INCLUDE_DIRS include#  LIBRARIES learn_server   CATKIN_DEPENDS geometry_msgs roscp rospy std_msgs turtlesim message_runtime#  DEPENDS system_lib)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后再package.xml文件添加以下依赖描述：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>message_generation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>message_runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在工作空间根目录下，使用<code>catkin_make</code>编译头文件</p><p>编译完成之后，<strong>在工作空间的devel/include/learn_server目录下</strong>，可以看到三个编译完成的头文件：</p><ul><li><p>Pokemon.h：会包含以下两个头文件，加载这一个就足矣。</p></li><li><p>PokemonRequest.h</p></li><li><p>PokemonResponse.h</p></li></ul><h2 id="二、代码实现">二、代码实现</h2><h3 id="c-实现">c++实现</h3><h4 id="1、服务端实现">1、服务端实现</h4><p>导入头文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include "learn_server/Pokemon.h"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>写主函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char **argv){    // ROS节点初始化    ros::init(argc, argv, "pokemon_server");    ros::NodeHandle ser_pokemon_node;    // 创建一个叫做/pokemon_show的server，注册回调函数Callback    ros::ServiceServer pokemon_server = ser_pokemon_node.advertiseService("/pokemon_show", Callback);    // 循环等待回调函数    ROS_INFO("Ready to show pokemon infomation");    ros::spin();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就是写好回调函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// service回调函数，输入参数req，输出参数resbool Callback(learn_server::Pokemon::Request &amp;req,learn_server::Pokemon::Response &amp;res){    // 显示请求数据    ROS_INFO("Pokemon: name:%s type:%s gender:%d", req.name.c_str(), req.type.c_str(), req.gender);    // 设置反馈数据    res.result = "Pokemon response. Done";    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、客户端实现">2、客户端实现</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include "learn_server/Pokemon.h"int main(int argc,char **argv){    ros::init(argc,argv,"pokemon_client");    ros::NodeHandle cli_pokemon_node;    // 发现/pokemon_show服务后，创建一个服务客户端，连接名为/pokemon_show的service    ros::service::waitForService("/pokemon_show");    ros::ServiceClient pokemon_client = cli_pokemon_node.serviceClient&lt;learn_server::Pokemon&gt;("/pokemon_show");    // 初始化learn_server::Pokemon的请求数据    learn_server::Pokemon srv;    srv.request.name = "Pikachu";    srv.request.type = "electric";    srv.request.gender  = learn_server::Pokemon::Request::male;    // 请求服务调用    ROS_INFO("Call service [name:%s, age:%s, sex:%d]",                 srv.request.name.c_str(), srv.request.type.c_str(), srv.request.gender);    pokemon_client.call(srv);    // 显示服务调用结果    ROS_INFO("Result : %s", srv.response.result.c_str());    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、编译运行">3、编译运行</h4><p>在CMakeLists中增加以下内容，告知编译器相关编译规则：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_executable(ser_pokemon src/ser_pokemon.cpp)target_link_libraries(ser_pokemon ${catkin_LIBRARIES})add_dependencies(ser_pokemon ${PROJECT_NAME}_gencpp)add_executable(cli_pokemon src/cli_pokemon.cpp)target_link_libraries(cli_pokemon ${catkin_LIBRARIES})add_dependencies(cli_pokemon ${PROJECT_NAME}_gencpp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在工作空间使用<code>catkin_make</code>编译即可运行</p><p>在运行代码之前记得<strong>先在待运行的终端</strong>执行<code>source devel/setup.bash</code>指令，修改环境变量，rosrun才能读到功能包下的可执行文件。</p><h3 id="python实现">python实现</h3><h4 id="1、服务端实现-2">1、服务端实现</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-import rospyfrom learn_server.srv import Pokemon,PokemonResponsedef Callback(req):    rospy.loginfo("Pokemon: name:%s type:%s gender:%d", req.name, req.type, req.gender)    return PokemonResponse("Pokemon response. Done")def pokemon_server():    rospy.init_node('poekmon_server_py')# 创建一个名为/pokemon_show的server，注册回调函数Callback    s = rospy.Service('/pokemon_show', Pokemon, Callback)# 循环等待回调函数    print "Ready to show pokemon information."    rospy.spin()if __name__ == "__main__":    pokemon_server()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、客户端实现-2">2、客户端实现</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-import sysimport rospyfrom learn_server.srv import Pokemon, PokemonRequestdef pokemon_client():    rospy.init_node('poekmon_client_py')# 发现/pokemon_show服务后，创建一个服务客户端，连接名为/pokemon_show的service    rospy.wait_for_service('/pokemon_show')    try:        poekmon_client_py = rospy.ServiceProxy('/pokemon_show', Pokemon)# 请求服务调用，输入请求数据        response = poekmon_client_py("Psyduck", "water", PokemonRequest.male)        return response.result    except rospy.ServiceException, e:        print "Service call failed: %s"%eif __name__ == "__main__":    print "Show person result : %s" %(pokemon_client())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 六、服务端与客户端</title>
      <link href="/2022/07/21/ros-6-client-server-code/"/>
      <url>/2022/07/21/ros-6-client-server-code/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ROS-6：服务端客户端实现"><a href="#ROS-6：服务端客户端实现" class="headerlink" title="ROS 6：服务端客户端实现"></a>ROS 6：服务端客户端实现</h1><h2 id="一、客户端实现"><a href="#一、客户端实现" class="headerlink" title="一、客户端实现"></a>一、客户端实现</h2><p>实现目标：使用客户端发送一个请求，请求turtlesim的spawn服务来新建一直小海龟，并给定其初始化的坐标位置。发送requext的代码是阻塞式的，需要等到response才会继续执行后续的语句。</p><p><img src="https://s2.loli.net/2022/07/20/3PT6pkbJuSFADVx.png" alt="服务模型"></p><p>创建一个客户端的流程大体为：</p><pre class="mermaid">graph TBa(初始化节点)a --&gt;b(创建client实例)b --&gt;c(发布服务请求数据)c --&gt;d(等待server处理之后的应答结果)</pre><p>首先，按照惯例，我们创建一个功能包：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ~/ros_ws/srccatkin_create_pkg learn_server roscp rospy std_msgs geometry_msgs turtlesim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在功能包的src底下创建第一个cpp文件</p><h3 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>一、导入头文件，初始化节点并创建句柄。</p><p>由于本次需要使用turtlesim的spawn服务，所以需要导入对应的头文件：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include &lt;turtlesim/Spawn.h&gt;int main(int argc, char** argv){ros::init(argc, argv, "turtle_spawn");ros::NodeHandle node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、然后就是需要客户端查询是否存在spawn服务，如果没有就会阻塞在这一句代码一直等待。</p><p>如果spawn服务出现了，就创建一个客户端，用来给spawn服务发送请求的，请求的数据类型是<code>turtlesim::spawn</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的serviceros::service::waitForService("/spawn");ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;("/spawn");//尖括号存放数据类型，后面跟上请求服务的名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>三、封装好请求数据。/spawn里需要存储以下类型的数据，初始化好预设值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// 初始化turtlesim::Spawn的请求数据turtlesim::Spawn srv;srv.request.x = 2.0;srv.request.y = 2.0;srv.request.name = "turtle2";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四、发送请求数据。使用call方法，将封装好的请求数据发送出去。</p><p>call也是阻塞性的函数，在数据发布出去之后，会一直等待服务器的反馈数据。获取到服务器的反馈之后1，才会去执行下一句代码。</p><p>由于在turtlesim成功调用服务之后，会返回这只turtle的名字，所以我们需要获取返回的turtle名。（可见<a href="https://tuoyou-hao.github.io/2022/07/13/ros-2-Basic-command-tools/#1%E3%80%81rosservice-call-%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%E8%AF%B7%E6%B1%82">ROS二：基本命令行工具</a>）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// 请求服务调用ROS_INFO("Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]", srv.request.x, srv.request.y, srv.request.name.c_str());add_turtle.call(srv);// 显示服务调用结果ROS_INFO("Spwan turtle successfully [name:%s]", srv.response.name.c_str());return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置编译文件"><a href="#配置编译文件" class="headerlink" title="配置编译文件"></a>配置编译文件</h4><p>在CMakeLists.txt输入以下文本，添家要编译的文件以及链接库。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_executable(turtle_client src/turtle_client.cpp)target_link_libraries(turtle_client ${catkin_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[ INFO] [1658379402.461341999]: Call service to spwan turtle[x:2.000000, y:2.000000, theta:2.000000,name:turtle2][ INFO] [1658379402.512673909]: Spwan turtle successfully [name:turtle2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以在turtlesim_node界面看到新建海龟成功的日志信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[ INFO] [1658379402.512145247]: Spawning turtle [turtle2] at x=[2.000000], y=[2.000000], theta=[2.000000]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以及在图形界面看到新生成的海龟。</p><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-import rospyimport sysfrom turtlesim.srv import Spawndef turtle_client():    rospy.init_node('turtle_client')    # 发现/spawn服务后，创建一个客户端，连接名为/spawn的service    rospy.wait_for_service('/spawn')    try:        # 创建客户端        add_turtle = rospy.ServiceProxy('/spawn', Spawn)         # 请求服务调用，输入请求数据        # 请求数据，类似cpp的call方法。response获取返回的turtle名字        response = add_turtle(2.0, 2.0, 2.0, "turtle2")         return response.name    except rospy.ServiceException, e:        print "Service call failed: %s"%e        return 0if __name__ == "__main__":    print "Spwan turtle successfully [name:%s]" %(turtle_client())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、服务端实现"><a href="#二、服务端实现" class="headerlink" title="二、服务端实现"></a>二、服务端实现</h2><p>实现目标：给海龟发速度指令。服务端通过获取客户端的指令控制海龟的运动与否。</p><p><img src="https://s2.loli.net/2022/07/21/cqzGZ3KCMitS5ax.png"></p><p>服务端实现的大致流程为：</p><pre class="mermaid">graph TBa(初始化节点)a --&gt;b(创建server)b --&gt;c(循环等待服务请求)c --&gt;d(获取到请求 进入回调函数)d --&gt;e(在回调函数中完成服务功能 并反馈应答数据)</pre><h3 id="c-实现-1"><a href="#c-实现-1" class="headerlink" title="c++实现"></a>c++实现</h3><p>我们如果想要知道Trigger里面包含什么类型，可以用<code>rossrv show</code>指令查看。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rossrv show std_srvs/Trigger ---bool successstring message<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于service包含有request和response两个部分，三横线 “—“以上是request的结构内容，以下是response的内容。</p><p>可以看到Trigger的response结构里包含有一个布尔的flag，以及字符串类型的消息。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>导入头文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;    //topic数据类型#include &lt;std_srvs/Trigger.h&gt;       //service数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>声明publisher等一些全局变量：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::Publisher turtle_pub;          //创建全局的publisherbool pub_turtle_sport_flag = false; //turtle是否运动的flag标记<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>主函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc,char **argv){    ros::init(argc,argv,"turtle_server");    ros::NodeHandle node;    // 自己起一个名为/turtle_command的server，注册回调函数CommandCallBack    ros::ServiceServer command_service = node.advertiseService("/turtle_command",CommandCallBack);    // 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10    turtle_pub = node.advertise&lt;geometry_msgs::Twist&gt;("/turtle1/cmd_vel",10);    // 设置循环的频率    ROS_INFO("Waiting to receive command");    ros::Rate loop_rate(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后写循环，判断标志符并根据标志发布指令</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">while(ros::ok){    // 查看一次回调函数队列,看是否有服务数据传进来    ros::spinOnce();    // 如果标志为true，则发布速度指令    if(pub_turtle_sport_flag)    {        geometry_msgs::Twist vel_msg;        vel_msg.linear.x = 0.5;        vel_msg.angular.z = 0.2;        turtle_pub.publish(vel_msg);    }    //按照循环频率延时    loop_rate.sleep();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数写完，写回调函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// service回调函数，输入参数req，输出参数resbool CommandCallBack(std_srvs::Trigger::Request &amp;req, std_srvs::Trigger::Response &amp;res){    pub_turtle_sport_flag = !pub_turtle_sport_flag;    // 显示请求数据    ROS_INFO("Publish command [%s]", pub_turtle_sport_flag==true?"Yes":"No");    // 设置反馈数据    res.success = true;    res.message = "Change turtle command state!";    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置编译文件-1"><a href="#配置编译文件-1" class="headerlink" title="配置编译文件"></a>配置编译文件</h4><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_executable(turtle_server src/turtle_server.cpp)target_link_libraries(turtle_server ${catkin_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p>首先，按照惯例，运行<code>roscore</code>，<code>rosrun turtlesim turtlesim_node</code>，并使用<code>rosrun &lt;功能包名&gt; &lt;可执行文件名&gt;</code>运行自己的代码，然后新建终端，运行以下指令，给自己的service发送空消息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosservice call /turtle_command "{}"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每运行一次上述指令，布尔值的flag：<code>pub_turtle_sport_flag</code>会自己取反，控制小乌龟是否按照topic运行。</p><h3 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h3><p>由于python中并没有上述c++代码中<code>ros::spinOnce();</code>的机制，只有不断循环的<code>rospy.spin()</code>，所以在开发商存在一定的区别。</p><p>所以我们需要使用<strong>多线程</strong>机制进行开发。</p><p>载入头文件，并初始化全局变量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-import rospyimport thread,timefrom geometry_msgs.msg import Twistfrom std_srvs.srv import Trigger, TriggerResponsepubCommand = False;turtle_vel_pub = rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size=10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从主函数开始介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if __name__ == "__main__":    turtle_server()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先是建立第一个函数，初始化节点以及创建server。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def turtle_server():    rospy.init_node('turtle_server_node')    # 创建一个名为/turtle_command的server，注册回调函数CommandCallback    ser_turtle = rospy.Service('/turtle_command', Trigger, CommandCallback)    # 循环等待回调函数    print "Ready to receive turtle command."    # 创建线程。第一个是线程函数，第二个是传给这个函数的参数。    # 由于我们不需要传参，后面的括号无需填写    thread.start_new_thread(turtle_thread, ())    rospy.spin()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>众所周知，线程所在的起始位置是在某个函数的开头，所以为其封装个函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def turtle_thread():    while True:        if pub_Command:            vel_msg = Twist()            vel_msg.linear.x = 0.8            vel_msg.angular.z = 0.5            turtle_vel_pub.publish(vel_msg)        time.sleep(0.1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当全局变量flag获取到反馈的时候，就需要调用回调函数。所以我们为其封装个回调函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def CommandCallback(req):    global pub_Command    pub_Command = bool(1-pub_Command)    # 显示请求    rospy.loginfo("Publish turtle command![%d]", pub_Command)    # 反馈数据    return TriggerResponse(True, "Change turtle command state!")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然实现的效果和c++是一样的，但是注意实现方式是很有区别的，一个是封装了<code>ros::spinOnce();</code>，一个是使用多线程</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 五、话题消息的自定义</title>
      <link href="/2022/07/19/ros-5-Customize-message-topics/"/>
      <url>/2022/07/19/ros-5-Customize-message-topics/</url>
      
        <content type="html"><![CDATA[<h1>ROS 5: 自定义消息话题</h1><p>实现目标：完成宝可梦信息的话题传输</p><p>自定义话题的流程：</p><pre class="mermaid">graph TBa(定义msg文件)a --&gt;b(package.xml中添加依赖)b --&gt;c(CMakeLists.txt添加编译选项)c --&gt;d(编译生成相关文件)</pre><h2 id="一、定义消息">一、定义消息</h2><p>先定义消息类型，ros使用<code>*.msg</code>格式存储消息。</p><p>msg文件不是编程语言，所以在编译的时候，会根据不同的编程语言动态扩展层不同的数据类型。</p><pre class="line-numbers language-msg" data-language="msg"><code class="language-msg">string name#名字string type#属性uint8  gender#性别uint8 unknown = 0uint8 male    = 1uint8 female  = 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、修改package-xml">二、修改package.xml</h2><p>在功能包的package.xml里，增加两句话，为其增加依赖包。包名如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>message_generation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>message_runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、调整CMakeLists-txt">三、调整CMakeLists.txt</h2><p>在CMakeLists.txt中<strong>补充</strong>以下内容</p><ul><li>1、在第十行find_package的最后补充上<code>message_generation</code>.</li></ul><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">find_package(catkin REQUIRED COMPONENTS  geometry_msgs  roscpp  rospy  std_msgs  turtlesim  message_generation)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>2、声明ROS消息。在<code>Declare ROS dynamic reconfigure parameters</code>上方，有关于msg编译的指导。</li></ul><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">## 在“msg”文件夹中生成消息# add_message_files(#   FILES#   Message1.msg#   Message2.msg# )## 在“srv”文件夹中生成服务# add_service_files(#   FILES#   Service1.srv#   Service2.srv# )## 在“action”文件夹中生成操作# add_action_files(#   FILES#   Action1.action#   Action2.action# )## 生成具有在此处列出的任何依赖项的添加消息和服务# generate_messages(#   DEPENDENCIES#   geometry_msgs#   std_msgs# )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只需写入：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_message_files(  FILES  Pokemon.msg)generate_messages(  DEPENDENCIES  std_msgs)################################################## Declare ROS dynamic reconfigure parameters ##################################################<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>3、在catkin_package增加运行依赖</li></ul><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">##################################### catkin specific configuration #####################################catkin_package(  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成上述修改后，<strong>在工作空间</strong>使用<code>catkin_make</code>编译，然后在<strong>工作空间的devel中</strong>就可以<strong>找到这个功能包的文件夹</strong>，里面就含有一个<code>Pokemon.h</code>头文件。</p><h2 id="四，编写代码">四，编写代码</h2><h3 id="c">c++</h3><h4 id="publisher">publisher</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include "learn_topic/Pokemon.h"int main(int argc,char **argv){        ros::init(argc,argv,"pokemon_pub_topic");    ros::NodeHandle n;    ros::Publisher Pub_Pokemon = n.advertise&lt;learn_topic::Pokemon&gt;("/pokemon_info",10);    ros::Rate loop_rate(10);    while (ros::ok())    {    learn_topic::Pokemon pokemon_msg;pokemon_msg.name = "pikachu";pokemon_msg.type  = "electric";pokemon_msg.gender  = learn_topic::Pokemon::male;Pub_Pokemon.publish(pokemon_msg);        ROS_INFO("Publish Pokemon INfo\n\t name:%s type:%s gender:%d",     pokemon_msg.name.c_str(),pokemon_msg.type.c_str(),pokemon_msg.gender);        loop_rate.sleep();    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="subscriber">subscriber</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include "learn_topic/Pokemon.h"void pokemonInfoCallback(const learn_topic::Pokemon::ConstPtr&amp; msg){    ROS_INFO("Subcribe Pokemon Info: name:%s type:%s gender:%d",  msg-&gt;name.c_str(), msg-&gt;type.c_str(), msg-&gt;gender);}int main(int argc,char **argv){    ros::init(argc, argv, "pokemon_sub_topic");    ros::NodeHandle n;    ros::Subscriber Sub_Pokemon = n.subscribe&lt;learn_topic::Pokemon&gt;("/pokemon_info",10,pokemonInfoCallback);    ros::spin();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="cmake">cmake</h4><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_executable(pub_pokemon src/pub_pokemon.cpp)target_link_libraries(pub_pokemon ${catkin_LIBRARIES})add_dependencies(pub_pokemon ${PROJECT_NAME}_generate_messages_cpp)add_executable(sub_pokemon src/sub_pokemon.cpp)target_link_libraries(sub_pokemon ${catkin_LIBRARIES})add_dependencies(sub_pokemon ${PROJECT_NAME}_generate_messages_cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python">python</h3><h4 id="publisher-2">publisher</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rospyfrom learn_topic.msg import Pokemondef pub_pokemon():    rospy.init_node('py_pokemon_pub_topic', anonymous=True)    Pub_Pokemon = rospy.Publisher('/pokemon_info', Pokemon, queue_size=10)    rate = rospy.Rate(10)    count = 0    while not rospy.is_shutdown():        pokemon_msg = Pokemon()        pokemon_msg.name = "psyduck"        pokemon_msg.type = "water"        pokemon_msg.gender = 2        Pub_Pokemon.publish(pokemon_msg)        rospy.loginfo("Publiish pokemon message[%s-%s-%d]",pokemon_msg.name,pokemon_msg.type,pokemon_msg.gender)        rate.sleep()if __name__ == '__main__':    try:        pub_pokemon()    except rospy.ROSInterruptException:        pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="subscriber-2">subscriber</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rospyfrom learn_topic.msg import Pokemondef pokemonInfoCallback(msg):    rospy.loginfo("Subscribe pokemon info: name:%s type:%s gender:%d",        msg.name,msg.type,msg.gender)def sub_pokemon():    rospy.init_node('py_pokemon_sub_topic',anonymous=True)    rospy.Subscriber('/pokemon_info',Pokemon,pokemonInfoCallback)    rospy.spin()if __name__ == '__main__':    sub_pokemon()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：ROS Master是负责给节点建立连接。如果多个节点链接完毕后，即使ROS Master断开也不影响节点之间的通讯，就是无法建立新的链接而已。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 四、发布者与订阅者</title>
      <link href="/2022/07/18/ros-4-publisher-subscriber-code/"/>
      <url>/2022/07/18/ros-4-publisher-subscriber-code/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ROS-四：发布者与订阅者的实现"><a href="#ROS-四：发布者与订阅者的实现" class="headerlink" title="ROS 四：发布者与订阅者的实现"></a>ROS 四：发布者与订阅者的实现</h1><p><img src="https://s2.loli.net/2022/07/17/ibDTIw9KBfJUx84.png" alt="话题模型（发布/订阅）"></p><blockquote><p>程序目标：</p><p>实现一个Publisher，发布速度指令的msg，控制turtlesim运动。</p></blockquote><p>第一步：创建一个功能包</p><p>功能包相关请参考：<a href="https://tuoyou-hao.github.io/2022/07/17/ros-3-workspace-pkg/">https://tuoyou-hao.github.io/2022/07/17/ros-3-workspace-pkg/</a></p><p>进入工作空间的src路径</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">catkin_create_pkg learn_topic rospy roscpp std_msgs geometry_msgs turtlesim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="一、如何创建一个publisher"><a href="#一、如何创建一个publisher" class="headerlink" title="一、如何创建一个publisher"></a>一、如何创建一个publisher</h2><p>建立一个publisher的基本流程</p><pre class="mermaid">graph TBa(初始化节点)a --&gt;b(注册节点)b --&gt;c(创建消息)c --&gt;d(按一定频率发布消息)</pre><h2 id="c-代码实现"><a href="#c-代码实现" class="headerlink" title="c++代码实现"></a>c++代码实现</h2><h3 id="一、编写代码"><a href="#一、编写代码" class="headerlink" title="一、编写代码"></a>一、编写代码</h3><p>先创建一个cpp文件<code>touch publisher.cpp</code></p><p>我们将使用代码发布turtle1/cmd_vel话题，消息类型为geometry_msgs::Twist</p><ol><li>首先，导入头文件</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后编写我们的主函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char **argv){}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>主函数里，先初始化节点</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// ROS节点初始化,节点名字叫publisher，唯一的名字ros::init(argc, argv, "publisher");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>argc, argv是主函数传入的参数</p><p>publisher是节点的名称，注意不能重名</p><ol start="3"><li>创建节点句柄</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// 创建节点句柄,变量名为nros::NodeHandle n;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>节点句柄是用来管理ros相关的api资源的。比如创建发布者，或创建一系列api调用，都需要用ros的句柄来调用。</p><ol start="4"><li><p>创建publisher来发布消息</p><p>向ROS Master注册节点信息，包括发布的话题名和话题的消息类型。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// 创建一个Publisher,叫turtle_vel_pub// 发布名为/turtle1/cmd_vel的topic// 消息类型为geometry_msgs::Twist，队列长度10ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;("/turtle1/cmd_vel", 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在n.advertise的尖括号里要放的是数据类型，后面跟随要发布的topic名以及消息队列长度。</p><ul><li><p>消息队列长度有一点要注意的是：如果发送频率太高，以太网或底层系统可能来不及快速响应，所以用一个队列，先把消息放在队列里，然后再对外发送数据。</p></li><li><p>如果这里的队列爆满了，队列会把先进队的数据丢弃，队列会永远保存最晚进队列的数据。所以队列会出现掉帧、掉数据的情况。</p></li></ul><ol start="5"><li>设置循环频率</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// 设置循环的频率ros::Rate loop_rate(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="6"><li><p>循环发送数据</p><p>先初始化消息，然后让他按照一定频率发布消息。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int count = 0;while (ros::ok()){    // 初始化geometry_msgs::Twist类型的消息    geometry_msgs::Twist vel_msg;    vel_msg.linear.x = 0.5; //线速度    vel_msg.angular.z = 0.2; //角速度    // 发布消息    turtle_vel_pub.publish(vel_msg);    ROS_INFO("Publish command[%0.2f m/s, %0.2f rad/s]", vel_msg.linear.x, vel_msg.angular.z);    // 按照循环频率延时    loop_rate.sleep();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、代码编译"><a href="#二、代码编译" class="headerlink" title="二、代码编译"></a>二、代码编译</h3><p>在功能包里的CMakeLists里增加两句代码：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">############# Build ##############在CMakeList里的build一栏底下补充上：##add_executable(可执行文件名 要编译的cpp文件)add_executable(publisher src/publisher.cpp)##链接ros的库##target_link_libraries(可执行文件 链接的库)##这里我们链接catkin_LIBRARIEStarget_link_libraries(publisher ${catkin_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在终端输入以下指令进行编译：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ~/ros_wscatkin_makesource devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行代码测试效果：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">roscorerosrun turtlesim turtlesim_noderosrun learn_topic publisher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>如果命令行报错显示找不到功能包：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[rospack] Error: package 'learn_topic' not found<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>记得检查<code>ROS_PACKAGE_PATH</code>环境变量，是否运行<code>source devel/setup.bash</code>。</p><h2 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyfrom geometry_msgs.msg import Twistdef publisher():# ROS节点初始化    rospy.init_node('publisher', anonymous=True)# 创建一个Publisher    turtle_vel_pub = rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size=10)# 设置循环的频率    rate = rospy.Rate(10)     while not rospy.is_shutdown():# 初始化geometry_msgs::Twist类型的消息        vel_msg = Twist()        vel_msg.linear.x = 0.5        vel_msg.angular.z = 0.2# 发布消息        turtle_vel_pub.publish(vel_msg)    rospy.loginfo("Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]", vel_msg.linear.x, vel_msg.angular.z)# 按照循环频率延时        rate.sleep()if __name__ == '__main__':    try:        publisher()    except rospy.ROSInterruptException:        pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编程思想和c++开发的一样。</p><p>在运行roscore和turtlesim的前提下，直接用python指令运行代码即可</p><h2 id="二、如何创建一个订阅者"><a href="#二、如何创建一个订阅者" class="headerlink" title="二、如何创建一个订阅者"></a>二、如何创建一个订阅者</h2><p><img src="https://s2.loli.net/2022/07/18/DHoyuQOtTjk2IPZ.png"></p><p>开发目标：订阅turtlesim的pose信息</p><h2 id="c-代码实现-1"><a href="#c-代码实现-1" class="headerlink" title="c++代码实现"></a>c++代码实现</h2><p>头文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros/ros.h&gt;#include "turtlesim/Pose.h"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>回调函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">// 接收到订阅的消息后，会进入消息回调函数void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg){    // 将收到的消息打印出来    ROS_INFO("Turtle pose: x:%0.6f, y:%0.6f", msg-&gt;x, msg-&gt;y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char **argv){    // 初始化ROS节点    ros::init(argc, argv, "subscriber");    // 创建节点句柄    ros::NodeHandle n;    // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback    ros::Subscriber pose_sub = n.subscribe("/turtle1/pose", 10, poseCallback);    // 循环等待回调函数    ros::spin();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写完毕后，和上述一样，进行编译，然后rosrun运行</p><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-import rospyfrom turtlesim.msg import Posedef poseCallback(msg):    rospy.loginfo("Turtle pose: x:%0.6f, y:%0.6f ",msg.x, msg.y)def subscriber():# ROS节点初始化    rospy.init_node('subscriber', anonymous=True)# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback    rospy.Subscriber("/turtle1/pose", Pose, poseCallback)# 循环等待回调函数    rospy.spin()if __name__ == '__main__':    subscriber()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码参考自：公众号古月居</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 三、工作空间和功能包</title>
      <link href="/2022/07/17/ros-3-workspace-pkg/"/>
      <url>/2022/07/17/ros-3-workspace-pkg/</url>
      
        <content type="html"><![CDATA[<h1>创建工作空间和功能包</h1><h2 id="一、工作空间（workspace）">一、工作空间（workspace）</h2><p>工作空间可以类比为，我们新建一个工程项目，会建立一系列的文件夹目录。工作空间就是一个存放ROS工程开发相关文件的文件夹</p><ul><li><p>src（Source Space）：代码空间</p><p>放置功能包，代码，配置文件，launch文件等等</p></li><li><p>build（Build Space）：编译空间</p><p>放置编译过程中产生的中间文件，通常不需要太关注这些文件</p></li><li><p>devel（Development Space）：开发空间</p><p>放置编译完成的可执行文件，一些库，脚本等等，编译完成的文件会在这运行。</p><ul><li>存放的是开发过程中的可执行文件</li></ul></li><li><p>install（Install Space）：安装空间</p><p>用install指令安装成功后的这部分文件都在这，类比Windows里的<code>C:\Program Files</code>。</p><ul><li>存放的是开发完成后的可执行文件</li></ul></li></ul><p>由于devel和install两个开发空间有重复，在ROS2里只保留了install space，在ros1里就还留有devel space</p><h3 id="1-1-创建工作空间">1.1 创建工作空间</h3><h4 id="1、创建工作空间">1、创建工作空间</h4><p>workspace名可以自己随便起</p><p>这里我们叫 “ros_ws”</p><p>但后面跟随的路径名，如src等名字一定要一致。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p ~/ros_ws/src cd ~/ros_ws/src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面这个指令会把当前文件夹变成ros工作空间的属性<br>执行成功后，src目录底下会生成一个<code>CMakeLists.txt</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">catkin_init_workspace <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2、编译工作空间">2、编译工作空间</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ~/ros_ws/catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行完上述指令，会产生build空间和devel空间。</p><p>如果需要生成install工作空间，需要执行的指令是</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">catkin_make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、设置环境变量">3、设置环境变量</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4、检察环境变量">4、检察环境变量</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo $ROS_PACKAGE_PATH&gt; 查看输出路径是否含有当前该工作环境的路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="二、功能包">二、功能包</h2><h3 id="2-1-创建功能包">2.1 创建功能包</h3><p>创建代码的时候，我们一定要创建功能包。功能包是放置代码的最小单元。我们的代码吗不能直接放置在src底下编译，是不允许的。</p><p>创建功能包的指令要求是：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">catkin_create_pkg &lt;package_name&gt; [depend 1][depend 2]...[depend n]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>package_name：是功能包的名字</p><p>depend：指定功能包的依赖，可以依赖很多个</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 创建功能包cd ~/ros_ws/srccatkin_create_pkg test_pkg std_msgs rospy roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行上述指令，就会在src里创建一个<code>test_pkg</code>功能包（文件夹）</p><p>依赖：</p><ul><li>std_msgs：ros定义的标准消息结构</li><li>rospy、roscpp：用python或c++开发的接口写程序。</li></ul><hr><p>打开<code>test_pkg</code>后，可以看到有include文件夹，src文件夹，package.xml和CMakeLists.txt</p><ul><li><p>src文件夹：所有代码开发的文件都在这</p></li><li><p>include文件夹：放置头文件</p></li><li><p>package.xml：用xml描述功能包相关信息</p><p>会存放作者email，开源许可证，版本号，以及编译依赖，运行依赖等等信息</p></li><li><p>CMakeLists.txt：描述功能包的编译规则，语法是cmake。</p></li></ul><h3 id="2-2-编译功能包">2.2 编译功能包</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ~/ros_wscatkin_makesource ~/ros_Ws/devel/setup.bash #设置环境变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译完成需要将其添加到环境变量。需要验证是否已经加入环境变量，只需要在中端运行以下指令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo $ROS_PACKAGE_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会打印所有ROS功能包的路径。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Win11配置WSL</title>
      <link href="/2022/07/15/wsl_init_Win11/"/>
      <url>/2022/07/15/wsl_init_Win11/</url>
      
        <content type="html"><![CDATA[<h1>Win11配置WSL</h1><blockquote><p>前言废话：</p><p>在电脑上需要LINUX开发的时候，由于虚拟机无法直接连接到电脑主机的显卡，无法在LINUX上进行CUDA编程。所以如果需要在该电脑进行LINUX的CUDA开发，配置一个wsl就显得十分重要。</p><p>本次配置是在一台（刚装过vs c++和CUDA的）全新的电脑上配置的，系统是win11。</p></blockquote><h2 id="1、电脑系统内的配置">1、电脑系统内的配置</h2><p>有两种方法，大同小异，可自行选择<strong>其中一种方案</strong></p><h3 id="1-1-用控制面板">1.1 用控制面板</h3><p>在 <code>控制面板-&gt;程序-&gt;启用或关闭 windows 功能</code> 中，开启 Windows 虚拟化、 Linux 子系统（WSL2)、Hyper-V</p><p><img src="https://s2.loli.net/2022/07/15/9KFs4paNYw8TS1n.png" alt="控制面板"></p><p><img src="https://s2.loli.net/2022/07/15/HpAB2xD8QvhJPVz.png" alt="勾选画框的部分"></p><p><strong>用管理员身份打开powershell</strong>，输入以下指令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">bcdedit /set hypervisorlaunchtype auto<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-用命令行">1.2 用命令行</h3><p><strong>用管理员身份打开powershell</strong>，<code>分别</code>输入以下的指令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">bcdedit /set hypervisorlaunchtype AutoEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -AllEnable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform #需要重启系统，请注意按y让他重启Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果以上内容不能顺利运行，可以执行以下的指令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、下载linux子操作系统">2、下载linux子操作系统</h2><p>打开<code>Microsoft Store</code>，里面有很多不同的linux操作系统，有debain，Ubuntu、kali等等，在搜索框输入自己需要的操作系统名，选择下载即可，这里使用大家都爱用的Ubuntu，版本20.04。</p><p><img src="https://s2.loli.net/2022/07/15/7dst9pbEokK8Pje.png" alt="选择需要的系统即可"></p><p>下载完成后，在<code>cmd</code>或者<code>powershell</code>输入<code>wsl</code>即可。初始化会让你注册用户名，设定密码等等。如果你一路操作下来都很顺利，本次安装到此结束。</p><p><strong>如果你出现了报错，希望在第四部分，我的踩坑解决方案可以帮助到你</strong></p><h2 id="3、查看子系统的文件">3、查看子系统的文件</h2><p>使用<kbd>Win</kbd>+<kbd>r</kbd>调出运行界面框，输入<code>\\wsl$</code>即可打开wsl的文件管理器。</p><p>但我们的运行界面有时候要用别的功能，自然会希望可以在 “此电脑” 界面中直接可以打开了</p><p>我们用上面的方法打开目录后，点选上面的路径复制下来</p><p><img src="https://s2.loli.net/2022/07/15/DMaisbvZyXehnEQ.png" alt="复制wsl的路径"></p><p>然后返回此电脑的界面，右键菜单栏选择<code>添加一个网络位置</code></p><p><img src="https://s2.loli.net/2022/07/15/GrPVDuomldXac6h.png" alt="此电脑中右键菜单栏"></p><p>一路点选 “下一页”，然后他要你填写网络位置的时候，把刚刚的路径粘贴进去，点选 “下一页”继续。</p><p>然后就可以在此电脑界面中直接查看wsl文件了。</p><h2 id="4、踩坑记录">4、踩坑记录</h2><p>我出现的报错内容大致如下：</p><p><img src="https://s2.loli.net/2022/07/15/CWFAgBcvGlOtbxu.png" alt=""></p><p>并且我初步配置的时候，是没有功能<code>Hyper-V </code>的，而且运行下面这条指令的话，会报错<strong>功能名称 Microsoft-Hyper-V 未知。</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-1-解决Microsoft-Hyper-V不存在">4.1 解决Microsoft-Hyper-V不存在</h3><p>首先在电脑新建一个txt文件，把以下内容贴进去</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pushd "%~dp0"dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后保存，文件后缀名改成<code>.cmd</code>格式，然后运行他。</p><p>运行完毕，重新在管理员权限下的powershell中运行刚刚的Microsoft-Hyper-V指令即可</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-解决wsl启动时出现一堆？？？的问题">4.2 解决wsl启动时出现一堆？？？的问题</h3><p>首先下载Windows Subsystem for Linux Update setup 官方版将WSL1升级到WSL2。</p><p>下载地址1：<a href="https://www.xitongzhijia.net/soft/244754.html">https://www.xitongzhijia.net/soft/244754.html</a></p><p>下载地址2：<a href="https://www.aliyundrive.com/s/F297Y6SNpSf">https://www.aliyundrive.com/s/F297Y6SNpSf</a></p><p>下载完毕执行一下该msi程序。</p><p>然后重新跑一下以下代码：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">bcdedit /set hypervisorlaunchtype AutoEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -AllEnable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform #需要重启系统，请注意按y让他重启Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我在完成到这一步就解决问题了。</p><hr><h2 id="5、给wsl安装图形化界面">5、给wsl安装图形化界面</h2><p>回来更新wsl的图形界面</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get purge xrdpsudo apt-get install -y xrdp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>安装完成后，选择第一个选修<code>gdm3</code></p><p>如果选错了，可以用这个语句修改： <code>sudo dpkg-reconfigure gdm3</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt install -y xfce4-goodiessudo cp /etc/xrdp/xrdp.ini /etc/xrdp/xrdp.ini.baksudo sed -i 's/3389/3390/g' /etc/xrdp/xrdp.inisudo sed -i 's/max_bpp=32/#max_bpp=32\nmax_bpp=128/g' /etc/xrdp/xrdp.inisudo sed -i 's/xserverbpp=24/#xserverbpp=24\nxserverbpp=128/g' /etc/xrdp/xrdp.iniecho xfce4-session &gt; ~/.xsession<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编辑/etc/xrdp/srartwm.sh文件，这里随便用什么都可以，我是直接使用vscode的wsl插件进行修改。可以使用nano对文件进行修改。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo nano /etc/xrdp/srartwm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>末尾两句注释掉：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># test -x /etc/X11/Xsession &amp;&amp; exec /etc/X11/Xsession# exec /bin/sh /etc/X11/Xsession<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>并自行在最末尾加上：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># xfcestartxfce4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后启动服务：<code>sudo /etc/init.d/xrdp start</code></p><p>使用<kbd>win</kbd>+<kbd>r</kbd>后，输入mstsc回车</p><p>在界面输入localhost:3390</p><p>输入账号密码登录即可使用</p><p>用完记得用sudo /etc/init.d/xrdp stop 关闭哦</p><p>如果普通用户无法正常登录，比如我会出现 login failed for display 0 的报错：</p><p><img src="https://s2.loli.net/2022/08/30/BmZPfeEClIVvhb4.jpg" alt=""></p><p>可以使用<code>su</code>进入超级用户，然后启动服务。使用root账户名和密码登录远程图形化界面，即可使用。</p><p>如果以上内容还不能解决到你的问题，可以参考/var/log/xrdp-sesman.log日志，根据问题在网上查找相关解决方案</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 二、基本工具</title>
      <link href="/2022/07/13/ros-2-Basic-command-tools/"/>
      <url>/2022/07/13/ros-2-Basic-command-tools/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS-二：基本的命令行工具"><a href="#ROS-二：基本的命令行工具" class="headerlink" title="ROS 二：基本的命令行工具"></a>ROS 二：基本的命令行工具</h1><h2 id="一、启动ros小海龟仿真环境"><a href="#一、启动ros小海龟仿真环境" class="headerlink" title="一、启动ros小海龟仿真环境"></a>一、启动ros小海龟仿真环境</h2><p>我们打开linux的命令行，使用<code>roscore</code>先启动ROS Master</p><p>打开新的终端，使用<code>rosrun turtlesim turtlesim_node</code>，启动小海龟的界面（需要在linux图形化界面启动，命令行界面启动不了）</p><p>再打开一个新的终端，使用<code>rosrun turtlesim turtle_teleop_key</code>（可以使用键盘控制小海龟移动了）</p><ul><li>本篇基本指令都围绕海龟仿真器这项服务举例说明，其他功能大同小异</li></ul><img src="https://s2.loli.net/2022/07/11/G8vxbJjKug367XE.png" alt="turtlesim" style="zoom:60%;"><h2 id="二、ROS常用命令"><a href="#二、ROS常用命令" class="headerlink" title="二、ROS常用命令"></a>二、ROS常用命令</h2><p><img src="https://s2.loli.net/2022/07/11/hbjFekIxfODqS3E.png"></p><p><a href="http://www.clearpathrobotics.com/ros-cheat-sheet">高清链接</a></p><h3 id="2-1-rqt-graph"><a href="#2-1-rqt-graph" class="headerlink" title="2.1 rqt_graph"></a>2.1 rqt_graph</h3><p>ROS里面有一系列以<code>rqt</code>开头的工具，都是一些基于qt的可视化工具，可以直观地展示各种信息</p><p><img src="https://s2.loli.net/2022/07/11/LtdWq9euvbYGfAm.png" alt="rqt_graph"></p><p><code>rqt_graph</code>使用来显示系统的计算图的工具。对计算图不明白的可以看<a href="https://tuoyou-hao.github.io/2022/07/11/ros-1-Core-concepts/">ros计算图简介</a>。通过观察计算图可以观察整个系统的全貌。</p><p>从上图我们可以看到，上面有两个节点，<code>turtlesim</code>是我们小乌龟的节点，<code>teleop_turtle</code>是键盘的节点。<code>cmd_vel</code>节点之间通讯的话题。</p><h3 id="2-2-rosnode"><a href="#2-2-rosnode" class="headerlink" title="2.2 rosnode"></a>2.2 rosnode</h3><p>显示系统中所有节点线管信息的指令。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosnode is a command-line tool for printing information about ROS Nodes.Commands:        rosnode ping    test connectivity to node        rosnode list    list active nodes        rosnode info    print information about node        rosnode machine list nodes running on a particular machine or list machines        rosnode kill    kill a running node        rosnode cleanup purge registration information of unreachable nodes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>命令</th><th>详细说明</th></tr></thead><tbody><tr><td>rosnode ping [节点名]</td><td>测试链接指定节点</td></tr><tr><td>rosnode list</td><td>查看活动的节点列表</td></tr><tr><td>rosnode info [节点名]</td><td>查看指定节点的信息</td></tr><tr><td>rosnode machine [PC名称或IP]</td><td>查看该PC中运行的节点列表</td></tr><tr><td>rosnode kill [节点名]</td><td>停止指定节点的运行</td></tr><tr><td>rosnode cleanup</td><td>删除失连节点的注册信息</td></tr></tbody></table><p>这里只展示个别指令</p><h4 id="1、rosnode-list"><a href="#1、rosnode-list" class="headerlink" title="1、rosnode list"></a>1、rosnode list</h4><p>查看话题列表，把所有节点都列出来</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/rosout#启动roscore就会启动，获取ros日志信息/teleop_turtle/turtlesim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>rosout是在rqt里面不会显示的内容。只要启动roscore就会启动的一个话题，主要用于获取ros日志信息，提交给界面做显示，是ros默认的一个话题。</li></ul><h4 id="2、rosnode-info"><a href="#2、rosnode-info" class="headerlink" title="2、rosnode info"></a>2、rosnode info</h4><p>会展示对应节点的具体信息，语法是</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosnode info /节点名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如我启动<code>rosnode info /turtlesim</code>，会显示如下内容</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">--------------------------------------------------------------------------------Node [/turtlesim]Publications: #正在发布那些话题 * /rosout [rosgraph_msgs/Log] * /turtle1/color_sensor [turtlesim/Color] * /turtle1/pose [turtlesim/Pose]Subscriptions: #在订阅哪些话题 * /turtle1/cmd_vel [geometry_msgs/Twist]#读取键盘输入，移动小海龟Services: #提供的服务，可以用来完成一些配置 * /clear * /kill * /reset * /spawn * /turtle1/set_pen * /turtle1/teleport_absolute * /turtle1/teleport_relative * /turtlesim/get_loggers * /turtlesim/set_logger_level# 底层通信机制的相关信息contacting node http://huanyu-PC:39579/ ...Pid: 3914Connections: * topic: /rosout    * to: /rosout    * direction: outbound (52933 - 127.0.0.1:48044) [26]    * transport: TCPROS * topic: /turtle1/cmd_vel    * to: /teleop_turtle (http://huanyu-PC:38639/)    * direction: inbound (34866 - huanyu-PC:43907) [54]    * transport: TCPROS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3、rostopic"><a href="#2-3、rostopic" class="headerlink" title="2.3、rostopic"></a>2.3、rostopic</h3><p>会输出ros话题相关的信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rostopic is a command-line tool for printing information about ROS Topics.Commands:        rostopic bw     display bandwidth used by topic        rostopic delay  display delay of topic from timestamp in header        rostopic echo   print messages to screen        rostopic find   find topics by type        rostopic hz     display publishing rate of topic            rostopic info   print information about active topic        rostopic list   list active topics        rostopic pub    publish data to topic        rostopic type   print topic or field type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>命令</th><th>详细说明</th></tr></thead><tbody><tr><td>rostopic bw [话题名称]</td><td>显示指定话题的消息带宽（bandwidth）</td></tr><tr><td>rostopic delay [话题名称]</td><td>显示header中时间戳的延迟</td></tr><tr><td>rostopic echo [话题名称]</td><td>实时显示指定话题的消息内容</td></tr><tr><td>rostopic find [类型名称]</td><td>显示使用指定类型的消息的话题</td></tr><tr><td>rostopic type [话题名称]</td><td>显示指定话题的消息类型</td></tr><tr><td>rostopic hz [话题名称]</td><td>显示指定话题的消息数据发布周期</td></tr><tr><td>rostopic info [话题名称]</td><td>显示指定话题的信息</td></tr><tr><td>rostopic list</td><td>显示活动的话题目录</td></tr><tr><td>rostopic pub [话题名称] [消息类型] [参数]</td><td>在命令行，用指定的话题名称发布消息</td></tr><tr><td>rostopic type [话题名称]</td><td>打印主题或字段类型</td></tr></tbody></table><h4 id="1、rostopic-pub-发布话题消息"><a href="#1、rostopic-pub-发布话题消息" class="headerlink" title="1、rostopic pub 发布话题消息"></a>1、rostopic pub 发布话题消息</h4><p>在命令行配合<kbd>Tab</kbd>键，可以自动给你补全指令</p><p>我们在命令行发布<strong>一次</strong>消息给<code>turtlesim</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist "linear:  x: 2.0  y: 3.0  z: 5.0angular:  x: 7.0  y: 9.0  z: 11.0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 它就会自己跑<strong>一次</strong>上述的运动（因为pub只发布了一次消息）。linear是线速度，angular是角速度。</p><p>要想它循环发布，就需要加个频率参数<code>-r</code>，后面跟一个uint数，表示一秒发布几次。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist "linear:  x: 2.0  y: 3.0  z: 5.0angular:  x: 7.0  y: 9.0  z: 11.0" #每秒跑10次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4、rosmsg"><a href="#2-4、rosmsg" class="headerlink" title="2.4、rosmsg"></a>2.4、rosmsg</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosmsg is a command-line tool for displaying information about ROS Message types.Commands:        rosmsg show     Show message description        rosmsg info     Alias for rosmsg show        rosmsg list     List all messages        rosmsg md5      Display message md5sum        rosmsg package  List messages in a package        rosmsg packages List packages that contain messages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>命令</th><th>详细说明</th></tr></thead><tbody><tr><td>rosmsg show [消息名称]</td><td>显示消息的描述</td></tr><tr><td>rosmsg info [消息名称]</td><td>显示消息的信息</td></tr><tr><td>rosmsg list</td><td>列出所有消息</td></tr><tr><td>rosmsg md5 [消息名称]</td><td>显示 md5 加密后的消息</td></tr><tr><td>rosmsg package [消息名称]</td><td>显示某个功能包下的所有消息</td></tr><tr><td>rosmsg packages</td><td>列出包含消息的功能包</td></tr></tbody></table><p>比如我想打印<code>turtlesim</code>的消息数据结构，就按照如下指令：</p><p><code>rosmsg show geometry_msgs/Twist</code></p><p>会显示如下内容：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">geometry_msgs/Vector3 linear  float64 x  float64 y  float64 zgeometry_msgs/Vector3 angular  float64 x  float64 y  float64 z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5、rosservice"><a href="#2-5、rosservice" class="headerlink" title="2.5、rosservice"></a>2.5、rosservice</h3><p>命令行作为ros的 “客户端”，需要发送服务请求给这个海龟仿真器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Commands:        rosservice args print service arguments        rosservice call call the service with the provided args        rosservice find find services by service type        rosservice info print information about service        rosservice list list active services        rosservice type print service type        rosservice uri  print service ROSRPC uri<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>命令</th><th>详细说明</th></tr></thead><tbody><tr><td>rosservice args [服务名称]</td><td>打印服务参数</td></tr><tr><td>rosservice call [服务名称]</td><td>使用所提供的args调用服务</td></tr><tr><td>rosservice find [服务名称]</td><td>按服务类型查找服务</td></tr><tr><td>rosservice info [服务名称]</td><td>打印服务信息</td></tr><tr><td>rosservice list</td><td>显示服务列表</td></tr><tr><td>rosservice type [服务名称]</td><td>打印服务类型</td></tr><tr><td>rosservice uri [服务名称]</td><td>打印服务ROSRPC uri</td></tr></tbody></table><h4 id="1、rosservice-call-发布服务请求"><a href="#1、rosservice-call-发布服务请求" class="headerlink" title="1、rosservice call 发布服务请求"></a>1、rosservice call 发布服务请求</h4><p>比如我使用<code>rosservice list</code>查询<code>turtlesim</code>的服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/clear/kill/reset/rosout/get_loggers/rosout/set_logger_level/spawn#新建小海龟/teleop_turtle/get_loggers/teleop_turtle/set_logger_level/turtle1/set_pen/turtle1/teleport_absolute/turtle1/teleport_relative/turtlesim/get_loggers/turtlesim/set_logger_level<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<kbd>Tab</kbd>键辅助输入：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rosservice call /spawn "x: 1.0 y: 1.0theta: 0.0name: 'turtle2'"   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即可成功调用服务，获得一只新的海龟。并返回值<code>name: "turtle2"</code></p><p>此时使用<code>rostopic list</code>就可以看到以下的输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/rosout/rosout_agg/turtle1/cmd_vel/turtle1/color_sensor/turtle1/pose/turtle2/cmd_vel/turtle2/color_sensor/turtle2/pose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到两个海龟的topic，并且可以用指令分开调用不同海龟。</p><h3 id="2-6-rosbag"><a href="#2-6-rosbag" class="headerlink" title="2.6 rosbag"></a>2.6 rosbag</h3><p>可以记录话题数据并保存下来</p><p>如果下次需要调用的时候可以直接复现出来之前保存到整个记录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Usage: rosbag &lt;subcommand&gt; [options] [args]A bag is a file format in ROS for storing ROS message data. The rosbag command can record, replay and manipulate bags.Available subcommands:   check        Determine whether a bag is playable in the current system, or if it can be migrated.   compress     Compress one or more bag files.   decompress   Decompress one or more bag files.   decrypt      Decrypt one or more bag files.   encrypt      Encrypt one or more bag files.   filter       Filter the contents of the bag.   fix          Repair the messages in a bag file so that it can be played in the current system.   help     info         Summarize the contents of one or more bag files.   play         Play back the contents of one or more bag files in a time-synchronized fashion.   record       Record a bag file with the contents of specified topics.   reindex      Reindexes one or more bag files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1、rosbag-record-话题记录"><a href="#1、rosbag-record-话题记录" class="headerlink" title="1、rosbag record 话题记录"></a>1、rosbag record 话题记录</h4><p><code>rosbag record -a -O cmd_record</code></p><p>系统会在当前目录下生成一个<code>cmd_record.bag</code>文件</p><ul><li><code>-a</code>是指把所有的话题都记录下来</li><li><code>-O</code>是指保存成一个<code>*.bag</code>文件，后面要跟上文件名</li></ul><p>当我们记录完毕之后，ctrl+c结束即可。</p><p>具体的其他参数介绍如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Usage: rosbag record TOPIC1 [TOPIC2 TOPIC3 ...]Record a bag file with the contents of specified topics.Options:  -h, --help            show this help message and exit  -a, --all             record all topics  -e, --regex           match topics using regular expressions  -p, --publish         publish a msg when the record begin  -x EXCLUDE_REGEX, --exclude=EXCLUDE_REGEX                        exclude topics matching the follow regular expression                        (subtracts from -a or regex)  -q, --quiet           suppress console output  -o PREFIX, --output-prefix=PREFIX                        prepend PREFIX to beginning of bag name (name will                        always end with date stamp)  -O NAME, --output-name=NAME                        record to bag with name NAME.bag  --split               split the bag when maximum size or duration is reached  --max-splits=MAX_SPLITS                        Keep a maximum of N bag files, when reaching the                        maximum erase the oldest one to keep a constant number                        of files.  --size=SIZE           record a bag of maximum size SIZE MB. (Default:                        infinite)  --duration=DURATION   record a bag of maximum duration DURATION in seconds,                        unless 'm', or 'h' is appended.  -b SIZE, --buffsize=SIZE                        use an internal buffer of SIZE MB (Default: 256, 0 =                        infinite)  --chunksize=SIZE      Advanced. Record to chunks of SIZE KB (Default: 768)  -l NUM, --limit=NUM   only record NUM messages on each topic  --node=NODE           record all topics subscribed to by a specific node  -j, --bz2             use BZ2 compression  --lz4                 use LZ4 compression  --tcpnodelay          Use the TCP_NODELAY transport hint when subscribing to                        topics.  --udp                 Use the UDP transport hint when subscribing to topics.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、rosbag-play-话题复现"><a href="#2、rosbag-play-话题复现" class="headerlink" title="2、rosbag play 话题复现"></a>2、rosbag play 话题复现</h4><p>记录完成后，用<code>rosbag play</code> 语句调用保存好的<code>*.bag</code>文件，即可复现之前记录的信息。</p><p><code>rosbag play cmd_record.bag</code></p><p>就可以在海龟仿真器看到之前记录的所有指令。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 一、核心概念</title>
      <link href="/2022/07/11/ros-1-Core-concepts/"/>
      <url>/2022/07/11/ros-1-Core-concepts/</url>
      
        <content type="html"><![CDATA[<h1>ROS 一：核心概念</h1><p>ros提供了一种松耦合分布式通信框架。这些框架可以抽象成一个节点图。</p><p>每一个功能都可以是一个节点，比如一个图像采集功能为一个节点、图像检测又是一个节点、slam导航功能也放在一个节点。**每一个具体的功能都是一个节点。**我们用一个椭圆形代表一个节点。</p><p>每个节点通过通讯连接，互相传输数据。我们用箭头表示桐乡数据的流向。</p><ul><li>由节点（椭圆形）和通讯的方向（椭圆形上的箭头）构成ros的<strong>计算图</strong>。</li></ul><p><img src="https://s2.loli.net/2022/07/09/XxaCtYVNp2WglAy.png" alt="计算图"></p><p>如下图，每一个node节点就是机器人完成某一个具体功能的进程</p><p><img src="https://s2.loli.net/2022/07/09/kHO5FbGp1zUIr36.png" alt=""></p><p>每一个node的编程语言可以是不一样的。比如可以使用python，c++等。只要有统一的通讯标准就可以完成整个机器人系统的搭建。</p><h2 id="1、节点与节点管理器">1、节点与节点管理器</h2><ul><li><p>节点（node）——执行单元</p><ul><li>是执行具体任务的<strong>进程</strong>，是独立的可执行文件。</li><li>不同节点可以使用不同的编程语言（常用python或c++），可以分布式运行在不同的主机。</li><li>节点在系统中的名称必须是唯一的。</li></ul></li><li><p>节点管理器（ROS Master）——控制中心</p><ul><li><p>为各个节点提供命名、注册服务。</p></li><li><p>跟踪、记录话题或者服务通信，辅助节点相互查找，建立连接，帮助各个节点之间传输数据。</p><p>节点之间互相不知道彼此之间的存在，都需要ROS Master来帮忙建立连接。</p></li><li><p>提供参数服务器，节点使用此服务器来存储、检索运行时的参数。（可以理解为全局的对象字典，会记录一些全局变量，给各个节点提供服务）</p></li></ul></li></ul><h2 id="2、话题通信">2、话题通信</h2><p>以下是ros通信的两种方式：</p><h3 id="2-1-话题（topic）——异步通信机制">2.1 话题（topic）——异步通信机制</h3><ul><li>节点之间用来传输数据的<strong>重要总线</strong>，是传输的<strong>管道</strong>。</li><li>使用<strong>发布/订阅</strong>模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以是不唯一的。</li><li>如下图，发布者（publisher）给订阅者（subscriber）的通讯是<strong>单向的数据传输</strong>。而通讯的通道就是<strong>话题（Topic）</strong>。</li></ul><p><img src="https://s2.loli.net/2022/07/09/kxgYaKVDbf85IhG.png" alt="话题模型（发布/订阅）"></p><ul><li>消息（message）——话题里头的 “数据”<ul><li>描述传输数据的详细定义就是消息。</li><li>具有一定的类型和数据结构，包括ROS提供的标准类型和用户自定义的类型</li><li>使用编程语言无关的<code>.msg</code>文件来定义消息，编译过程中会生成对应的代码文件。</li></ul></li><li>区分：<ul><li>话题：传输数据的管道。</li><li>消息：传输数据的详细定义。</li></ul></li></ul><blockquote><p>eg:</p><p><img src="https://s2.loli.net/2022/07/09/SpJtixCVerRqy5P.png" alt=""></p><p>在上图中，摄像头把获取到的数据给<code>CameraNode</code>，<code>CameraNode</code>把这些画面发布出去。</p><p><code>Image Processing Node</code>要处理图像数据，使用需要订阅<code>CameraNode</code>发布的数据。</p><p>在笔记本电脑（Laptop）区，笔记本电脑想要显示图像，<code>Image Display Node</code>也就需要订阅这个图像数据</p><p>所以在上图模型中：</p><ul><li>有一个图像数据Publisher，两个图像数据Subscriber，一个Topic（Image data Message），传输图像数据消息。</li></ul></blockquote><h3 id="2-2-服务（service）——同步通信机制">2.2 服务（service）——同步通信机制</h3><ul><li><p>使用客户端/服务器（C/S）模型，客户端发送请求数据，服务器完成处理后，返回应答数据。</p><p>是双向的数据传输</p></li><li><p>使用编程语言无关的<code>.srv</code>文件定义请求和应答数据结构，编译过程中生成对应的代码文件。</p></li></ul><img src="https://s2.loli.net/2022/07/09/1p7cytkFEh4RMAw.png" alt="ros-1-4.png" style="zoom:50%;"><h3 id="2-3-话题与服务的区别">2.3 话题与服务的区别</h3><table><thead><tr><th></th><th style="text-align:center">话题</th><th style="text-align:center">服务</th></tr></thead><tbody><tr><td>同步性</td><td style="text-align:center">异步</td><td style="text-align:center">同步</td></tr><tr><td>通信模型</td><td style="text-align:center">发布/订阅</td><td style="text-align:center">客户端/服务器</td></tr><tr><td>底层协议</td><td style="text-align:center">ROS TCP/ROS UDP</td><td style="text-align:center">ROS TCP/ROS UDP</td></tr><tr><td>反馈机制</td><td style="text-align:center">无</td><td style="text-align:center">有</td></tr><tr><td>缓冲区</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td>实时性</td><td style="text-align:center">弱</td><td style="text-align:center">强</td></tr><tr><td>节点关系</td><td style="text-align:center">多对多</td><td style="text-align:center">一对多（一个server）</td></tr><tr><td>适用场景</td><td style="text-align:center">数据传输</td><td style="text-align:center">逻辑处理</td></tr></tbody></table><h2 id="3、参数（Parameter）全局共享字典">3、参数（Parameter）全局共享字典</h2><ul><li>ROS Master里面的参数服务器。</li><li>可通过网络访问的共享、多变量<strong>字典</strong>，数据类型不唯一。</li><li>节点使用次服务器来存储&amp;检索运行时的参数。</li><li>适合存储静态、非二进制的配置参数，不适合存储动态配置的数据。</li></ul><blockquote><p>eg:</p><img src="https://s2.loli.net/2022/07/11/9WpPugflbYcUK51.png" style="zoom:67%;"><p>如上图，Talker存入<code>setParam</code>了一个参数<code>("foo",1)</code>到ROS Master</p><p>Listener需要调用<code>foo</code>底下的值，就发出一个请求<code>getParam</code></p><p>然后Listener就可以获得ROS Master返回的<code>("foo",1)</code></p><ul><li>观察可以发现，如果Listener只get一次参数，如果参数有变化的话，就没办法及时更新了，就不适合存储动态变化的数据。</li><li>如果需要实时更新参数，就需要用到ROS的高级功能 “动态参数配置”的功能。</li></ul></blockquote><h2 id="4、文件系统">4、文件系统</h2><ul><li><p>功能包（package）</p><p>ROS软件中的基本单元，包含了节点源码、配置文件、数据定义……</p><p>用于完成一些具体的功能，人脸识别、图像识别等等</p></li><li><p>功能包清单（package manifest）</p><p>记录了功能包的基本信息，包含了作者信息、许可信息、依赖选项、变异标志……</p></li><li><p>元功能包（meta package）</p><p>组织多个用于同一个目的的功能包</p><p>比如很多个图像识别的功能包组织成一个大工程，这个大工程就是元功能包。</p></li></ul><pre class="mermaid">graph TBA(文件系统) --&gt;B[元功能包]B --&gt;C[功能包]C --&gt;D1[功能包清单]C --&gt;D2[消息类型]C --&gt;D3[服务类型]C --&gt;D4[代码]C --&gt;D5[其他]</pre><p><img src="https://s2.loli.net/2022/07/11/ZRt6jPecizJA37I.png" alt=""></p><p>参考自: 古月居ros教程</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成概述（2.2存储系统）</title>
      <link href="/2022/06/03/computer_organization3-1/"/>
      <url>/2022/06/03/computer_organization3-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="计算机组成原理——2-2-存储系统"><a href="#计算机组成原理——2-2-存储系统" class="headerlink" title="计算机组成原理——2.2 存储系统"></a>计算机组成原理——2.2 存储系统</h1><h2 id="一、主存存储器与CPU的连接"><a href="#一、主存存储器与CPU的连接" class="headerlink" title="一、主存存储器与CPU的连接"></a>一、主存存储器与CPU的连接</h2><p><img src="https://s2.loli.net/2022/05/18/R41VbvF5dPNT2gX.jpg" alt="MDR和MAR都集成在CPU"></p><p>单个存储芯片的容量可能不是很大，往往需要通过存储器芯片拓展技术，把多个芯片集成在一个内存条上，然后由多个内存条+主板上的ROM芯片，组成计算机所需要的主存空间。</p><p>内存条插槽就是存储器总线。内存条通过总线与主板相连，然后链接到CPU。</p><p><img src="https://s2.loli.net/2022/05/14/Ke6lCakUjm5MNB1.png" alt="8x8位存储芯片原理图"></p><p>由于单个存储芯片的容量是有限的，在<strong>字数</strong>或者<strong>字长</strong>上与实际的存储器要求都有差距。因此，需要<strong>在字和位两个方面进行扩充</strong>。通常采用的方法如下：</p><ul><li>位拓展法：使数据总线宽度=存储芯片宽度（数据总线）</li><li>字拓展法：拓展主存字数（地址总线）</li><li>字位同时拓展</li></ul><h3 id="1、位扩展"><a href="#1、位扩展" class="headerlink" title="1、位扩展"></a>1、位扩展</h3><p>当 CPU的数据线数 与 存储芯片的数据位数 不相等时，就进行位扩展。（针对数据总线）</p><p><strong>用多个存储芯片扩充存储字长</strong></p><p>举个栗子：</p><blockquote><ul><li><p>有一个<code>8k*1位</code>的芯片，8k对应了2的13次方</p><p>   所以需要13根地址线表示地址，将其和CPU连接起来</p></li><li><p>假设现在数据总线有8位，那我们就可以链接八个这样的芯片</p><p>   每传进来一个八位的数据，就由这八块芯片，分别存储这八位数据的其中一位。</p></li><li><p>由上可知，<strong>地址总线、读写控制信号线（WE）、片选信号（CS），由这八个芯片共同使用。</strong></p></li></ul></blockquote><p><img src="https://s2.loli.net/2022/05/26/L3IHi4lEk7wpjcg.jpg" alt="位扩展连线图"></p><h3 id="2、字扩展法"><a href="#2、字扩展法" class="headerlink" title="2、字扩展法"></a>2、字扩展法</h3><p>当<strong>CPU的地址线数</strong>与<strong>存储芯片的地址位数</strong>不相等时，就进行字扩展。（针对数据总线）</p><p>该方法把多出来的地址引脚接到译码器上，用译码器区分不同的片选信号，由这些片选信号来启动不同的存储芯片。</p><p><strong>地址总线（部分）、数据总线、读写控制信号线（WE）由这些芯片共同使用。片选信号（CS）接上译码器使用</strong></p><p><img src="https://s2.loli.net/2022/05/26/Gx1MlHn3FYIibK6.jpg" alt="字拓展连接原理图"></p><h3 id="3、字位同时扩展"><a href="#3、字位同时扩展" class="headerlink" title="3、字位同时扩展"></a>3、字位同时扩展</h3><p>有了前面的理解，我们直接上原理图</p><p><img src="https://s2.loli.net/2022/05/26/yMlBZVcFHEQIh3N.jpg" alt="字位同时扩展原理图"></p><p>16k的存储，对应2的14次方。所以需要使用14条线来表示。</p><p>采用字位同时扩展时，各个芯片连接地址线的方式相同</p><p>但连接数据线的方式不同。且片选信号需要连接译码器。</p><h2 id="二、存储芯片的地址分配和片选"><a href="#二、存储芯片的地址分配和片选" class="headerlink" title="二、存储芯片的地址分配和片选"></a>二、存储芯片的地址分配和片选</h2><p>CPU选择存储芯片的操作叫做<strong>片选</strong>。</p><p>选中后，为选中的芯片按照地址码，选择相应的存储单元，用来存储数据。这个操作叫做<strong>字选</strong>。</p><p>片内的字选，通常是由CPU送出的N条低位地址线完成的。</p><p>地址线直接连到所有存储芯片的地址输入端</p><p>N由片内存储容量$ 2^{N} $决定。</p><p>片选信号的产生分为线选法，译码片选法</p><h3 id="1、线选法"><a href="#1、线选法" class="headerlink" title="1、线选法"></a>1、线选法</h3><p>使用专门的地址线直接链接（或者加个反相器），接到存储芯片上。</p><ul><li>由于是直接链接到存储芯片，当专用的地址线，**有两个及以上的片选信号发出时，会造成访问冲突。</li></ul><blockquote><ul><li>举个栗子，比如只有两个存储芯片，线选法就只能在专门的地址线，比如最高位两位，选择控制芯片.</li><li>如果此时最高位同时为00，或者11，就会导致访问数据出现问题</li><li>而且会导致存储地址不连续。00xxxxxx和11xxxxxx的地址就是不可用的，可以看出有一定的局限性</li></ul></blockquote><h3 id="2、译码片选法"><a href="#2、译码片选法" class="headerlink" title="2、译码片选法"></a>2、译码片选法</h3><p>就是使用译码器，用来产生片选信号。可以通俗的理解为，把8421码转成单独的一个个片选输出</p><p><img src="https://s2.loli.net/2022/05/28/Lv7K3xFkTDAd9P5.png" alt="译码器"></p><p>虽然在连接过程中，需要接入译码器芯片，但是n条线可以产生$ 2^{n}  $个片选信号，二千地址空间连续，实用性更高</p><h2 id="三、外存储器"><a href="#三、外存储器" class="headerlink" title="三、外存储器"></a>三、外存储器</h2><p>磁表面存储器，是指把某些磁性材料薄薄地涂在铝或者塑料表面上，作为记忆载体，一次存储信息。磁盘、磁带、磁鼓存储器都是磁表面存储器</p><h3 id="1、磁盘存储器"><a href="#1、磁盘存储器" class="headerlink" title="1、磁盘存储器"></a>1、磁盘存储器</h3><p>磁盘存储器的优点：</p><ul><li><p>存储容量大，位价格低。相同价位下，机械硬盘的存储容量会比固态硬盘的大</p></li><li><p>存储介质可以重复使用</p></li><li><p>记录信息可以长期保存而不丢失，可以脱机存档</p></li><li><p>非破坏性读出，读出时不需要再生</p></li></ul><p>缺点：</p><ul><li>存取速度慢</li><li>机械结构比较复杂</li><li>对工作环境要求比较高（容易受到强磁场的干扰）</li></ul><h4 id="1-磁盘设备的组成"><a href="#1-磁盘设备的组成" class="headerlink" title="1. 磁盘设备的组成"></a>1. 磁盘设备的组成</h4><p><img src="https://s2.loli.net/2022/05/28/G3pCskQSnj6VUPq.png" alt="磁盘存储器原理图"></p><p>由磁盘驱动器，磁盘控制器和盘片组成</p><ul><li>磁盘驱动器的核心部件是磁头和盘片。温彻斯特盘是一种可移动磁头，固定盘片的存储器</li><li>磁盘控制器，硬盘和主机的接口，常见的有<strong>IDE、SCSI、SATA</strong></li></ul><p><img src="https://s2.loli.net/2022/05/28/9gjawFxAcfXCMYo.png" alt="SCSI存储流程"></p><ul><li><p>存储区</p><ul><li>一块硬盘有很多个盘片，也就是记录面，每个记录面划分为若干个磁道，每条磁道划分为若干个扇区（也称为块）。扇区是磁盘读写的最小单位。<strong>磁盘按照块来存取</strong>。</li></ul><blockquote><ul><li><p><strong>磁头数-Heads</strong>：也就是记录面数，表示硬盘一共有多少个磁头。磁头用来读取、写入盘片的信息，一个记录面对应一个磁头</p></li><li><p><strong>柱面数-Cylinder</strong>：表示硬盘的每个盘片上有多少个磁道。这个名词可以理解为，有一叠盘片，这些盘片上，相同位置（编号）的磁道们构成一个圆柱的面</p><p>说柱面号的时候，就是指明某一条磁道</p></li><li><p><strong>扇区数-Sectors</strong>：表示每个磁道有多少个扇区<sup class="refplus-num"><a href="#ref-s">[1]</a></sup>。</p><ul id="refplus" style="display:none;"><li id="ref-s" data-num="1">[1]   扇区就是盘片的一部分扇形区域</li></ul><p></p></li></ul></blockquote><p><img src="https://s2.loli.net/2022/06/03/7NBJU6bEvWACmQ5.png" alt="盘片正反面都可以读写"></p></li></ul><h4 id="2-磁盘存储原理"><a href="#2-磁盘存储原理" class="headerlink" title="2. 磁盘存储原理"></a>2. 磁盘存储原理</h4><ul><li><strong>原理</strong>：磁头和磁性介质相对运动的时候，通过电磁转换完成读写操作</li><li><strong>编码方法</strong>：按照某种方案或者规律，把一连串的二进制信息变成存储介质上磁层中（磁层翻转状态）的序列，并让读写控制电路更容易、可靠地实现转换</li><li><strong>磁记录方式</strong>：通常采用调频方式（FM）和改进型调频（MFM）的记录方式</li></ul><h4 id="3-磁盘的性能指标"><a href="#3-磁盘的性能指标" class="headerlink" title="3. 磁盘的性能指标"></a>3. 磁盘的性能指标</h4><ul><li><p><strong>记录的密度</strong></p><p>是指盘片上，单位面积内记录的信息量。通常用道<strong>密度、位密度和面密度</strong>表示。</p><ul><li><p><strong>道密度</strong>：沿磁盘半径方向，单位长度上的磁道数</p></li><li><p><strong>位密度</strong>：磁道单位长度上，能记录的二进制代码位数</p></li><li><p><strong>面密度</strong>：位密度 x 道密度</p></li><li><p>补充：</p><ul><li><p>位密度：</p><p>越内侧的磁道位密度越大。越靠外越小</p><p>所以一个磁盘的存储性能受到最靠内侧磁道的制约</p><p>不难理解，因为在最短的一个扇区内的存储上限很低</p><p><img src="https://s2.loli.net/2022/06/03/rELCHz4uAwXSpaR.png" alt="越靠内磁道密度越大"></p></li><li><p>所以：磁盘所有磁道记录的信息量一定是相等的。并不是圆圈越大信息量越多。所以每个磁道的位密度都不相同（外圈长度更长）</p></li></ul></li></ul></li><li><p><strong>磁盘的容量</strong></p><ul><li><p>非格式化容量</p><p>磁记录表面可利用的磁化单元总数，由道密度和位密度计算来的</p><p>（磁盘在物理上总共可以存储多少的数据）</p></li><li><p>格式化容量</p><p>按照某种特定的记录格式，能够存储的信息总量</p><p>（会留出一部分空间用作其他用途。比如为了防止个别扇区损坏，影响整个磁盘的正常工作，会留出一部分备用扇区等等）</p></li></ul><p>非格式化空间大小 &gt; 格式化容量</p></li><li><p>平均存取时间</p><p>由：</p><blockquote><p>寻道时间（磁头移动到对应的磁道，花费的时间）</p><p>旋转延迟时间（磁头找到要读取的扇区，花费的时间）</p><p>传输时间（传输数据花费的时间）</p></blockquote><p>三个部分相加而成。</p><p>也就是，先找到磁道，再2找到对应的扇区位置，然后再写数据。</p><p>由于寻道和找扇区的距离<strong>远近不一</strong>，所以寻道时间通常取平均值，旋转延迟时间可以取<strong>转半圈花费的时间</strong>。</p><blockquote><p>因为我们要读取的扇区，在任何一个位置的概率都是相等的。按照概率计算数学期望的思想，平均来看，尧都区的扇区转到磁头臂的下方，其期望值接近转半圈的时间。</p></blockquote><p>补充：计算机发出读写命令也需要花时间，也就是磁盘控制器的延迟花费的时间</p></li><li><p>数据传输率</p><p>磁盘存储器在单位时间内，向主机传送数据的字节数。</p><blockquote><p>假设磁盘专属为 r转/秒，每条磁道的容量为 N字节，数据传输率计算方式如下（理论最大值）：<br>$$<br>D_r = rN<br>$$</p></blockquote></li></ul><h4 id="4-磁盘地址"><a href="#4-磁盘地址" class="headerlink" title="4. 磁盘地址"></a>4. 磁盘地址</h4><p>主机会向磁盘控制器发出一个寻址的信息。磁盘的地址一般如下表分布：</p><table><thead><tr><th>驱动器号</th><th>柱面（磁道）号</th><th>盘面号</th><th>扇区号</th></tr></thead><tbody><tr><td>一台电脑可以有多个磁盘</td><td>移动磁头臂来寻道</td><td>激活某个磁头</td><td>通过旋转，将特定扇区划过磁头下方</td></tr></tbody></table><p>假设系统有</p><ul><li>4个驱动器，每个驱动器带1个磁盘</li><li>每个磁盘有256个磁道、16个盘面</li><li>每个盘面分为16个扇区</li></ul><p>则每个扇区地址要18位数据表示</p><table><thead><tr><th>驱动器号</th><th>柱面（磁道）号</th><th>盘面号</th><th>扇区号</th></tr></thead><tbody><tr><td>占2位</td><td>占8位</td><td>占4位</td><td>占4位</td></tr></tbody></table><h4 id="5-硬盘的工作过程"><a href="#5-硬盘的工作过程" class="headerlink" title="5. 硬盘的工作过程"></a>5. 硬盘的工作过程</h4><p>硬盘主要操作为寻址、读盘、写盘。每个操作都对应一个控制字（控制命令）</p><p>硬盘工作的时候，先取控制字，再执行控制字</p><p>机械硬盘是机械式的部件，读写操作都是串行的，不能在同一个时刻又读又写，也不能在用一时刻读两组数据或写两组数据。</p><h3 id="2、磁盘阵列"><a href="#2、磁盘阵列" class="headerlink" title="2、磁盘阵列"></a>2、磁盘阵列</h3><p>RAID（Redundant Array of Inexpensive Disks。 <strong>廉价磁盘冗余阵列</strong> ）：指将多个独立的物理磁盘组成一个独立的逻辑盘。数据在多个物理盘上分割交叉存储、并行访问。具有更好的存储性能、可靠性、安全性。</p><ul><li>RAID0：无冗余和无校验的磁盘阵列</li><li>RAID1：镜像磁盘阵列</li><li>RAID2：采用纠错的汉明码的磁盘阵列</li><li>RAID3：位交叉奇偶校验的磁盘阵列</li><li>RAID4：块交叉奇偶校验的磁盘阵列</li><li>RAID5：无独立校验的奇偶校验磁盘阵列</li><li>RAID后面带的数字越大，冗余信息越少，可靠性越高</li></ul><h4 id="1、RAID0：无冗余和无校验的磁盘阵列"><a href="#1、RAID0：无冗余和无校验的磁盘阵列" class="headerlink" title="1、RAID0：无冗余和无校验的磁盘阵列"></a>1、RAID0：无冗余和无校验的磁盘阵列</h4><p><img src="https://s2.loli.net/2022/06/03/pkG7cvSVmflthYq.png" alt="RAID0"></p><p>逻辑上相邻的两个甚至多个扇区，在物理上存到两个或多个磁盘（类比上一篇介绍的<strong>低位交叉编址的多体存储器</strong>）</p><p>也就是说，逻辑上相邻的数据块，把它们<strong>依次、分散</strong>存在物理上多个磁盘内。</p><p>看得出来，RAID0存储方式没有冗余的信息，也没有校验的功能<sup class="refplus-num"><a href="#ref-j">[1]</a></sup></p><ul id="refplus" style="display:none;"><li id="ref-j" data-num="1">[1]   如果某个扇区内损坏或数据错位，存在这个扇区的信息就永远丢失，找不回来了。如果存有一些冗余信息，需要的时候可以用来恢复数据。</li></ul><p></p><h4 id="2、RAID1：镜像磁盘阵列"><a href="#2、RAID1：镜像磁盘阵列" class="headerlink" title="2、RAID1：镜像磁盘阵列"></a>2、RAID1：镜像磁盘阵列</h4><p>就是存两份一样的数据</p><p><img src="https://s2.loli.net/2022/06/03/lXJ8fduW3qpZGKQ.png" alt="RAID1"></p><p>虽然数据出问题的时候，可以通过比对信息，来恢复数据。但是冗余了一半的存储空间，确实有点太粗暴了，也不能并行访问</p><h4 id="3、采用纠错的汉明码的磁盘阵列"><a href="#3、采用纠错的汉明码的磁盘阵列" class="headerlink" title="3、采用纠错的汉明码的磁盘阵列"></a>3、采用纠错的汉明码的磁盘阵列</h4><p>这里每个盘的每块颜色存的不是一块数据，而是一个bit。逻辑上连续的几个bit在物理上分散存储在各个盘中。</p><p>而且，4 bit数据+3 bit汉明码，可以纠正一位错误信息。</p><p><img src="https://s2.loli.net/2022/06/03/dpLb4ns6XfVuJ1G.png" alt="RAID2"></p><p>后面几种偷懒不写<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ，感兴趣可以看<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/1149823?fromtitle=RAID&fromid=33858&fr=aladdin">RAID百度百科</a>了解更多</p><h2 id="3、光盘存储器"><a href="#3、光盘存储器" class="headerlink" title="3、光盘存储器"></a>3、光盘存储器</h2><p>用光学原理存储信息的装置。用聚焦光束对介质存信息</p><p>特点：</p><ul><li>存储密度高</li><li>携带方便</li><li>成本低、容量大</li><li>存储时间长，更好保存</li><li>……</li></ul><p>蓝光波长较短，接近紫光，存储数据的话，信息密度更高。必入蓝光光盘</p><p>光盘类型如下：</p><blockquote><ul><li>CD-ROM：只读光盘，无法写入数据</li><li>CD-R：只能写进去一次信息，之后不可修改</li><li>CD-RW：可重复读写光盘</li><li>DVD-ROM：高容量的CD-ROM。DVD表示通用数字化多功能的光盘</li></ul></blockquote><h2 id="4、固态硬盘SSD"><a href="#4、固态硬盘SSD" class="headerlink" title="4、固态硬盘SSD"></a>4、固态硬盘SSD</h2><p>是一种基于闪存技术的存储器，是一种ROM。它与U盘没有本质的区别，就是容量更大，存储性能更好。</p><p>一个SSD由一个或多个闪存芯片和闪存翻译层组成。闪存芯片替代传统旋转磁盘的机械驱动器。闪存翻译层相当于磁盘控制器的角色。</p><p><img src="https://s2.loli.net/2022/06/03/9Zv21iXa8yIGx7H.png" alt="SSD"></p>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux开发板搭建ros环境</title>
      <link href="/2022/05/26/ros-start/"/>
      <url>/2022/05/26/ros-start/</url>
      
        <content type="html"><![CDATA[<h1>linux开发板配置ros</h1><p>在linux开发板底下，使用官方源即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd /etc/apt/sources.list.d/sudo touch ros-latest.listsudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'sudo apt install curlcurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -sudo apt-get updatesudo apt install ros-melodic-desktop-full#↑为ros桌面版完整安装，包括了ROS、rqt、rviz、机器人通用库、2D/3D 模拟器和 2D/3D 感知#设置每次启动新的 shell 时自动将 ROS 环境变量添加到您的 bash 会话中echo "source /opt/ros/melodic/setup.bash" &gt;&gt; ~/.bashrcsource ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到目前为止，已经安装了运行核心 ROS 软件包所需的东西。如果要创建和管理自己的 ROS 工作区，有多种工具和要求是分开分发的。例如，rosinstall是一种常用的命令行工具，它使您能够通过一个命令轻松下载许多 ROS 包的源代码树。</p><p>要安装此工具和其他依赖项以构建 ROS 包，就运行以下指令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化rosdep</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install python-rosdepsudo rosdep initrosdep update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查ros运行环境</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">printenv | grep ROS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/26/GFPgOWDLtAzqHv7.png" alt=""></p><p>创建catkin工作区</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p ~/catkin_ws/srccd ~/catkin_ws/catkin_makecd buildmake -j8 -l8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为确保工作区被设置脚本正确覆盖，请确保ROS_PACKAGE_PATH环境变量包含所在的目录。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ..source devel/setup.bashecho $ROS_PACKAGE_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#此为打印输出的结果，如果与如下输出类似，就是配置成功/home/HwHiAiUser/catkin_ws/src:/opt/ros/melodic/share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>##测试步骤</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在新的终端运行rostopic list，如果看到话题，可以看到以下画面，算是成功安装</p><p><img src="https://s2.loli.net/2022/05/26/duJ42kf1xe8jnvL.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 环境搭建 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 零、搭建ROS1 Linux环境</title>
      <link href="/2022/05/26/ros-0-start/"/>
      <url>/2022/05/26/ros-0-start/</url>
      
        <content type="html"><![CDATA[<h1>linux开发板配置ros</h1><p>在linux开发板底下，使用官方源即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd /etc/apt/sources.list.d/sudo touch ros-latest.listsudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'sudo apt install curlcurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -sudo apt-get updatesudo apt install ros-melodic-desktop-full#↑为ros桌面版完整安装，包括了ROS、rqt、rviz、机器人通用库、2D/3D 模拟器和 2D/3D 感知#设置每次启动新的 shell 时自动将 ROS 环境变量添加到您的 bash 会话中echo "source /opt/ros/melodic/setup.bash" &gt;&gt; ~/.bashrcsource ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果添加源出现<code>Failed to connect to raw.githubusercontent.com</code>的报错，按照以下步骤即可：</p><p>登录网站：<a href="https://www.ipaddress.com/">https://www.ipaddress.com</a></p><p>在打开的网站中将“<a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a>”复制到查询栏中进行搜索，可以看到域名对应的IP地址信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo chmod 777 /etc/hosts <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用编辑器打开这个文件，<strong>在文末添加你查询到的结果</strong>，比如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">151.101.84.133 raw.githubusercontent.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存退出，改回权限：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo chmod 644 /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可正常使用</p></blockquote><p>到目前为止，已经安装了运行核心 ROS 软件包所需的东西。如果要创建和管理自己的 ROS 工作区，有多种工具和要求是分开分发的。例如，rosinstall是一种常用的命令行工具，它使您能够通过一个命令轻松下载许多 ROS 包的源代码树。</p><p>要安装此工具和其他依赖项以构建 ROS 包，就运行以下指令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化rosdep</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install python-rosdepsudo rosdep initrosdep update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查ros运行环境</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">printenv | grep ROS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/26/GFPgOWDLtAzqHv7.png" alt=""></p><p>创建catkin工作区</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p ~/catkin_ws/srccd ~/catkin_ws/catkin_makecd buildmake -j8 -l8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为确保工作区被设置脚本正确覆盖，请确保ROS_PACKAGE_PATH环境变量包含所在的目录。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ..source devel/setup.bashecho $ROS_PACKAGE_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#此为打印输出的结果，如果与如下输出类似，就是配置成功/home/HwHiAiUser/catkin_ws/src:/opt/ros/melodic/share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="测试步骤">测试步骤</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在新的终端运行<code>rostopic list</code>，如果看到话题，可以看到以下画面，算是成功安装</p><p><img src="https://s2.loli.net/2022/05/26/duJ42kf1xe8jnvL.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成概述（2.1存储器）</title>
      <link href="/2022/05/15/computer_organization3/"/>
      <url>/2022/05/15/computer_organization3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="计算机组成原理——2-1-存储系统"><a href="#计算机组成原理——2-1-存储系统" class="headerlink" title="计算机组成原理——2.1 存储系统"></a>计算机组成原理——2.1 存储系统</h1><h2 id="一、存储器的层次结构"><a href="#一、存储器的层次结构" class="headerlink" title="一、存储器的层次结构"></a>一、存储器的层次结构</h2><pre class="mermaid">graph TBCPU --&gt; Cache(Cache高速缓冲储存器)Cache --&gt; A(主存/内存)A --&gt;B(磁盘/辅存)B --&gt;C(U盘-磁带-光盘/外存)</pre><ul><li><p>从上到下：容量从小到大、速度，价格从大到小</p></li><li><p>性能更高的，还会将cache分为L1（一级cache）L2（ 二级cache）等等，通常来说，L1最快。cache成本比内存大得多。</p></li><li><p>主存&amp;辅存：实现虚拟存储系统，解决主存容量不够的问题。</p></li><li><p>Cache&amp;主存：解决了主存与CPU速度不匹配的问题。</p></li></ul><h3 id="1、按层次分类"><a href="#1、按层次分类" class="headerlink" title="1、按层次分类"></a>1、按层次分类</h3><pre class="mermaid">graph LRA(按层次分类)subgraph memoryB(高速缓存--cache)C(主存储器--主存 - 内存)endD(辅助存储器--辅存 - 外存)E(可直接被CPU读写)A --&gt;BA --&gt;CA --&gt;DB --&gt;EC --&gt;E</pre><h3 id="2、存储介质"><a href="#2、存储介质" class="headerlink" title="2、存储介质"></a>2、存储介质</h3><ul><li>半导体存储器（主存，Cache）</li><li>磁性材料存储器（磁盘，磁带）</li><li>光存储器，以光介质存储信息（光盘）</li></ul><h3 id="3、存取方式"><a href="#3、存取方式" class="headerlink" title="3、存取方式"></a>3、存取方式</h3><ul><li><p>随机存储器（Random Access Memory，RAM）</p><p>读写任何一个存储单元所需要的时间都相同，与存储单元所在物理位置无关。如内存条</p></li><li><p>顺序存储器（Sequential Access Memory，SAM）</p><p>读写一个存储单元所需的时间取决于存储单元所在位置。如磁带</p></li><li><p>直接存取存储器（Direct Access Memory，DAM）</p><p>既有随机存储特性，也有顺序存储特性。先直接选取信息所在的区域，然后按顺序的方式存储。如：机械硬盘</p></li><li><p>相联存储器（Associative Memory）即可以按内容访问的存储器（Content Addressed Memory，CAM）</p><p>可以按照内容检索到存储位置进行读写。快表<sup class="refplus-num"><a href="#ref-k">[1]</a></sup>就是一种相联存储器  </p><ul id="refplus" style="display:none;"><li id="ref-k" data-num="1">[1]  快表是一种特殊的高速缓冲存储器（Cache），内容是页表中的一部分或全部内容。</li><li id="ref-在操作系统中引入快表是为了加快地址映射速度" data-num="2">[2] 在操作系统中引入快表是为了加快地址映射速度。</li><li id="ref-在虚拟页式存储管理中设置了快表，作为当前进程页表的Cache。通常快表处于MMU中" data-num="3">[3] 在虚拟页式存储管理中设置了快表，作为当前进程页表的Cache。通常快表处于MMU中。</li></ul><p></p></li><li><p>顺序存储和直接存储的存储器统称<strong>串行访问存储器</strong>：</p><p>读取某个存储单元所需时间与存储单元的物理位置有关。</p></li></ul><h3 id="4、信息的可更改性"><a href="#4、信息的可更改性" class="headerlink" title="4、信息的可更改性"></a>4、信息的可更改性</h3><ul><li>读写存储器（read/write Memory）== 可读也可写（磁盘，内存，cache）</li><li>只读存储器（Read Only Memory）== 只读，不可写（CD-ROM，BIOS存储的ROM）要写入比较麻烦，需要先擦除再写入。</li></ul><h3 id="5、信息的可保存性"><a href="#5、信息的可保存性" class="headerlink" title="5、信息的可保存性"></a>5、信息的可保存性</h3><ul><li>易失性存储器（主存，cache）：断电后存储信息就消失了</li><li>非易失存储器（磁盘，光盘）：断电后信息还保留</li><li>破坏性读出（DRAM）：信息读出后，原存储信息被破坏。DRAM读出数据后需要进行重写</li><li>非破坏性读出（SRAM，磁盘，光盘）：信息读出后，原本信息不会被破坏</li></ul><h3 id="6、存储器性能指标"><a href="#6、存储器性能指标" class="headerlink" title="6、存储器性能指标"></a>6、存储器性能指标</h3><ul><li><p>存储容量：存储字长（MDR位数） x 字长（如：1M x 16位）</p></li><li><p>单位成本：每位加个 = 总成本 / 总容量</p></li><li><p>存储速度：数据传输率 = 数据的宽度 / 存储周期</p></li><li><p>存取时间Ta：从启动一次存储器操作到完成该操作所经历的时间，分读出时间和写入时间。</p></li><li><p>存取周期Tm：存储器进行一次完整的读写操作所需的全部时间。（也就是连续两次独立访问存储器操作，所需的最小时间间隔）</p></li><li><p>主存带宽Bm：又称数据传输率。表每秒从主存进出心理的最大数量，单位：字/秒、字节/每秒（B/s）、位/秒（b/s）</p></li></ul><h2 id="二、主存储器基本组成"><a href="#二、主存储器基本组成" class="headerlink" title="二、主存储器基本组成"></a>二、主存储器基本组成</h2><p>由电容与MOS关组成</p><p><img src="https://s2.loli.net/2022/05/13/fR9LpVQDsGouOe4.png" alt="原理图"></p><p>我们使用译码器，使用n位地址找到2^n个存储单元里对应的存储信息。地址由MAR存储。CPU通过地址总线连接MAR。</p><p>CPU给MAR一个地址，通过译码器找到对应地址的存储单元，将其数据通过数据总线（位线）输出给MDR，MDR吧数据给CPU。数据总线的宽度 = 存储字长</p><ul><li>总容量 = 存储单元个数 * 存储字长</li></ul><p>其中，MAR和MDR需要通过<strong>控制电路</strong>和<strong>译码器驱动器</strong>，可以理解为负责稳定输出。只有MAR和MDR里的数据存储稳定之后，控制电路才会打开通路的开关，让数据在总线上进行传输。</p><p><img src="https://s2.loli.net/2022/05/14/Ke6lCakUjm5MNB1.png"></p><p>片选线负责在多个存储芯片中，选择其中一个存储芯片，在里头读取数据。</p><p><img src="https://s2.loli.net/2022/05/14/R4umtJ9oEPwWhvS.png" alt="多个存储芯片"></p><p>存储芯片总结一共由于五类引脚：</p><ul><li><p>地址线</p></li><li><p>数据线</p></li><li><p>片选线</p></li><li><p>读写控制线</p></li><li><p>供电引脚与接地引脚</p></li></ul><p><strong>寻址</strong></p><p>按字节寻址</p><p>按字寻址</p><ul><li>字地址算术左移一定位数，即可转换为对应的字节地址</li></ul><p>按半字寻址</p><p>按双字寻址</p><h2 id="三、SRAM-amp-DRAM"><a href="#三、SRAM-amp-DRAM" class="headerlink" title="三、SRAM & DRAM"></a>三、SRAM &amp; DRAM</h2><ul><li><p>DRAM，Dynamic Random Access Memory，即动态RAM</p><p>SRAM，Static Random Access Memory，即静态RAM</p></li><li><p>DRAM用于主存，SRAM用于Cache</p></li><li><p>上述介绍的 “主存储器基本组成” 就是DRAM。</p></li></ul><table><thead><tr><th>类型特点</th><th>DRAM（常用主存）</th><th>SRAM（常用cache）</th></tr></thead><tbody><tr><td>存储器</td><td>栅极电容</td><td>双稳态触发器</td></tr><tr><td>是否破坏性</td><td>电容放电时信息被破坏，是破坏性读出，读出之后应有重写操作。也称 “再生” 。</td><td>读出数据的时候，触发器保持状态稳定，非破坏性读出，无需重写。</td></tr><tr><td>读写速度</td><td>更慢</td><td>更快</td></tr><tr><td>集成度&amp;成本</td><td>集成度高，成本低</td><td>集成度低，成本高</td></tr><tr><td>是否易失</td><td>是，断电后信息消失</td><td>是，断电后信息消失</td></tr><tr><td>需要刷新</td><td>需要，存储介质是电容</td><td>不需要，存储介质是触发器</td></tr><tr><td>送行列地址</td><td>分两次送</td><td>同时送</td></tr><tr><td>功耗&amp;发热量</td><td>功耗低，发热量小</td><td>功耗高，发热量高</td></tr></tbody></table><ul><li><p>DRAM存储单元使用的MOS管比SRAM更少，在芯片面积不变的情况下，DRAM集成度更高。</p></li><li><p>核心区别：存储元不一样</p></li></ul><h3 id="3-1-DRAM刷新"><a href="#3-1-DRAM刷新" class="headerlink" title="3.1 DRAM刷新"></a>3.1 DRAM刷新</h3><ul><li><p>刷新的概念</p><ul><li><p>刷新一次的时间间隔：</p><p>DRAM使用的电容存储信息，大概2ms后信息会消失，所以DRAM每2ms就需要刷新一次。</p></li><li><p>每次刷新多少个存储单元：</p><p>由于DRAM存储器需要刷新，如果我们有20根选线，就有2^20 = 1M根选线。如果全部接在一个译码器，难度会很大。</p><p>此时我们把这个译码器拆分成两个，为（行地址译码器）和（列地址译码器），每个译码器只需要处理一半的地址，即2^10 = 1k = 1024根选线，这样就可以把存储单元排列成2^{n/2} x 2^{n/2}的存储单元<strong>矩阵</strong>。</p><p><strong>使用行列地址可以减少选通线的数量</strong></p></li></ul></li><li><p>如何刷新？</p><p>所以每次刷新的时候，以行为单位，<strong>每次刷新一行存储单元</strong>。</p><p>这里有硬件的支持，由存储器独立完成，不需要CPU控制。</p><p>读出一行的信息之后就重新写入。</p><p>由于刷新一次类似于一次读操作，所以时间上占用一个读或写周期。</p></li><li><p>刷新的思路</p><ul><li><p>思路一，分散刷新：</p><p>每次读写完都刷新一行</p></li><li><p>思路二，集中刷新：</p><p>2ms内集中安排一块时间全部刷新。那就会出现有一段时间专门用于刷新，无法访问存储器，称为访存 “死区”。</p></li><li><p>思路三，异步刷新：</p><p>2ms内每行刷新一次即可，那每隔2ms就会出现一次 “死时间”（可以理解为分散了死区），在这期间，CPU无法访问。<strong>可以在译码阶段刷新</strong>。</p></li></ul></li><li><p>送行列地址：</p><ul><li>因为DRAM使用了两个译码器，所以我们使用<strong>地址线复用技术</strong>，也就是说，每次传输一半的地址给其中一个译码器即可先接受行地址，再接受列地址，分两次传输地址，给两个译码器。我们就可以减少一半的地址线，芯片引脚也会更少。</li><li>SRAM因为集成度更低，所以地址我们同时传输即可</li></ul></li><li><p>现在主存芯片通常使用<code>SDRAM</code>芯片，</p></li></ul><h2 id="四、只读存储器ROM"><a href="#四、只读存储器ROM" class="headerlink" title="四、只读存储器ROM"></a>四、只读存储器ROM</h2><p>RAM芯片断电后数据会消失（易失性的），而：</p><p>ROM芯片，断电后数据不会消失（非易失性的）。</p><p>ROM还可以细分为：<code>MROM</code>、<code>PROM</code>、<code>EPROM</code>、<code>flash闪存</code>、 <code>SSD</code></p><p>很多ROM也具有 “随机存储” 特性。</p><h3 id="1、MROM"><a href="#1、MROM" class="headerlink" title="1、MROM"></a>1、MROM</h3><p>MROM（Mask Read Only Memory），掩模式只读寄存器</p><p>由厂家直接写入信息，只能读出，之后任何人<strong>不可重写</strong></p><p>可靠性高、灵活性差、生产周期长，只适合批量生产</p><h3 id="2、PROM"><a href="#2、PROM" class="headerlink" title="2、PROM"></a>2、PROM</h3><p>PROM（Programmable Read Only Memory），可编程只读存储器</p><p>用户可以用专门的软件写入信息，<strong>写一次之后就不可更改</strong></p><h3 id="3、EPROM"><a href="#3、EPROM" class="headerlink" title="3、EPROM"></a>3、EPROM</h3><p>EPROM（Erasable Programmable Read Only Memory）</p><p>允许用户写入信息，之后可以擦除数据，可进行多次重写</p><h3 id="4、UVEPROM"><a href="#4、UVEPROM" class="headerlink" title="4、UVEPROM"></a>4、UVEPROM</h3><p>UVEPROM（Ultraviolet rays），可以使用紫外线照射8-20分钟，擦除<strong>所有</strong>信息</p><h3 id="5、EEPROM"><a href="#5、EEPROM" class="headerlink" title="5、EEPROM"></a>5、EEPROM</h3><p>第一个E表示的是Electrically，也就是说，可以使用电擦除，擦除<strong>特定</strong>的字。</p><h3 id="6、FLASH-MEMORY"><a href="#6、FLASH-MEMORY" class="headerlink" title="6、FLASH MEMORY"></a>6、FLASH MEMORY</h3><p>Flash Memory，闪速存储器（比如U盘、sd卡），从<code>EEPROM</code>发展来的。断电后可以保存信息，且<strong>可以进行多次快速擦除重写</strong>。</p><p>由于闪存需要先电擦除再写入，所以闪存的 “写” 要比 “读” 来的更慢。</p><p>每个存储元只需要一个MOS管，位密度要比<code>RAM</code>高。</p><h3 id="7、SSD固态硬盘"><a href="#7、SSD固态硬盘" class="headerlink" title="7、SSD固态硬盘"></a>7、SSD固态硬盘</h3><p>由控制单元+存储单元（flash）组成。</p><p>与闪存的核心区别在于：控制单元不一样。</p><p>但是由于存储介质类似，<strong>可以进行多次快速擦除重写</strong>。</p><p>SSD速度快、功耗低、价格高，目前个人电脑常用SSD取代传统的机械硬盘。</p><p>手机辅存也是用的FLASH芯片。相比SSD使用的芯片，集成度高，功耗低，价格贵</p><h2 id="五、计算机内重要的ROM"><a href="#五、计算机内重要的ROM" class="headerlink" title="五、计算机内重要的ROM"></a>五、计算机内重要的ROM</h2><pre class="mermaid">graph TBsubgraph 主机A[主存RAM //+ROM] subgraph CPU    B(运算器)    C(控制器)endend</pre><p>CPU的任务是到<strong>主存</strong>中取指令，然后去运行。主存RAM中存放着指令与数据。而断电后，RAM数据全部丢失。</p><p>所以CPU开机的时候，里头是没有存放指令的。需要把操作系统、应用程序相关的<strong>指令、数据</strong>，重新调入主存。</p><p>而我们知道，操作系统是安装在<strong>辅存</strong>里面的。如何开机，也是需要CPU执行开机指令。但此时CPU里头完全没有指令。</p><p>所以CPU开机的时候，就需要在主板上的ROM芯片读取开机的指令。这块ROM就是<strong>BIOS</strong>。</p><ul><li>主板上BIOS芯片（ROM)，存储了<strong>自举装入程序</strong>，负责引导装入操作系统（开机）</li></ul><p>逻辑上来说，主存由RAM（内存）+ROM（BIOS）组成，且二者通常统一编址。<strong>主板上ROM也是 “主存” 的一部分</strong>。</p><h2 id="六、双端口RAM-amp-多模块存储器"><a href="#六、双端口RAM-amp-多模块存储器" class="headerlink" title="六、双端口RAM & 多模块存储器"></a>六、双端口RAM &amp; 多模块存储器</h2><ul><li><p>存取周期：存取（启动存取 -&gt; 存取完）的时间 + 恢复（存取完 + 下次存取之前）的时间</p><p>也可以表示成：可以连续读写的最短时间间隔</p><ul><li>注：DRAM的恢复时间比较长，有可能会是存取时间的几倍（SRAM的恢复时间比较短）</li></ul></li></ul><p>每次读取完数据，都需要一段时间恢复。如果此时多核CPU都需要访存，那是不是每个CPU都需要等待RAM的恢复时间，才能进行下一次的存取？且即使是单核CPU，读写数据的速度比主存快很多，主存恢复时间太长了该怎么办？</p><p>这里就使用到双端口存储器</p><h3 id="6-1-双端口RAM"><a href="#6-1-双端口RAM" class="headerlink" title="6.1 双端口RAM"></a>6.1 双端口RAM</h3><ul><li><p>作用：<strong>优化多核CPU访问一根内存条的速度</strong>，可以通过两个端口</p></li><li><p>需要有两组完全独立的数据线、地址线、控制线</p></li><li><p>两个端口同时操作主存时：</p><ul><li>两个端口同时对不同的地址单元存数据</li><li>两个端口同时对同一个地址单元读出数据</li><li>两个端口同时对同一个地址单元写入数据（会造成写入错误）</li><li>两个端口同时对同一个地址单元，一个写入，一个读出（会造成读出错误）</li><li>解决方案：<ul><li>把<code>busy</code>信号置0，由判断逻辑决定暂时关闭一个端口（被延时），未被关闭的端口正常访问，被关闭的端口延长很小一段时间后可以再次访问。</li></ul></li></ul></li></ul><h3 id="6-2-多体并行存储器"><a href="#6-2-多体并行存储器" class="headerlink" title="6.2 多体并行存储器"></a>6.2 多体并行存储器</h3><p>CPU读写速度比内存快很多，而内存每次读写过后，需要一段恢复的时间。当CPU需要连续读取的时候，就必须等待内存的恢复时间。所以可以用上多体并行存储器</p><p>多体并行存储器可以理解为使用了多个存储体（每个内存条大小一致，<strong>假设我们使用四个存储体</strong>）</p><p>CPU访存的时候，一定需要一个地址。有以下两种编址模式</p><ul><li><p>高位交叉编址的多体存储器</p><p><img src="https://s2.loli.net/2022/05/14/lQFVykqaizZ2C78.png" alt="高位多体并行存储器原理图"></p><p>假设说我们用的八位地址，那我们就会用<strong>最高位</strong>来区分我存在第几个存储体里（比如最高两比特位共有四种状态）</p><ul><li>看图可知，高位内模块地址是连续的，存取方式仍然是串行存储。<strong>仍然是顺序存储器</strong></li><li>高位交叉的方式下，总是把低位的体内地址送到由高位体号确定的模块内进行译码。</li><li>访问一个连续主存块时，总是先在一个模块内进行访问，等到这个模块访问结束之后才转到下一个模块进行访问。</li><li>CPU总是按顺序访问存储模块，各个模块不能被并行访问，所以不能提高存储器的吞吐率</li></ul></li><li><p>低位交叉编址的多体存储器</p><p><img src="https://s2.loli.net/2022/05/14/SN7A3Kc5rlZDvXW.png" alt="低位多体并行存储器原理图"></p><p>假设说我们用的八位地址，那我们就会用<strong>最低位</strong>来区分我存在第几个存储体里（比如最低两比特位共有四种状态）</p><ul><li><p>看图可知，每个模块按照 “模m” 交叉编址，<strong>模块号 = 单元地址 % m</strong>。</p></li><li><p>低位交叉方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。程序连续放在相邻的模块中，因此称这种编址方式的存储器叫<strong>交叉存储器</strong>。可以在不改变每个模块存储周期的前提下，使用流水线并行存取，提高存储器的带宽。</p><ul><li>如果单模块存取周期为T，总线传送周期为r，实现流水线存储，**存储器交叉模块数m(交叉存储度)  应该大于等于<code>T/r</code>**。以保证启动某个模块后的<code>m*r</code>的时间内要再次启动模块的时候，这个模块已经存取完毕，并已经度过了内存的恢复时间。</li><li>存取周期为T，存取时间为r，为了流水线不间断，保证模块数量为<code>m&gt;=T/r</code>。</li></ul></li><li><p>这样下来，连续存取m个字所需要的时间为:<br>$$<br>t1 = T + (m-1)r<br>$$</p></li><li><p>而顺序方式连续读取m个字所需要的时间为：<br>$$<br>t2 = mT<br>$$</p></li><li><p>综上所述，低位交叉存储器的带宽得到了大幅度的提高（如下图）</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/14/Wfg1po5J3sv67Od.png" alt="低位交叉编址甘特图"></p><p>类似数组等等数据，或者编写的指令代码，其数据存放方式就是连续的存储（除了指令跳转部分）。所以连续存取的速度提升对于计算机来说很有意义。</p><h3 id="6-3-单体多字存储器"><a href="#6-3-单体多字存储器" class="headerlink" title="6.3 单体多字存储器"></a>6.3 单体多字存储器</h3><p>多体并行存储器就是，每个模块都有相同的容量和存储速度，是互相独立的。CPU可以自由选择在哪个存储体的哪个位置读取数据。</p><p>各个模块都有独立的读写控制电路、地址寄存器和数据寄存器等等。可以<strong>并行、交叉</strong>地工作。</p><p>单体多字存储器相当于做了一个合并。共用一套读写控制电路、地址控制器和数据寄存器（类似位拓展）。</p><p><img src="https://s2.loli.net/2022/05/15/BsiGhIDR1wzo8yc.png"></p><p>每次可以读取一整行的数据</p><p>设每个存储单元，存储m个字</p><p>总线宽度也为m个字</p><p>一次并行即可读出m个字</p><p>缺点：指令和数据在主存内必须是连续存放的。一旦遇到转移指令或者操作数不能连续存放，提速的效果就不明显了。</p>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Apt运行报错排查</title>
      <link href="/2022/05/12/error-linux-Unable-to-acquire-the-dpkg-frontend-lock/"/>
      <url>/2022/05/12/error-linux-Unable-to-acquire-the-dpkg-frontend-lock/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="linux中对于Unable-to-acquire-the-dpkg-frontend-lock的解决方法"><a href="#linux中对于Unable-to-acquire-the-dpkg-frontend-lock的解决方法" class="headerlink" title="linux中对于Unable to acquire the dpkg frontend lock的解决方法"></a>linux中对于Unable to acquire the dpkg frontend lock的解决方法</h1><p>运行环境：Ubuntu 18.04<br>问题描述：在别人配置好的Ubuntu下安装软件时，进行<code>apt-get</code>操作，出现了如下报错：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解决办法:</p><h2 id="一、终止占用的进程"><a href="#一、终止占用的进程" class="headerlink" title="一、终止占用的进程"></a>一、终止占用的进程</h2><p>导致的原因：<strong>进程中存在与apt相关的运行中的进程</strong></p><ul><li>检查是否在运行apt,apt-get相关的进程</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ps aux | grep -i apt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果存在与apt相关的正在运行的进程，kill掉对应的进程ID；</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo kill -9 &lt;process id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        或使用简单粗暴的方式:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo killall apt apt-get <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、删除lockfile并配置dpkg"><a href="#二、删除lockfile并配置dpkg" class="headerlink" title="二、删除lockfile并配置dpkg"></a>二、删除lockfile并配置dpkg</h2><p>问题现象：<strong>进程列表中已经没有与(apt/apt-get)相关的进程在运行，但依然报错</strong></p><p>导致的原因：lock file未被正常删除</p><ul><li>lock file用于防止两个或多个进程使用相同的数据。 当运行apt及其相关指令时，它会在几个地方创建lock files。<br>当前一个apt命令未正确终止时，lock file就不会被删除。因此它们会阻止任何新的apt / apt-get命令实例，</li><li>比如正在执行<code>apt-get update</code>，在执行过程中直接ctrl+c取消了该操作，很有可能就会造成这种情况。</li><li>要解决此问题，首先要删除lock file。<br>使用<code>lsof</code>命令获取持有lock file的进程的进程ID,依次运行如下命令:</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsof /var/lib/dpkg/locklsof /var/lib/apt/lists/locklsof /var/cache/apt/archives/lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是</p><p>以上命令执行结果如果无返回，说明没有正在运行的进程</p><p>如果返回了相应的进程，就需要kill掉。</p><p>删除所有的lock file</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo rm /var/lib/apt/lists/locksudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后重新配置一下dpkg：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo dpkg --configure -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果上述命令不出任何错误，就万事大吉了。</p><hr><p>但是有时候，执行配置命令时可能会出现以下错误：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">dpkg: error: dpkg frontend is locked by another process<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时需要找出正在锁定lock file的进程:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsof /var/lib/dpkg/lock-frontend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>kill掉输出的进程（如果输出为空则忽略）</p><pre class="line-numbers language-none"><code class="language-none">sudo kill -9 &lt;process id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除lock file并重新配置dpkg:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo rm /var/lib/dpkg/lock-frontendsudo dpkg --configure -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 报错排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成概述（1.概述）</title>
      <link href="/2022/04/19/computer_organization1/"/>
      <url>/2022/04/19/computer_organization1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="计算机组成原理——第一章"><a href="#计算机组成原理——第一章" class="headerlink" title="计算机组成原理——第一章"></a>计算机组成原理——第一章</h1><h2 id="1-1-计算机与案件的更新换代"><a href="#1-1-计算机与案件的更新换代" class="headerlink" title="1.1 计算机与案件的更新换代"></a>1.1 计算机与案件的更新换代</h2><ol><li><strong>摩尔定律</strong>：当价格不变，集成电路上可容纳的晶体管的数目，约每隔18个月便会增加一倍。也就是说，我们现在和18个月后花同样价钱买到的CPU，后者的性能是前者的2倍。</li><li><strong>半导体存储器的发展</strong>：1970年，仙童半导体公司产出第一个较大容量的半导体存储器。</li><li><strong>微处理机机器字长</strong>：32位和64位指的是机器字长。指<strong>计算机进行一次整数计算所能处理的二进制数据的位数</strong>。</li><li>*硬件发展：逻辑元件从电子管 -&gt; 晶体管 -&gt; 中小规模集成电路 -&gt; 大规模、超大规模集成电路</li></ol><h2 id="1-2-计算机系统硬件"><a href="#1-2-计算机系统硬件" class="headerlink" title="1.2 计算机系统硬件"></a>1.2 计算机系统硬件</h2><ul><li>系统软件（管理整个计算机系统，如操作系统<strong>OS</strong>、数据库管理系统<strong>DBMS</strong>、标准程序库、网络软件、服务程序）</li><li>应用软件（按任务需要编写的程序）</li><li>硬件是计算机物理基础。决定了计算机的 “天花板” 、“瓶颈”在哪，软件决定了我们可以把硬件性能发挥到什么程度。</li></ul><h3 id="1-2-1-计算机硬件"><a href="#1-2-1-计算机硬件" class="headerlink" title="1.2.1 计算机硬件"></a>1.2.1 计算机硬件</h3><h4 id="1-冯·诺依曼机的基本思想"><a href="#1-冯·诺依曼机的基本思想" class="headerlink" title="1. 冯·诺依曼机的基本思想"></a>1. 冯·诺依曼机的基本思想</h4><p>冯·诺依曼在研究<strong>EDVAC</strong>及时提出了“存储程序”的概念。特点如下：</p><ul><li>采用<strong>存储程序</strong>的结构，将指令以二进制代码的形式，事先输入计算机的主储存器，然后按其在储存器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</li><li>计算机硬件由运算器、存储器、控制器、输入设备、输出设备组成</li><li>指令和数据以同等地位存储在存储器中</li></ul><p><img src="https://s2.loli.net/2022/04/14/IOwrRx7jsXD3u29.png" alt="Schematic_diagram_of_von_Neumann_machine"></p><p>图中实线表示数据传输，虚线表示控制线以及反馈线</p><ul><li><p>输入设备：将信息转成及其能识别的形式</p></li><li><p>存储器：存数据和程序。存储器还分为<strong>主存和辅存</strong></p><ul><li>主存：内存</li><li>辅存：机械硬盘、固态硬盘等等。平时应用程勋存在辅存中，需要的时候才读入主存，所以辅存也算是一种I/O设备</li></ul></li><li><p>运算器：alu算数运算和逻辑运算</p></li><li><p>输出设备：将结果转成人们熟悉的形式</p></li><li><p>控制器：解析指令 &amp; 指挥程序运行</p></li><li><p>以上五个设备总和：硬件</p></li><li><p>数据程序：软件</p></li></ul><p>在计算机系统中，软件和硬件在逻辑上是等效的</p><ul><li>eg：乘法运算，可以设计专门的硬件电路去实现，也可以用软件执行多次加法来实现</li></ul><h4 id="2-冯·诺依曼机的特点"><a href="#2-冯·诺依曼机的特点" class="headerlink" title="2. 冯·诺依曼机的特点"></a>2. 冯·诺依曼机的特点</h4><ul><li><p>计算机有五大部件组成（输入输出设备统称<strong>I/O设备（input &amp; output）</strong>）</p></li><li><p>指令和数据，以同等地位存于存储器，可以用地址去寻访</p></li><li><p>指令和数据用二进制表示</p></li><li><p>指令有操作码和地址码组成</p></li><li><p>可以存储程序</p></li><li><p>以运算器为中心（这样会导致各种数据传输效率低下，所以线代计算机以存储器为中心，以下是原理图）</p></li></ul><p><img src="https://s2.loli.net/2022/04/14/4VwFux6RtiYblCj.png" alt="Schematic_diagram_of_modern_computer"></p><p>由于<strong>运算器</strong>和<strong>控制器</strong>之间逻辑关系十分紧密，所以在大规模集成电路工艺出现之后，这两个部件通常是整合在一个芯片上的，也就是我们现在的<strong>CPU</strong>。以下是简化原理图。</p><p><img src="https://s2.loli.net/2022/04/14/R9xEMKVUvYGLz8h.png" alt="Simplified_schematic_d_agram_of_computer"></p><p><strong>在计算机组成原理中，CPU和主存储器统称主机，而且并不是指平时日常生活中的电脑主机</strong></p><pre class="mermaid">graph LRA(硬件) --&gt;B(主机)B --&gt;B1(CPU)B --&gt;B2(主存)A --&gt;C(IO设备)C --&gt;C1(辅存)C --&gt;C2(输入设备)C --&gt;C3(输出设备)B2 --&gt;D(存储器)C1 --&gt;DB1 --&gt;E(运算器)B1 --&gt;F(控制器)</pre><h2 id="1-3-硬件各个部件"><a href="#1-3-硬件各个部件" class="headerlink" title="1.3 硬件各个部件"></a>1.3 硬件各个部件</h2><h3 id="1-主存储器"><a href="#1-主存储器" class="headerlink" title="1.主存储器"></a>1.主存储器</h3><p>MAR：地址寄存器</p><p>MDR：数据寄存器</p><p>线代计算机通常把MAR&amp;MDR集成在CPU内</p><pre class="mermaid">graph TBsubgraph memoryA[存储体] subgraph register    MAR(MAR地址寄存器)    MDR(MDR数据寄存器)endend</pre><p>在MAR给个地址，MAR去存储器寻找对应的数据，然后存放至MDR。可以类比为下图：</p><pre class="mermaid">graph TBsubgraph memoryA[仓库,机器人去找货物] subgraph register    MAR(MAR机器人,给机器人地址)     MDR(MDR柜台,机器人给你货物)endMAR --&gt;AA --&gt;MDRend</pre><p>其中，你要去取这个货物，就好比CPU要去取存储器的数据，从而完成整个数据访问过程。</p><p>如果要存数据，就把要存的数据放在MDR，对应地址给MAR，然后通过总线把数据存进存储体（仓库）。</p><ul><li><p>存储体</p><p>本身会被分为一个个的存储单元，按地址存储。</p><ul><li><p>存储单元：每个存储单元存放一串二进制代码，每个地址对应一个存储单元。</p></li><li><p>存储自（word）：存储单元中二进制代码的组合</p></li><li><p>存储字长：存储单元中二进制代码的位数，通常是8bit的整数倍</p></li><li><p>*存储元：存二进制的电容，每个存1bit</p></li><li><p>MAR位数反映存储单元的个数</p></li></ul></li><li><p>eg：MAR = 8 位 -&gt; 总共有 2的8次方 个存储单元</p><ul><li><p>MAR位数 = 存储字长</p></li><li><p>eg：MDR = 32位 -&gt; 每个存储单元可存放32bit，一个字 = 32 bit</p></li><li><p>字（word）和字节（byte）</p><p>一个字节（byte）= 8 bit</p><p>  1B = 一个字节，1b = 1个bit</p></li></ul></li></ul><h3 id="2-运算器"><a href="#2-运算器" class="headerlink" title="2. 运算器"></a>2. 运算器</h3><p>用于实现算术运算（加减乘除）和逻辑运算（与或非）</p><p>ACC: 累加器，用来存放操作数 / 运算结果</p><p>MQ: 乘商寄存器，惩处运算用来存放操作数 / 运算结果</p><p>x: 通用的 操作数寄存器，存放操作数</p><p>ALU: 算术逻辑单元，实现算术运算和逻辑运算</p><table><thead><tr><th align="center"></th><th align="center">加</th><th align="center">减</th><th align="center">乘</th><th align="center">除</th></tr></thead><tbody><tr><td align="center">ACC</td><td align="center">被加数、和</td><td align="center">被减数、差</td><td align="center">乘积高位</td><td align="center">被除数、余数</td></tr><tr><td align="center">MQ</td><td align="center"></td><td align="center"></td><td align="center">成熟、乘积低位</td><td align="center">商</td></tr><tr><td align="center">X</td><td align="center">加数</td><td align="center">减数</td><td align="center">被乘数</td><td align="center">除数</td></tr></tbody></table><h3 id="3-控制器"><a href="#3-控制器" class="headerlink" title="3. 控制器"></a>3. 控制器</h3><p>CU： 控制单元，分析指令，给出控制信号</p><p>IR：指令寄存器，存放当前执行的指令</p><p>PC：程序计数器，存放吓一跳指令的地址，有自动+1的功能</p><p>完成一条指令的流程：</p><ul><li>取指令：PC</li><li>分析指令：IR</li><li>执行指令：CU</li><li>指令：操作码 +地址码</li><li>OP(IR)：取操作码</li><li>Ad(IR)：取地址码<ul><li>CPU区分指令和数据的依据：指令周期的不同阶段</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/7s1virCB4IFyPWd.png" alt="schematic_diagram"></p><ul><li>运算器的核心部件是ALU，控制器的核心部件是CU。</li></ul><h2 id="1-4-计算机系统层次结构"><a href="#1-4-计算机系统层次结构" class="headerlink" title="1.4 计算机系统层次结构"></a>1.4 计算机系统层次结构</h2><p>代码需要翻译成机器语言，CPU在执行这些机器指令的时候，还需要细分为更细的小步骤来执行，这些小步骤称为<strong>微指令/微操作</strong>。</p><p>用微程序机器的微指令，逐步解析传统机器的每一条机器指令，并执行。</p><p>这样设计程序是很不方便的，所以现在出现了<strong>符号式程序设计语言</strong>，也就是<strong>汇编语言</strong>。识别汇编语言的机器叫<strong>虚拟机器</strong>。（因为虽然程序员看这台机器，好像可以直接识别汇编语言，但其实机器不可能真的识别出汇编语言，汇编语言必须先翻译成机器语言。才叫虚拟机器）</p><pre class="mermaid">graph TB    subgraph software    M4(M4虚拟机器--高级语言机器)    M3(M3虚拟机器--汇编语言机器)    M2(M2虚拟机器--操作系统机器)    end    subgraph hardware    M1(M1虚拟机器--机器语言机器)    M0(M0虚拟机器--微指令系统)    end    M4 --&gt;M3    M3 --&gt;M2     M2 --&gt;M1    M1 --&gt;M0</pre><p>翻译程序有以下三类：</p><ul><li><p>汇编程序：汇编器</p></li><li><p>解释程序：解释器</p></li><li><p>编译程序：编译器</p></li><li><p>汇编语言是一种 “助记符”，帮助人类记忆用的，本质上和机器语言是一一对应的。</p></li><li><p>高级语言需要先经过汇编，再翻译成机器语言。如果使用其他的库函数，还需要进行链接。使用编译程序</p></li><li><p>有的高级语言不是通过编译程序，而是用解释器，将程序翻译成与之对等的机器语言。很多脚本类的语言都是使用解释器，python、JavaScript，shell等等。</p></li><li><p>编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言，而后在执行机器语言程序（只能翻译一次）</p><p>会生成可执行文件，如 <code>*.exe</code>程序等等。</p></li><li><p>解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行，紧接着再翻译下一句（每次执行都需要翻译）</p></li><li><p>编译型的执行效率更高一些，解释性的执行效率更低一些。</p></li><li><p>编译、汇编、解释程序，可统称为 <strong>翻译程序</strong>。</p></li><li><p>*计算机体系结构学习的是：如何设计硬件与软件之间的接口</p><p>计算机组成原理学习的是：如何用硬件实现所定义的接口</p></li></ul><h2 id="1-5-计算机性能指标"><a href="#1-5-计算机性能指标" class="headerlink" title="1.5 计算机性能指标"></a>1.5 计算机性能指标</h2><h3 id="1-主储存器的性能指标"><a href="#1-主储存器的性能指标" class="headerlink" title="1 主储存器的性能指标"></a>1 主储存器的性能指标</h3><ul><li><p><strong>MAR</strong>位数反映<strong>存储单元</strong>，<code>最多</code>支持的个数，可支持 2的MAR次方</p></li><li><p><strong>MDR</strong>位数=存储字长=每个存储单元的大小</p></li><li><p><strong>总容量 = 存储单元个数 * 存储字长 bit = 存储单元个数 *存储字长 / 8 Byte</strong>，<code>1 Byte = 8 bit</code></p><p>eg：MAR=32位，MDR=8位，总容量 = 2^32 * 8 bit = 4GB</p></li></ul><p>$$<br>K=2^{10}\\M=2^{20}\\G=2^{30}\\T=2^{40}<br>$$</p><h3 id="2-cpu的性能指标"><a href="#2-cpu的性能指标" class="headerlink" title="2 cpu的性能指标"></a>2 cpu的性能指标</h3><ul><li>cpu的时钟周期：<br>把CPU的每一个脉冲信号的时间周期叫做<strong>cpu的时钟周期</strong>，单位是微秒或纳秒。</li></ul><p>$$<br>CPU主频（时钟频率） = \frac{1}{CPU时钟周期}<br>$$</p><ul><li><p><strong>CPI（Clock cycle Per Instruction）</strong>：执行一条指令所需的时间周期数</p><p>不同的指令，不同的CPI；甚至相同的指令，CPI也可能不同</p></li></ul><p>$$<br>执行一条指令的耗时 = \frac{CPI}{CPU的时钟周期} \\<br>CPU执行时间(整个程序耗时) = \frac{CPU时钟周期}{主频} = \frac{(指令条数*CPI)}{主频}<br>$$</p><ul><li><p><strong>IPS  (Instructions Per Second)</strong> :<code>每秒</code>执行多少条指令</p><ul><li>可细分为<code>KIPS</code>，<code>MIPS</code><br>$$<br>IPS = \frac{主频}{平均CPI}<br>$$</li></ul></li><li><p><strong>FLOPS  (Floating-point Operations Per Second)</strong> 每秒执行多少次<strong>浮点运算</strong></p><ul><li>可细分为<code>KFLOPS</code>，<code>MFLOPS</code>, <code>GFLOPS</code>，<code>TFLOPS</code></li></ul></li><li><p>此处K、M、G、T为数量单位，<strong>要与文件大小的指标区分开</strong><br>$$<br>K=kilo=10^3  \\ M=million=10^6 \\ G=giga=10^9 \\ T=tera=10^{12}<br>$$</p></li></ul><h3 id="3-系统整体的性能指标"><a href="#3-系统整体的性能指标" class="headerlink" title="3 系统整体的性能指标"></a>3 系统整体的性能指标</h3><ul><li><p>数据通路带宽：数据总线一次所能并行传送的信息的位数（各个硬件部件通过数据总线传输数据）</p></li><li><p>吞吐量：指系统在单位时间内处理请求的数量</p></li><li><p>响应时间：指从用户向计算机发送一个请求，到系统对这个请求作出响应，并获得它所需的结果 的等待时间</p></li><li><p>基准程序（跑分软件）：用来测量计算机处理速度的一种程序。</p><p>便于被测量的计算机性能可以与运行相同的程序的其他计算机性能进行比较</p></li></ul><p>思考问题:</p><ul><li>Q：主频高的CPU一般比主频低的CPU快吗？</li><li>A：不一定，需要看CPI，以及不同指令系统<br>(如果指令系统做过优化，即使主频和CPI不占优势，也有可能在某个方面性能更强)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述(2.2处理机调度)</title>
      <link href="/2022/04/19/operating_system2-2/"/>
      <url>/2022/04/19/operating_system2-2/</url>
      
        <content type="html"><![CDATA[<h1>操作系统——2.2 处理机调度</h1><h2 id="一、基本概念-4">一、基本概念</h2><p>进程调度（低级调度），就是按照某种算法，从就绪队列中，选择一个进程，为其分配处理机。</p><p>当有一堆任务要处理的时候，由于资源有限，这些事情没办法同时处理，这就需要确定某种规则来决定处理这些任务的顺序，这就是<strong>调度</strong>研究的问题。</p><p>一些概念的介绍：</p><ul><li>作业：一个具体的运行任务</li><li>用户向系统提交一个作业 <strong>≈</strong>用户让操作系统启动一个程序（来处理一个具体的任务）</li></ul><h3 id="1-1高级调度（作业调度）-4">1.1高级调度（作业调度）</h3><p>按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入会建立PCB，调出时才撤销PCB。</p><ul><li>简单理解就是：好几个程序需要启动，这个调度方式要确定先调度哪个。</li><li>***作业控制块（JCB）：**操作系统想用户提供的一组作业控制语言，用户将这种语言写作业说明书，然后程序、数据和作业一起交给系统操作员。</li><li>*多道批处理系统通常配有作业调度，其他系统中通常不需要配置作业调度。</li></ul><h3 id="1-2-中级调度（内存调度）-4">1.2 中级调度（内存调度）</h3><p>按照某种策略决定将那个处于挂起状态的进程重新调入内存。</p><ul><li><p>引入中级调度的目的是提高内存利用率和系统吞吐量。</p></li><li><p>内存不够时，可将那些暂时用不上的进程调度至外存等待，等内存空闲或者进程需要运行的时候再重新调入内存。</p></li><li><p>此时进程状态为<strong>挂起态</strong>，被挂起的进程PCB会被组织成<strong>挂起队列</strong>。</p></li></ul><p>中级调度实际上是存储器管理中的对换功能。</p><ul><li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率比高级调度更高。</li></ul><h3 id="1-3-低级调度（进程调度-处理机调度）-4">1.3 低级调度（进程调度 / 处理机调度）</h3><p>按照某种策略，从就绪队列中选取一个进程，将处理机分配给它。</p><p>这是一种最基本的调度，调用频率最高。</p><h3 id="1-4-进程的挂起-4">1.4 进程的挂起</h3><p>被挂起的进程称为 <u>挂起态（suspend）</u></p><p>挂起态可以进一步分为<strong>就绪挂起</strong>和<strong>阻塞挂起</strong>。</p><ul><li>进程在就绪态可以挂起为就绪挂起，就绪挂起可以激活为就绪态</li><li>进程在阻塞态可以挂起为阻塞挂起，阻塞挂起可以激活为阻塞态</li><li>阻塞挂起可以在事件出现的时候变成就绪挂起</li><li>并且，在创建态和运行态的进程，也可以直接挂起为就绪挂起</li></ul><p><strong>！挂起和阻塞的区别：</strong></p><ul><li>两种状态都是参数不能获得CPU的服务的</li><li><strong>挂起态</strong>是将进程调到外存去了，<strong>阻塞态</strong>下的进程还在内存中。</li><li>有的操作系统会把<strong>就绪挂起</strong>，<strong>阻塞挂起</strong>分为两个挂起队列，甚至会根据阻塞原因不同，把挂起队列细分为多个队列。</li></ul><table><thead><tr><th>调度</th><th>调度发生在</th><th>发生频率</th><th>对进程状态的影响</th></tr></thead><tbody><tr><td>高级调度（作业调度）</td><td>外存-&gt;内存（面向作业）</td><td>最低</td><td>无-&gt;创建态-&gt;就绪态</td></tr><tr><td>中级调度（内存调度）</td><td>外存-&gt;内存（面向进程）</td><td>中等</td><td>挂起态-&gt;就绪态（阻塞挂起-&gt;阻塞态）</td></tr><tr><td>低级调度（进程调度）</td><td>内存-&gt;CPU</td><td>最高</td><td>就绪态-&gt;运行态</td></tr></tbody></table><h2 id="二、进程调度方式-4">二、进程调度方式</h2><h3 id="2-1进程调度的时机-4">2.1进程调度的时机</h3><p><strong>！<strong>什么时候</strong>需要</strong>进程调度</p><ul><li><p>当前运行的进程<strong>主动放弃</strong>处理机</p><ul><li>进程终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（如：等待IO）</li><li>有的系统中，只允许进程主动放弃处理机</li></ul></li><li><p>当前运行的进程<strong>被动放弃</strong>处理机</p><ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如：IO中断）</li><li>有更高优先级的进程进入就绪队列<ul><li>有的系统中，当有更紧急的任务需要处理的时候，也会强行剥夺处理机（被动放弃）</li></ul></li></ul></li></ul><p><strong>！<strong>什么时候</strong>不能</strong>进程调度</p><ul><li><strong>处理中断的过程中</strong>：处理中断过程复杂，与硬件密切相关，很难在冲段处理的时候进行进程切换</li><li>进程在<strong>操作系统内核程序临界区中</strong>。但是进程在普通临界区中是可以进行调度和切换的。</li><li>在<strong>原子操作过程中（原语）</strong>。原子操作不可中断（如修改PCB中进程状态标志，并放置在相应队列）</li></ul><p><strong>！eg：<strong>进程在</strong>操作系统内核临界区</strong>中<strong>不能</strong>进行调度切换（√）</p><p><strong>！eg：<strong>进程处于</strong>临界区</strong>时<strong>不能</strong>进行处理机调度（×）</p><p><strong>！临界资源：<strong>一个时间段内只允许一个进程使用的资源。个进程需要</strong>互斥地</strong>访问临界资源。</p><p>**！临界    区：**访问临界资源的那段代码。</p><p><strong>内核程序临界区</strong>一般是用来访问<strong>某种内核数据结构的</strong>，比如说进程的就绪队列（由各个就绪进程的PCB组成）</p><ul><li>举个栗子：</li></ul><p>比如有一个内核进程，要访问就绪队列</p><pre class="mermaid">graph LRA(进程) --&gt;B(就绪队列)</pre><p>那就需要先锁住<span class="github-emoji"><span>🔒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f512.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>就绪队列 。如果还没退出临界区（还没解锁）就进行进程调度，但经常调度相关程序也需要访问就绪队列，此时就绪队列又被锁住了，因此有无法顺利进行进程调度。</p><p>由此可见，内核程序临界区访问的临界资源，如果不尽快释放，很有可能因此影响到操作系统内核的其他管理工作。所以，访问内核程序临界区期间不可以进行调度与切换。</p><ul><li>再举个栗子：</li></ul><p>有一个进程要控制打印机，在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但是打印机是慢速的设备，如果一直不允许进程调度，会导致CPU一直空闲。</p><p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。访问普通临界区时可以进行调度与切换。</p><h3 id="2-1-进程调度的方式-4">2.1 进程调度的方式</h3><h5 id="非剥夺方式（非抢占方式）-4">非剥夺方式（非抢占方式）</h5><p>只允许进程主动放弃处理机，如果运行过程中有更紧迫的任务到达，当前进程还会继续使用处理机，直到该进程终止或主动进入阻塞态。</p><ul><li>实现简单，系统开销小，但无法及时处理紧急任务。适用早期的批处理系统。</li></ul><h5 id="剥夺方式（抢占方式）-4">剥夺方式（抢占方式）</h5><p>当一个进程正在处理机上执行时，如果有一个更重要的任务到达，则立即暂停正在执行的进程，将处理机分配给那个紧迫的进程。</p><ul><li>可以优先处理更紧急的进程，也可以让各个进程按时间片轮流执行的功能（通过使用时钟中断）。适用于分时操作系统，实时操作系统。</li></ul><h5 id="细分进程调度-4">细分进程调度</h5><ul><li><p>狭义的进程调度：从就绪队列中选中一个要运行的进程</p></li><li><p>广义的进程调度：包含了选择进程和进程切换两个步骤</p><ul><li>对原来运行的进程的数据进行保存</li><li>对新进程的数据恢复（通常这些信息保存在PCB）</li><li>！进程切换是有代价的。因此如果过于频繁的进行进程调度、切换，必然会降低整个系统的运行效率。并不是调度越频繁、并发度越高</li></ul></li></ul><h2 id="三、调度算法的评价指标-4">三、调度算法的评价指标</h2><h3 id="1-CPU利用率：-4">1 CPU利用率：</h3><ul><li>CPU处于忙碌的时间占总时间的比例。</li></ul><p>$$<br>利用率 = \frac{有效工作的时间}{总时间 – 空闲+工作的时间}<br>$$</p><h3 id="2-系统吞吐量：-4">2 系统吞吐量：</h3><ul><li>单位时间内完成的作业数量</li></ul><p>$$<br>系统吞吐量 = \frac{总完成的作业数量}{总共花费的时间}<br>$$</p><h3 id="3-周转时间：-4">3 周转时间：</h3><ul><li>作业提交给系统开始，到作业完成为止的时间间隔</li></ul><p>包括四个部分：</p><ul><li>作业在外存后备队列等待调度的时间（高级调度）</li><li>进程在就绪队列上等待调度的时间（低级调度）</li><li>进程上CPU执行的时间</li><li>进程等待I/O操作完成的时间<ul><li>其中后三项在作业整个处理的过程中，可能发生多次</li></ul></li></ul><p>$$<br>作业周转时间 = 作业完成时间 - 作业提交时间 \\<br>平均周转时间 = \frac{\sum_{i=1}^n作业n的周转时间}{作业数} \\<br>带权周转时间 = \frac{作业周转时间}{作业实际运行时间} \\ = \frac{作业完成时间 - 作业提交时间}{作业实际运行时间}\\<br>平均带权周转时间 = \sum_{i=1}^n 作业n的带权周转时间<br>$$</p><p>其中，带权周转时间可以理解为：周转时间比运行时间大多少倍。如果带权周转时间太大，说明原本只需要少量时间让CPU为其服务，却让他等待了很长的时间。</p><h3 id="4-等待时间：-4">4 等待时间：</h3><ul><li>指进程/作业<strong>处于等待处理机窗台时间之和</strong>。等待时间越长，用户满意度越低。</li></ul><p>因为处理机调度算法不影响作业执行或者I/O时间，只影响作业在就绪队列中等待所花的时间。</p><p>因此，衡量一个调度算法的优劣，只需要简单的看等待时间。</p><ul><li>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>。等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li><li>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后等待的时间，还要加上作业在外存后备队列中等待的时间</strong>。</li><li>一个作业总共需要被CPU服务多久，被I/O设备服务多久，一般情况下，是确定不变的。调度算法值影响作业、进程的等待时间。我们也可以使用<strong>平均等待时间</strong>来评价整体性能。</li></ul><h3 id="5-响应时间-4">5 响应时间</h3><ul><li>指用户提交请求到首次产生响应所使用的时间</li></ul><h2 id="四、调度算法-4">四、调度算法</h2><h3 id="1、先来先服务——FCFS-4">1、先来先服务——FCFS</h3><h4 id="1-算法思想-19">1 算法思想</h4><p>主要从<strong>公平</strong>的角度去考虑（类比食堂排队打饭的例子）</p><h4 id="2-算法规则-19">2 算法规则</h4><p>按照作业/进程到达的先后顺序进行服务</p><h4 id="3-用于作业-进程调度-19">3 用于作业/进程调度</h4><p>作业调度：考虑的是哪个作业先到达后备队列</p><p>进程调度：考虑的是哪个进程先到达就绪队列</p><h4 id="4-是否可抢占-19">4 是否可抢占</h4><p>使用非抢占式算法</p><h4 id="5-优缺点-16">5 优缺点</h4><ul><li>优点：公平，实现简单</li><li>缺点：排在长作业/进程后面的短作业需要等待很长的时间，带权周转时间很大，对短作业用户来说，体验不好。</li><li>总结：FCFS<strong>对长作业有利，对短作业不利</strong>。</li></ul><h4 id="6-是否会导致饥饿-19">6 是否会导致饥饿</h4><p>不会。排在前面的作业总会处理完。</p><ul><li>饥饿的概念：某个作业或者进程长时间得不到服务</li></ul><h3 id="2、短作业优先——SJF-4">2、短作业优先——SJF</h3><h4 id="1-算法思想-20">1 算法思想</h4><p>追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</p><h4 id="2-算法规则-20">2 算法规则</h4><p>最短的作业/进程优先得到服务（指要求服务的时间最短）</p><h4 id="3-用于作业-进程调度-20">3 用于作业/进程调度</h4><p>两种都可以用。对进程来说，叫**短进程优先（SPF，shortest process first）**算法</p><h4 id="4-是否可抢占-20">4 是否可抢占</h4><p>SJF和SPF是非抢占式的算法。但也有抢占式的版本，叫<strong>最短剩余时间优先算法（SRTN Shortest Remaining Time Next）</strong></p><ul><li><p>SRTN：当有进程<strong>加入就绪队列改变时就需要调度</strong>。如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间更短，则由新进程<strong>抢占</strong>处理机。当前运行进程重新回到就绪队列。</p><p><strong>! 另外</strong>，当一个进程完成时<sup class="refplus-num"><a href="#ref-f">[1]</a></sup>也需要用这种算法进行调度。  </p><ul id="refplus" style="display:none;"><li id="ref-f" data-num="1">[1]  进程主动放弃处理机的时候</li></ul><p></p></li><li><p>细节：</p><ul><li><p>平时讨论短作业优先默认是<code>SJF / SPF</code>，是非抢占式的</p></li><li><p>其实<code>SRTN</code>比<code>SJF</code>的平均的等待时间，平均周转时间要更少。</p><p>应该说：<strong>在所有进程同时可运行时</strong>，或者<strong>在所有进程都几乎同时到达的时候</strong>，采用<code>SJF</code>调度算法的平均等待时间，平均周转时间最少。</p></li><li><p>一般来说，<code>SJF</code>的平均等待时间和平均周转时间，比除了SRTN以外的算法（如FCFS）要更少。</p></li><li><p>不过说<code>SJF</code>是平均等待时间，平均周转时间最少，仍然是不够严谨的</p></li></ul></li></ul><h4 id="5-优缺点-17">5 优缺点</h4><ul><li>优点：“最短的” 平均等待时间、平均周转时间</li><li>缺点：<ul><li>不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿</strong>现象。</li><li>作业/进程的运行时间，是由用户提供的，并不一定完全准确，不一定真正可以实现短作业优先。</li><li>该算法完全没有考虑作业的紧迫程度，不能保证紧迫性作业会被及时处理。</li></ul></li></ul><h4 id="6-是否会导致饥饿-20">6 是否会导致饥饿</h4><p>会。如果源源不断有大量短作业/进程到来，可能会使长作业很长时间都得不到服务。产生饥饿现象。</p><p>如果一直得不到服务，则称之为 “饿死”。</p><h3 id="3、高响应比优先——HRRN-4">3、高响应比优先——HRRN</h3><h4 id="1-算法思想-21">1 算法思想</h4><p>综合考虑 作业/进程 的等待时间和要求服务的时间。</p><h4 id="2-算法规则-21">2 算法规则</h4><p>在每次调度时，先计算各个 作业/进程 的<strong>响应比</strong>，选择<strong>响应比最高的</strong> 作业/进程 为其服务。<br>$$<br>响应比 = \frac{等待时间+要求服务时间}{要求服务时间}<br>\geq 1<br>$$</p><h4 id="3-用于作业-进程调度-21">3 用于作业/进程调度</h4><p>都可以使用</p><h4 id="4-是否可抢占-21">4 是否可抢占</h4><p>非抢占式算法，只有当前运行中的作业或进程<strong>主动放弃处理机时</strong>，才需要调度，才需要计算响应比。调度时<strong>计算所有就绪进程的响应比，选中响应比最高的</strong>进程上处理机。</p><h4 id="5-优点-4">5 优点</h4><ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比夜壶越来越大，从而避免了长作业饥饿的问题。</li></ul><h4 id="6-是否会导致饥饿-21">6 是否会导致饥饿</h4><p>不会</p><ul><li>以上三种算法总结</li></ul><p>这几种算法主要关心对用户的公平性，平均周转时间，平均等待时间等评价系统性能的指标。但是不关心 “响应时间” ，也不区分任务的紧急程度。</p><p>因此，对用户来说，交互性很差，这三种算法一般适用于<strong>早期的批处理系统</strong>。</p><p>当然，<code>FCFS</code>也常结合其他算法使用。</p><h3 id="4、时间片轮转（RR-Round-Robin）-4">4、时间片轮转（RR, Round-Robin）</h3><h4 id="1-算法思想-22">1 算法思想</h4><p>公平地、轮流地为各个进程服务，让每个进程在一定时间内都可以得到响应</p><p><strong>！常用于分时操作系统，更注重 “响应时间”</strong></p><h4 id="2-算法规则-22">2 算法规则</h4><p>按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个<strong>时间片</strong>。</p><p>若进程未在一个时间片内执行完，则剥夺处理机，将进程程序放到就绪队列队尾重新排队。</p><p><strong>！时间片划分需要注意：</strong></p><ul><li><p>如果时间片太大：</p><p>使每个进程在一个时间片内就可以完成。则该算法会退化成FCFS（先到先服务）算法，并增大进程响应时间。</p></li><li><p>如果时间片太小：</p><p>会导致进程切换过于频繁，系统要花大量的时间来处理进程切换。从而导致实际用于进程执行的时间比例减少。</p></li><li><p>* 一般来说设计时间片时需要让切换进程的开销比例不超过 1%。</p></li></ul><h4 id="3-用于作业-进程调度-22">3 用于作业/进程调度</h4><p>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</p><h4 id="4-是否可抢占-22">4 是否可抢占</h4><p>抢占式算法。</p><p>若进程未能在时间片内运行完，将被强制剥夺处理机使用权。</p><p>由时钟装置发出的<strong>时钟中断</strong>来通知CPU时间片已到时。</p><h4 id="5-优缺点-18">5 优缺点</h4><ul><li><p>优点：</p><p>公平，响应快，适用于分时操作系统</p></li><li><p>缺点：</p><ul><li><p>由于高频率的进程切换，因此有一定的开销</p></li><li><p>不区分任务紧急程度</p></li></ul></li></ul><h4 id="6-是否会导致饥饿-22">6 是否会导致饥饿</h4><p>不会</p><h3 id="5、优先级调度算法-4">5、优先级调度算法</h3><h4 id="1-算法思想-23">1 算法思想</h4><p>实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</p><h4 id="2-算法规则-23">2 算法规则</h4><p>给每一个 作业/进程 各自的优先级，调度的时候选择优先级最高的 作业/进程 。</p><h4 id="3-用于作业-进程调度-23">3 用于作业/进程调度</h4><p>可用于作业调度、进程调度、以及I/O调度。</p><h4 id="4-是否可抢占-23">4 是否可抢占</h4><p>抢占式&amp;非抢占式。</p><p>区别：</p><ul><li>非抢占式只需在进程主动放弃处理机时进行调度即可</li><li>抢占式还需在就绪队列变化时，检查是否会发生进程之间的抢占</li></ul><p>要注意的是，就绪队列未必只有一个，可以按照优先级不同来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。</p><ul><li><p>优先级</p><ul><li><p>静态优先级：光剑进程时候确定的，之后一直不变</p><ul><li><p>通常来说：</p><ul><li><p>系统进程优先级 高于 用户进程</p></li><li><p>前台进程优先级 高于 后台进程</p></li><li><p>操作系统更偏好I/O型进程（I/O繁忙型进程）</p><p>I/O设备可以和CPU设备并行工作。</p><p>让I/O设备尽早投入工作，资源利用率、系统吞吐量会得到提升。</p></li><li><p>与I/O型进程先对的是<strong>计算型进程（CPU繁忙进程）</strong></p></li></ul></li></ul></li><li><p>动态优先级：创建的时候有个初始值，之后会根据情况动态地调整优先级</p><ul><li>如果进程在就绪队列中等待很长时间，就可以适当提升优先级</li><li>如果进程占用处理机很长时间，则可以适当降低优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可以适当提升优先级</li></ul></li></ul></li></ul><h4 id="5-优缺点-19">5 优缺点</h4><ul><li><p>优点：</p><p>用优先级区分任务紧急程度。适用于实时操作系统。可以灵活地调整对各个 作业/进程 的偏好程度</p></li><li><p>缺点</p><p>如果源源不断的有高优先级的进程进来，可能会导致饥饿</p></li></ul><h4 id="6-是否会导致饥饿-23">6 是否会导致饥饿</h4><p>会</p><h3 id="6、多级反馈队列-4">6、多级反馈队列</h3><h4 id="1-算法思想-24">1 算法思想</h4><p>对其他调度算法的整理集中</p><h4 id="2-算法规则-24">2 算法规则</h4><ol><li><p>设置多个就绪队列</p><p><strong>各级队列优先级 从高到低，时间片 从小到大</strong></p></li><li><p>新进程到大时，先进入1级队列，按<code>FCFS</code>原则排队等待被分配。</p><p>若用完时间片进程还未结束，则进入下一级队列的队尾。</p><p>如果此时已经在最下级的队列，则重新放回该队队尾。</p></li><li><p>只有第k级队列为空时，才会为k+1级的队列分配时间片</p></li></ol><h4 id="3-用于作业-进程调度-24">3 用于作业/进程调度</h4><p>用于进程调度</p><h4 id="4-是否可抢占-24">4 是否可抢占</h4><p>抢占式算法。</p><p>在k级队列的进程运行过程中，若更上级的队列中进了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p><h4 id="5-优缺点-20">5 优缺点</h4><ul><li><p>优点：</p><ul><li><p>对各类型进程相对公平（FCFS的优点）</p></li><li><p>每个新到达的进程都苦很快得到响应（RR的优点）</p></li><li><p>短进程只用较少的时间就可以完成（SPF的优点）</p></li><li><p>不比实现估计进程的运行时间（避免用户提供的运行时间不准确）</p></li><li><p>可以灵活地调整对各类进程的偏好程度，比如CPU密集型进程，I/O密集型进程</p><p>（可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高的优先级）</p></li></ul></li><li><p>缺点：</p><p>可能会导致饥饿</p></li></ul><h4 id="6-是否会导致饥饿-24">6 是否会导致饥饿</h4><p>会</p><p>如果源源不断有短进程进入队列，可能会导致饥饿</p><ul><li>后三种算法适用于交互式的系统（比如Unix就是使用多级反馈队列调度算法）</li></ul>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机知识 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy 总结笔记</title>
      <link href="/2022/04/17/numpy-summary/"/>
      <url>/2022/04/17/numpy-summary/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="numpy-总结笔记"><a href="#numpy-总结笔记" class="headerlink" title="numpy 总结笔记"></a>numpy 总结笔记</h1><p>偶然翻到一篇以前整理的numpy笔记，由于数据分析是人工智能很重要很基础的内容，因此稍作整理和大家共享</p><h2 id="一、Ndarray-对象"><a href="#一、Ndarray-对象" class="headerlink" title="一、Ndarray 对象"></a>一、Ndarray 对象</h2><p>ndarray 内部由以下内容组成：</p><ul><li><p>一个指向数据（内存 | 内存映射文件中的一块数据）的指针。</p></li><li><p>数据类型或 dtype，描述在数组中的 固定大小值的格子。</p></li><li><p>一个表示数组形状（shape）的元组，表各维度大小的元组。</p></li><li><p>一个跨度元组（stride），其中的整数指的是 为了前进到当前维度 下一个元素需要”跨过”的字节数。</p></li></ul><p> <img src="https://s2.loli.net/2022/04/17/D6L4eZEcpbjw1AR.png" alt="np-nparray"></p><p>跨度可以是负数，这样会使数组在内存中后向移动，切片中 obj[::-1] 或 obj[:,::-1] 就是如此。</p><p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p><p><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p><p>参数说明：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>object</strong></td><td>数组或嵌套的数列</td></tr><tr><td><strong>dtype</strong></td><td>数组元素的数据类型，可选</td></tr><tr><td><strong>copy</strong></td><td>对象是否需要复制，可选</td></tr><tr><td><strong>order</strong></td><td>创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td></tr><tr><td><strong>subok</strong></td><td>默认返回一个与基类类型一致的数组</td></tr><tr><td><strong>ndmin</strong></td><td>指定生成数组的最小维度</td></tr></tbody></table><h2 id="二、NumPy-数据类型"><a href="#二、NumPy-数据类型" class="headerlink" title="二、NumPy 数据类型"></a>二、NumPy 数据类型</h2><h3 id="1）：基本数据类型"><a href="#1）：基本数据类型" class="headerlink" title="1）：基本数据类型"></a>1）：基本数据类型</h3><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>bool_</td><td>布尔型数据类型（True 或者 False）</td></tr><tr><td>int_</td><td>默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td></tr><tr><td>intc</td><td>与 C 的 int 类型一样，一般是 int32 或 int 64</td></tr><tr><td>intp</td><td>用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td></tr><tr><td>int8</td><td>字节（-128 to 127）</td></tr><tr><td>int16</td><td>整数（-32768 to 32767）</td></tr><tr><td>int32</td><td>整数（-2147483648 to 2147483647）</td></tr><tr><td>int64</td><td>整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td>uint8</td><td>无符号整数（0 to 255）</td></tr><tr><td>uint16</td><td>无符号整数（0 to 65535）</td></tr><tr><td>uint32</td><td>无符号整数（0 to 4294967295）</td></tr><tr><td>uint64</td><td>无符号整数（0 to 18446744073709551615）</td></tr><tr><td>float_</td><td>float64 类型的简写</td></tr><tr><td>float16</td><td>半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td>float32</td><td>单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td>float64</td><td>双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td>complex_</td><td>complex128 类型的简写，即 128 位复数</td></tr><tr><td>complex64</td><td>复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td>complex128</td><td>复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><ul><li><p>numpy 的数值类型实际上是 dtype 对象的实例，并且对应唯一的字符，如 np.bool_，np.int32，np.float32，等等。</p></li><li><p>int8, int16, int32, int64 四种数据类型可以使用字符串 ‘i1’, ‘i2’,’i4’,’i8’ 代替</p></li></ul><h3 id="2）：数据类型对象dtype"><a href="#2）：数据类型对象dtype" class="headerlink" title="2）：数据类型对象dtype"></a>2）：数据类型对象dtype</h3><p>dtype 对象使用以下语法构造：</p><p><code>numpy.dtype(object, align, copy)</code></p><ul><li><p>object 要转换为的数据类型对象</p></li><li><p>align    如果为 true，填充字段使其类似 C 的结构体。</p></li><li><p>copy    复制 dtype 对象 ，若为 false，则是对内置数据类型对象的引用</p></li></ul><p>每个内建类型都有一个唯一定义它的字符代码，如下：        </p><table><thead><tr><th>字符</th><th>对应类型</th></tr></thead><tbody><tr><td>b</td><td>布尔型</td></tr><tr><td>i</td><td>(有符号) 整型</td></tr><tr><td>u</td><td>无符号整型 integer</td></tr><tr><td>f</td><td>浮点型</td></tr><tr><td>c</td><td>复数浮点型</td></tr><tr><td>m</td><td>timedelta（时间间隔）</td></tr><tr><td>M</td><td>datetime（日期时间）</td></tr><tr><td>O</td><td>(Python) 对象</td></tr><tr><td>S, a</td><td>(byte-)字符串</td></tr><tr><td>U</td><td>Unicode</td></tr><tr><td>V</td><td>原始数据 (void)</td></tr></tbody></table><p>实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(np.dtype(np.int32))&gt;int32print(np.dtype('i4'))&gt;int32print(np.dtype('&lt;i4'))&gt;int32print(np.dtype([('age',np.int8)]))&gt;[('age', 'i1')]dt = np.dtype([('age',np.int8)]) print(np.array([(10,),(20,),(30,)], dtype = dt))&gt;[(10,) (20,) (30,)]dt = np.dtype([('age',np.int8)]) a = np.array([(10,),(20,),(30,)], dtype = dt) print(a['age'])&gt;[10 20 30]student = np.dtype([('name','S20'), ('age', 'i1'), ('marks', 'f4')]) print(student)&gt;[('name', 'S20'), ('age', 'i1'), ('marks', 'f4')]student = np.dtype([('name','S20'), ('age', 'i1'), ('marks', 'f4')]) print(np.array([('abc', 21, 50),('xyz', 18, 75)], dtype = student))&gt;[('abc', 21, 50.0), ('xyz', 18, 75.0)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><h3 id="1）：数组属性"><a href="#1）：数组属性" class="headerlink" title="1）：数组属性"></a>1）：数组属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>ndarray.ndim</td><td>秩，即轴的数量或维度的数量</td></tr><tr><td>ndarray.shape</td><td>数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td>ndarray.size</td><td>数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td>ndarray.dtype</td><td>ndarray 对象的元素类型</td></tr><tr><td>ndarray.itemsize</td><td>ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td>ndarray.flags</td><td>ndarray 对象的内存信息</td></tr><tr><td>ndarray.real</td><td>ndarray 元素的实部</td></tr><tr><td>ndarray.imag</td><td>ndarray 元素的虚部</td></tr><tr><td>ndarray.data</td><td>包含实际数组元素的缓冲区由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr><tr><td>ndarray.reshape</td><td>ndarray重新分配大小，包括秩等等都可以变换</td></tr></tbody></table><p>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>C_CONTIGUOUS (C)</td><td>数据是在一个单一的C风格的连续段中</td></tr><tr><td>F_CONTIGUOUS (F)</td><td>数据是在一个单一的Fortran风格的连续段中</td></tr><tr><td>OWNDATA (O)</td><td>数组拥有它所使用的内存或从另一个对象中借用它</td></tr><tr><td>WRITEABLE (W)</td><td>数据区域可以被写入，将该值设置为 False，则数据为只读</td></tr><tr><td>ALIGNED (A)</td><td>数据和所有元素都适当地对齐到硬件上</td></tr><tr><td>UPDATEIFCOPY (U)</td><td>这个数组是其它数组的一个副本当这个数组被释放时，原数组的内容将被更新</td></tr></tbody></table><p>实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x = np.array([1,2,3,4,5]) print (x.flags)&gt;C_CONTIGUOUS : True&gt;F_CONTIGUOUS : True&gt;OWNDATA : True&gt;WRITEABLE : True&gt;ALIGNED : True&gt;WRITEBACKIFCOPY : False&gt;UPDATEIFCOPY : Falsea = np.array([[1,2,3],[4,5,6]]) a.shape = (3,2) print (a)&gt;[[1 2]  [3 4]  [5 6]]# 数组的 dtype 为 int8（一个字节） x = np.array([1,2,3,4,5], dtype = np.int8) print (x.itemsize) # 数组的 dtype 现在为 float64（八个字节） y = np.array([1,2,3,4,5], dtype = np.float64) print (y.itemsize)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>一个元素类型为float64的数组，itemsize属性值为8(float64占用64个bits，每个字节长度为8，所以64/8占用 8 个字节）</p></li><li><p>一个元素类型为complex32的数组item属性为4（32/8）</p></li></ul><h3 id="2）：创建数组"><a href="#2）：创建数组" class="headerlink" title="2）：创建数组"></a>2）：创建数组</h3><p><code>numpy.zeros(shape, dtype = float, order = 'C')</code></p><p><code>numpy.ones(shape, dtype = None, order = 'C')</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 默认为浮点数 x = np.ones(5) print(x) # 设置类型为整数 y = np.zeros((5,), dtype = np.int) print(y) # 自定义类型 z = np.zeros((2,2), dtype = [('x', 'i4'), ('y', 'i4')]) print(z)# 输出[1. 1. 1. 1. 1.][0 0 0 0 0][[(0, 0) (0, 0)] [(0, 0) (0, 0)]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）：从已有的数组创建数组"><a href="#3）：从已有的数组创建数组" class="headerlink" title="3）：从已有的数组创建数组"></a>3）：从已有的数组创建数组</h3><h4 id="1、asarray"><a href="#1、asarray" class="headerlink" title="1、asarray"></a>1、asarray</h4><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>任意形式的输入参数，可以是 列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</td></tr><tr><td>dtype</td><td>数据类型，可选</td></tr><tr><td>order</td><td>可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python">x = [(1,2,3),(4,5)] a = np.asarray(x) print (a)# 输出[(1, 2, 3) (4, 5)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、numpy-frombuffer"><a href="#2、numpy-frombuffer" class="headerlink" title="2、numpy.frombuffer"></a>2、numpy.frombuffer</h4><p>numpy.frombuffer 用于实现动态数组。</p><p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><p><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></p><ul><li>注：<br>buffer是字符串的时候，Python3默认str是Unicode 类型所以要转成bytestring在原str前加上b。</li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>buffer</td><td>可以是任意对象，会以流的形式读入</td></tr><tr><td>dtype</td><td>返回数组的数据类型，可选</td></tr><tr><td>count</td><td>读取的数据数量，默认为-1，读取所有数据</td></tr><tr><td>offset</td><td>读取的起始位置，默认为0</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python">s = b'Hello World' a = np.frombuffer(s, dtype = 'S1') print (a)# 输出[b'H' b'e' b'l' b'l' b'o' b' ' b'W' b'o' b'r' b'l' b'd']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、numpy-fromiter"><a href="#3、numpy-fromiter" class="headerlink" title="3、numpy.fromiter"></a>3、numpy.fromiter</h4><p>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p><p><code>numpy.fromiter(iterable, dtype, count=-1)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>iterable</td><td>可迭代对象</td></tr><tr><td>dtype</td><td>返回数组的数据类型</td></tr><tr><td>count</td><td>读取的数据数量，默认为-1，读取所有数据</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 使用 range 函数创建列表对象 list=range(5) it=iter(list) # 使用迭代器创建 ndarray x=np.fromiter(it, dtype=float) print(x)# 输出[0. 1. 2. 3. 4.]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4）：从数值范围创建数组"><a href="#4）：从数值范围创建数组" class="headerlink" title="4）：从数值范围创建数组"></a>4）：从数值范围创建数组</h3><h4 id="1、numpy-arange"><a href="#1、numpy-arange" class="headerlink" title="1、numpy.arange"></a>1、numpy.arange</h4><p>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象：</p><p><code>numpy.arange(start, stop, step, dtype)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>序列的起始值</td></tr><tr><td>stop</td><td>序列的终止值，若endpoint为true，该值包含于数列中</td></tr><tr><td>num</td><td>要生成的等步长的样本数量，默认为50</td></tr><tr><td>endpoint</td><td>该值为 true 时，数列中包含stop值，反之不包含，默认True</td></tr><tr><td>retstep</td><td>如果为 True 时，生成的数组中会显示间距，反之不显示</td></tr><tr><td>dtype</td><td>ndarray 的数据类型</td></tr></tbody></table><h4 id="2、numpy-logspace"><a href="#2、numpy-logspace" class="headerlink" title="2、numpy.logspace"></a>2、numpy.logspace</h4><p>numpy.logspace 函数用于创建一个于等比数列。格式如下：</p><p><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>序列的起始值为：base ** start</td></tr><tr><td>stop</td><td>序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中</td></tr><tr><td>num</td><td>要生成的等步长的样本数量，默认为50</td></tr><tr><td>endpoint</td><td>该值为true时，数列中中包含stop值，反之不包含，默认True</td></tr><tr><td>base</td><td>对数 log 的底数，取对数的时候 log 的下标</td></tr><tr><td>dtype</td><td>ndarray 的数据类型</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python">print (np.logspace(1.0, 2.0, num = 10))&gt;[ 10.           12.91549665     16.68100537      21.5443469  27.82559402        35.93813664   46.41588834     59.94842503      77.42636827    100.    ]  print (np.logspace(0,9,10,base=2))&gt;[  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、索引、切片"><a href="#3、索引、切片" class="headerlink" title="3、索引、切片"></a>3、索引、切片</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = np.arange(10) s = slice(2,7,2) # 从索引 2 开始到索引 7 停止，间隔为2 print (a[s])&gt;[2  4  6]b = a[2:7:2] # 从索引 2 开始到索引 7 停止，间隔为 2 print(b)&gt;[2  4  6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切片还可以包括省略号 <code>…</code>，来使选择元组的长度与数组的维度相同。 </p><p>如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = np.array([[1,2,3],[3,4,5],[4,5,6]]) print (a[...,1]) # 第2列元素 print (a[1,...]) # 第2行元素 print (a[...,1:]) # 第2列及剩下的所有元素# 输出&gt;[2 4 5]&gt;[3 4 5]&gt;[[2 3]  [4 5]  [5 6]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、高级索引"><a href="#4、高级索引" class="headerlink" title="4、高级索引"></a>4、高级索引</h4><ul><li>整数索引</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x = np.array([[1, 2], [3, 4], [5, 6]]) y = x[[0,1,2], [0,1,0]] print (y)# 输出[1  4  5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>布尔索引</li></ul><p>我们可以通过一个布尔数组来索引目标数组。</p><p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><p>如大于 5 的元素：<code>print (x[x &gt; 5])</code></p><p>使用 <code>~</code>（取补运算符）来过滤 NaN：</p><p><code>a = np.array([np.nan, 1,2,np.nan,3,4,5]) print (a[~np.isnan(a)])</code></p><ul><li>花式索引</li></ul><p>关于 np.ix_ 的具体使用：</p><p><code>x[np.ix_([1,5,7,2],[0,3,1,2])]</code>这句话会输出一个4*4的矩阵，其中的元素分别是：</p><pre class="line-numbers language-none"><code class="language-none">x[1,0] x[1,3] x[1,1] x[1,2]x[5,0] x[5,3] x[5,1] x[5,2]x[7,0] x[7,3] x[7,1] x[7,2]x[2,0] x[2,3] x[2,1] x[2,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相当于：</p><pre class="line-numbers language-none"><code class="language-none">y=np.array([[x[1,0], x[1,3], x[1,1], x[1,2]],\            [x[5,0], x[5,3], x[5,1],x[5,2]],\      [x[7,0] ,x[7,3], x[7,1], x[7,2]],\          [x[2,0], x[2,3], x[2,1], x[2,2]]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>就是说，如果 np.xi_ 中输入两个列表，则第一个列表存的是待提取元素的行标，第二个列表存的是待提取元素的列标，第一个列表中的每个元素都会遍历第二个列表中的每个值，构成新矩阵的一行元素。</p><h4 id="5、数组广播"><a href="#5、数组广播" class="headerlink" title="5、数组广播"></a>5、数组广播</h4><p>广播的规则:</p><ul><li><p>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</p></li><li><p>输出数组的形状是输入数组形状的各个维度上的最大值。</p></li><li><p>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</p></li><li><p>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</p></li></ul><p>简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li><p>数组拥有相同形状。</p></li><li><p>当前维度的值相等。</p></li><li><p>当前维度的值有一个是 1。</p></li></ul><p>若条件不满足，抛出 “ValueError: frames are not aligned” 异常。</p><h4 id="6、迭代器"><a href="#6、迭代器" class="headerlink" title="6、迭代器"></a>6、迭代器</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = np.arange(6).reshape(2,3) print ('迭代输出：') for x in np.nditer(a): print (x, end=", " ) # 迭代输出：0, 1, 2, 3, 4, 5, <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>控制遍历顺序</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">for x in np.nditer(a, order='F'):Fortran order，即是列序优先；for x in np.nditer(a.T, order='C'):C order，即是行序优先；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>修改数组中元素的值</li></ul><p>nditer 对象另一个可选参数 op_flags</p><p>默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only）</p><p>为了在遍历数组的同时，实现对数组元素值得修改</p><p>必须指定 read-write 或者 write-only 的模式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = np.arange(0,60,5) a = a.reshape(3,4) print ('原始数组：') print (a) print ('\n') for x in np.nditer(a, op_flags=['readwrite']): x[...]=2*x print ('改后数组：') print (a)#原始数组：改后数组：[[ 0  5 10 15][[  0  10  20  30] [20 25 30 35][ 40  50  60  70] [40 45 50 55]][ 80  90 100 110]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>外部循环</strong></p><p>nditer 类的构造器拥有 flags 参数，它可以接受下列值：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>c_index</td><td>可以跟踪 C 顺序的索引</td></tr><tr><td>f_index</td><td>可以跟踪 Fortran 顺序的索引</td></tr><tr><td>multi_index</td><td>每次迭代可以跟踪一种索引类型</td></tr><tr><td>external_loop</td><td>给出的值是具有多个值的一维数组，而不是零维数组</td></tr></tbody></table><h4 id="7、数组操作"><a href="#7、数组操作" class="headerlink" title="7、数组操作"></a>7、数组操作</h4><ul><li>修改数组形状</li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>reshape</td><td>不改变数据的条件下修改形状</td></tr><tr><td>flat</td><td>数组元素迭代器</td></tr><tr><td>flatten</td><td>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td>ravel</td><td>返回展开数组</td></tr></tbody></table><p><code>numpy.reshape(arr, newshape, order='C')</code></p><ul><li><p>arr：要修改形状的数组</p></li><li><p>newshape：整数或者整数数组，新的形状应当兼容原有形状</p></li><li><p>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。</p></li></ul><p><code>ndarray.flatten(order='C')</code></p><p><code>numpy.ravel(a, order='C')</code></p><ul><li><p>numpy.ravel() 展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，类似 C/C++引用reference），修改会影响原始数组。</p></li><li><p>翻转数组</p></li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>transpose</td><td>对换数组的维度</td></tr><tr><td>ndarray.T</td><td>和 self.transpose() 相同，转置</td></tr><tr><td>rollaxis</td><td>向后滚动指定的轴</td></tr><tr><td>swapaxes</td><td>对换数组的两个轴</td></tr></tbody></table><ul><li>修改数组维度</li></ul><table><thead><tr><th>维度</th><th>描述</th></tr></thead><tbody><tr><td>broadcast</td><td>产生模仿广播的对象</td></tr><tr><td>broadcast_to</td><td>将数组广播到新形状</td></tr><tr><td>expand_dims</td><td>通过在指定位置插入新的轴扩展数组形状</td></tr><tr><td>squeeze</td><td>从数组的形状中删除一维条目</td></tr></tbody></table><ul><li>numpy.broadcast ：</li></ul><p>用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x = np.array([[1], [2], [3]]) y = np.array([4, 5, 6])# 对 y 广播 x b = np.broadcast(x,y) # 它拥有 iterator 属性，基于自身组件的迭代器元组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>numpy.broadcast_to(array, shape, subok)：</p><p>将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</p></li><li><p>numpy.expand_dims(arr, axis)</p><p>arr：输入数组</p><p>axis：新轴插入的位置</p></li><li><p>numpy.squeeze(arr, axis)</p></li><li><p>连接数组</p></li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>concatenate</td><td>连接沿现有轴的数组序列</td></tr><tr><td>stack</td><td>沿着新的轴加入一系列数组。</td></tr><tr><td>hstack</td><td>水平堆叠序列中的数组（列方向）</td></tr><tr><td>vstack</td><td>竖直堆叠序列中的数组（行方向）</td></tr></tbody></table><p><code>numpy.concatenate((a1, a2, ...), axis)</code></p><ul><li><p>a1, a2, …：相同类型的数组</p></li><li><p>axis：沿着它连接数组的轴，默认为0，即为竖直方向链接。1为水平方向链接。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">#沿轴 0 连接两个数组：沿轴 1 连接两个数组：[[1 2][[1 2 5 6] [3 4][3 4 7 8]] [5 6] [7 8]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>numpy.stack(arrays, axis)</code></p><p>用于沿新轴连接数组序列</p><ul><li><p>arrays相同形状的数组序列</p></li><li><p>axis：返回数组中的轴，输入数组沿着它来堆叠</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 沿轴 0 堆叠两个数组：沿轴 1 堆叠两个数组：[[[1 2][[[1 2]  [3 4]] [5 6]] [[5 6][[3 4]  [7 8]]] [7 8]]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>numpy.hstack(array1, array2)    水平堆叠</p></li><li><p>numpy.vstack(array1, array2)    竖直堆叠</p></li><li><p>分割数组</p></li></ul><table><thead><tr><th>函数</th><th>数组及操作</th></tr></thead><tbody><tr><td>split</td><td>将一个数组分割为多个子数组</td></tr><tr><td>hsplit</td><td>将一个数组水平分割为多个子数组（按列）</td></tr><tr><td>vsplit</td><td>将一个数组垂直分割为多个子数组（按行）</td></tr></tbody></table><p><code>numpy.split(ary, indices_or_sections, axis)</code></p><ul><li><p>ary：被分割的数组</p></li><li><p>indices_or_sections：若是一个整数，就用该数平均切分，若是一个数组，为沿轴切分的位置（左开右闭）</p></li><li><p>axis：设置沿着哪个方向进行切分，默认为 0，水平切分。为 1 时，竖直切分。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">print (np.split(a,[4,7]))&gt;[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>数组元素添加&amp;删除</li></ul><table><thead><tr><th>函数</th><th>元素及描述</th></tr></thead><tbody><tr><td>resize</td><td>返回指定形状的新数组</td></tr><tr><td>append</td><td>将值添加到数组末尾</td></tr><tr><td>insert</td><td>沿指定轴将值插入到指定下标之前</td></tr><tr><td>delete</td><td>删掉某个轴的子数组，并返回删除后的新数组</td></tr><tr><td>unique</td><td>查找数组内的唯一元素</td></tr></tbody></table><p><code>numpy.resize(arr, shape)</code></p><p>函数返回指定大小的新数组。</p><p>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p><ul><li><p>arr：要修改大小的数组</p></li><li><p>shape：返回数组的新形状</p></li></ul><p><code>numpy.append(arr, values, axis=None)</code></p><p>函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 </p><p>输入数组的维度必须匹配否则将生成ValueError。</p><ul><li><p>append 函数返回的始终是一个一维数组。</p></li><li><p>arr：输入数组</p></li><li><p>values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</p></li><li><p>axis：默认为 None。当axis无定义时，是横向加成，****返回总是为一维数组****。</p><ul><li>当axis为0时，数组是加在下边（列数要相同）</li><li>当axis为1时，数组是加在右边（行数要相同）</li></ul></li></ul><p><code>numpy.insert(arr, obj, values, axis)</code></p><p>函数在给定索引之前，沿给定轴在输入数组中插入值。</p><p>如果值的类型转换为要插入，则它与输入数组不同。 </p><p>插入没有原地的，函数会返回一个新数组。</p><p>如果未提供轴，则输入数组会被展开。</p><ul><li><p>arr：输入数组</p></li><li><p>obj：在其之前插入值的索引</p></li><li><p>values：要插入的值</p></li><li><p>axis：沿着它插入的轴，如果未提供，则输入数组会被展开</p></li></ul><p><code>Numpy.delete(arr, obj, axis)</code></p><p>函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数情况一样，如果未提供轴参数，则输入数组将展开。</p><ul><li><p>arr：输入数组</p></li><li><p>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</p></li><li><p>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</p></li></ul><p><code>numpy.unique(arr, return_index, return_inverse, return_counts)</code></p><p>用于去除数组中的重复元素。</p><ul><li><p>arr：输入数组，若不是一维数组则会展开</p></li><li><p>return_index：为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</p></li><li><p>return_inverse：为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</p></li><li><p>return_counts：为true，返回去重数组中的元素在原数组中的出现次数</p></li></ul><h4 id="8、numpy位运算"><a href="#8、numpy位运算" class="headerlink" title="8、numpy位运算"></a>8、numpy位运算</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>bitwise_and</td><td>对数组元素执行位与操作</td></tr><tr><td>bitwise_or</td><td>对数组元素执行位或操作</td></tr><tr><td>invert</td><td>按位取反</td></tr><tr><td>left_shift</td><td>向左移动二进制表示的位</td></tr><tr><td>right_shift</td><td>向右移动二进制表示的位</td></tr></tbody></table><h2 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>对两个数组的逐个字符串元素进行连接</td></tr><tr><td>multiply()</td><td>返回按元素多重连接后的字符串</td></tr><tr><td>center()</td><td>居中字符串</td></tr><tr><td>capitalize()</td><td>将字符串第一个字母转换为大写</td></tr><tr><td>title()</td><td>将字符串的每个单词的第一个字母转换为大写</td></tr><tr><td>lower()</td><td>数组元素转换为小写</td></tr><tr><td>upper()</td><td>数组元素转换为大写</td></tr><tr><td>split()</td><td>指定分隔符对字符串进行分割，并返回数组列表</td></tr><tr><td>splitlines()</td><td>返回元素中的行列表，以换行符分割</td></tr><tr><td>strip()</td><td>移除元素开头或者结尾处的特定字符</td></tr><tr><td>join()</td><td>通过指定分隔符来连接数组中的元素</td></tr><tr><td>replace()</td><td>使用新字符串替换字符串中的所有子字符串</td></tr><tr><td>decode()</td><td>数组元素依次调用str.decode</td></tr><tr><td>encode()</td><td>数组元素依次调用str.encode</td></tr></tbody></table><h2 id="五、统计"><a href="#五、统计" class="headerlink" title="五、统计"></a>五、统计</h2><ul><li><p>numpy.amin()         用于计算数组中的元素沿指定轴的最小值。</p></li><li><p>numpy.amax()         用于计算数组中的元素沿指定轴的最大值。</p></li><li><p>numpy.ptp()            计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p></li><li><p>numpy.percentile(a, q, axis)</p><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 </p><ul><li><p>a: 输入数组</p></li><li><p>q: 要计算的百分位数，在 0 ~ 100 之间</p></li><li><p>axis: 沿着它计算百分位数的轴</p></li></ul><p>第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p><p>例子：入学考试成绩以百分位数的形式报告。假设某个考生在考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。这里的 p = 70。</p></li><li><p>numpy.median()         函数用于计算数组 a 中元素的中位数（中值）</p></li><li><p>numpy.mean()        返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p><p>算术平均值是沿轴的元素的总和除以元素的数量。</p></li><li><p>numpy.average()        根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。</p><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p><p>$$<br>加权平均值 = \frac{1*4+2*3+3*2+4*1}{4+3+2+1}<br>$$</p></li><li><p>标准差        <code>numpy.std = sqrt(mean((x - x.mean())**2))</code></p></li><li><p>方差            <code>numpy.var = mean((x - x.mean())** 2)</code></p></li></ul><h2 id="六、排序、条件刷选函数"><a href="#六、排序、条件刷选函数" class="headerlink" title="六、排序、条件刷选函数"></a>六、排序、条件刷选函数</h2><table><thead><tr><th>种类</th><th>速度</th><th>最坏情况</th><th>工作空间</th><th>稳定性</th></tr></thead><tbody><tr><td>‘quicksort’（快速排序）</td><td>1</td><td>O(n^2)</td><td>0</td><td>否</td></tr><tr><td>‘mergesort’（归并排序）</td><td>2</td><td>O(n*log(n))</td><td>~n/2</td><td>是</td></tr><tr><td>‘heapsort’（堆排序）</td><td>3</td><td>O(n*log(n))</td><td>0</td><td>否</td></tr></tbody></table><ul><li><p><code>numpy.sort(a, axis, kind, order)</code></p><ul><li><p>a: 要排序的数组</p></li><li><p>axis: 沿着排序数组的轴，若没有数组则会被展开，沿着最后的轴排序，0按列，1按行</p></li><li><p>kind: 默认’quicksort’</p></li></ul><p> -order: 如果数组包含字段，则是要排序的字段</p></li><li><p>numpy.argsort()            返回的是数组值从小到大的索引值。</p></li><li><p>numpy.lexsort()             用于对多个序列进行排序。</p></li></ul><p>想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><p>例子：在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = ('aaaa','arrr','raaa','rrmm')b = ('fy','sy','sy','fy')ind = np.lexsort((a,b)) print(ind)&gt;[0 3 1 2]print ([a[i] + ", " + b[i] for i in ind])&gt;['aaaa, fy', 'rrmm, fy', 'arrr, sy', 'raaa, sy']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>msort(a)</td><td>数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相当于 np.sort(a, axis=0)。</td></tr><tr><td>sort_complex(a)</td><td>对复数按照先实部后虚部的顺序进行排序。</td></tr><tr><td>partition(a, kth[, axis, kind, order])</td><td>指定一个数，对数组进行分区</td></tr><tr><td>argpartition(a, kth[, axis, kind, order])</td><td>可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</td></tr></tbody></table><ul><li><p>numpy.argmax() &amp; numpy.argmin()    分别沿给定轴返回最大和最小元素的索引。</p></li><li><p>numpy.nonzero()                 函数返回输入数组中非零元素的索引。</p></li><li><p>numpy.where()                     函数返回输入数组中满足给定条件的元素的索引。</p></li><li><p>numpy.extract()             函数根据某个条件从数组中抽取元素，返回满条件的元素。</p></li></ul><h2 id="七、字节交换"><a href="#七、字节交换" class="headerlink" title="七、字节交换"></a>七、字节交换</h2><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p><ul><li><p>大端模式：</p><p>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p></li><li><p>小端模式：</p><p>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p></li></ul><p>例如：在 C 语言中，一个类型为 int 的变量 x 地址为 0x100，那么其对应地址表达式&amp;x的值为 0x100。且x的四个字节将被存储在存储器的 0x100, 0x101, 0x102, 0x103位置。</p><p><img src="https://s2.loli.net/2022/04/17/nqu9VrwvxIR5SYG.png" alt="np-address"></p><ul><li>numpy.ndarray.byteswap()            将 ndarray 中每个元素中的字节进行大小端转换。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; A = np.array([1,256,8755],dtype=np.int16)&gt;&gt;&gt; print(list(map(hex,A)))['0x1', '0x100', '0x2233']&gt;&gt;&gt; print(A.byteswap(inplace=True))[  256     1 13090]&gt;&gt;&gt; print(list(map(hex,A)))['0x100', '0x1', '0x3322']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、线性代数"><a href="#八、线性代数" class="headerlink" title="八、线性代数"></a>八、线性代数</h2><table><thead><tr><th>函数</th><th>速度</th></tr></thead><tbody><tr><td>dot</td><td>两个数组的点积，即元素对应相乘</td></tr><tr><td>vdot</td><td>两个向量的点积</td></tr><tr><td>inner</td><td>两个数组的内积</td></tr><tr><td>matmul</td><td>两个数组的矩阵积</td></tr><tr><td>determinant</td><td>数组的行列式</td></tr><tr><td>solve</td><td>求解线性矩阵方程</td></tr><tr><td>inv</td><td>计算矩阵的乘法逆矩阵</td></tr><tr><td>linalg.det</td><td>计算矩阵的行列式</td></tr><tr><td>linalg.solve</td><td>求解线性矩阵方程</td></tr></tbody></table><h2 id="九、I-x2F-O"><a href="#九、I-x2F-O" class="headerlink" title="九、I/O"></a>九、I/O</h2><p>NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。</p><p>npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p><p>常用的 IO 函数：</p><ul><li><p>load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。</p></li><li><p>savez() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。</p></li><li><p>loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)</p></li><li><p>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</p><p>将数组保存到以 .npy 为扩展名的文件中。</p><p>它们是 Numpy 专用的二进制格式后的数据</p><p>使用 load() 函数来读取数据才可以正常显示</p><ul><li>file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。</li><li>arr: 要保存的数组</li><li>allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。</li><li>fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。</li></ul></li><li><p>numpy.savez(file, *args, **kwds)函数将多个数组保存到以 npz 为扩展名的文件中。</p><ul><li>file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。</li><li>args: 要保存的数组，可以用关键字参数为数组起名，非关键字参数传递的数组会自动起名为 arr_0, arr_1, …　。</li><li>kwds: 要保存的数组使用关键字名称。</li></ul></li><li><p>savetxt() 以简单的文本文件格式存储数据，对应使用 loadtxt() 函数来获取数据。</p></li></ul><p><code>np.loadtxt(FILENAME, dtype=int, delimiter=' ')</code></p><p><code>np.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></p><p><strong>参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a=np.arange(0,10,0.5).reshape(4,-1) np.savetxt("out.txt",a,fmt="%d",delimiter=",") # 改为保存为整数，以逗号分隔 b = np.loadtxt("out.txt",delimiter=",") # load 时也指定为逗号分隔 print(b)# 输出[[0. 0. 1. 1. 2.] [2. 3. 3. 4. 4.] [5. 5. 6. 6. 7.] [7. 8. 8. 9. 9.]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速入门 Markdown(新手向)</title>
      <link href="/2022/04/16/markdown-quick-get-start/"/>
      <url>/2022/04/16/markdown-quick-get-start/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="快速学习Markdown"><a href="#快速学习Markdown" class="headerlink" title="快速学习Markdown"></a>快速学习Markdown</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p><p><strong>本篇可能是目录结构最混乱的文章，<em>跟紧带序号的标题</em>，开始学习吧 <span class="github-emoji"><span>☀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2600.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ）</strong></p><h2 id="1、Markdown-应用"><a href="#1、Markdown-应用" class="headerlink" title="1、Markdown 应用"></a>1、Markdown 应用</h2><p>Markdown 能被使用来撰写电子书，如：Gitbook。</p><p>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p><p>本教程使用的是<code>Typora</code>。用vscode也是可以的，在vscode右侧栏扩展按钮下载<strong>Markdown Preview Enhanced</strong> 即可。</p><p>在<code>Typora</code>，用<code>ctrl + / </code>按键即可切换源码模式和预览模式。</p><h2 id="2、Markdown-标题"><a href="#2、Markdown-标题" class="headerlink" title="2、Markdown 标题"></a>2、Markdown 标题</h2><pre class="line-numbers language-none"><code class="language-none">2.1 我是一级标题=================2.2 我是二级标题-----------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下</p><h1 id="2-1-我是一级标题"><a href="#2-1-我是一级标题" class="headerlink" title="2.1 我是一级标题"></a>2.1 我是一级标题</h1><h2 id="2-2-我是二级标题"><a href="#2-2-我是二级标题" class="headerlink" title="2.2 我是二级标题"></a>2.2 我是二级标题</h2><p>用#号标记六级标题，参考如下效果</p><pre class="line-numbers language-none"><code class="language-none"># 2.3 一级标题## 2.4 二级标题### 2.5 三级标题#### 2.6 四级标题##### 2.7 五级标题###### 2.8 六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-3-一级标题"><a href="#2-3-一级标题" class="headerlink" title="2.3 一级标题"></a>2.3 一级标题</h1><h2 id="2-4-二级标题"><a href="#2-4-二级标题" class="headerlink" title="2.4 二级标题"></a>2.4 二级标题</h2><h3 id="2-5-三级标题"><a href="#2-5-三级标题" class="headerlink" title="2.5 三级标题"></a>2.5 三级标题</h3><h4 id="2-6-四级标题"><a href="#2-6-四级标题" class="headerlink" title="2.6 四级标题"></a>2.6 四级标题</h4><h5 id="2-7-五级标题"><a href="#2-7-五级标题" class="headerlink" title="2.7 五级标题"></a>2.7 五级标题</h5><h6 id="2-8-六级标题"><a href="#2-8-六级标题" class="headerlink" title="2.8 六级标题"></a>2.8 六级标题</h6><h2 id="3、Markdown字体"><a href="#3、Markdown字体" class="headerlink" title="3、Markdown字体"></a>3、Markdown字体</h2><p>markdown可以使用一下几种字体，参考如下效果：</p><pre class="line-numbers language-none"><code class="language-none">*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___~~删除线文本~~&lt;u&gt;带下划线文本&lt;/u&gt; #通过HTML的&lt;u&gt;&lt;/u&gt;标签带脚注文本，鼠标指一下会显示对应解释 [^tuoyou-hao]。[^tuoyou-hao]: 拓佑豪博客<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em><br><del>删除线文本</del><br><u>带下划线文本</u> #通过HTML的<u></u>标签<br>带脚注文本，鼠标指一下会显示对应解释<sup class="refplus-num"><a href="#ref-t">[1]</a></sup>。</p><ul id="refplus" style="display:none;"><li id="ref-t" data-num="1">[1]   拓佑豪博客</li></ul><p></p><h2 id="4、Markdown分割线"><a href="#4、Markdown分割线" class="headerlink" title="4、Markdown分割线"></a>4、Markdown分割线</h2><pre class="line-numbers language-none"><code class="language-none">**** * ******- - -----------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><hr><hr><hr><hr><hr><h2 id="5、Markdown-列表项"><a href="#5、Markdown-列表项" class="headerlink" title="5、Markdown 列表项"></a>5、Markdown 列表项</h2><h3 id="5-1-Markdown-无序列表"><a href="#5-1-Markdown-无序列表" class="headerlink" title="5.1 Markdown 无序列表"></a>5.1 Markdown 无序列表</h3><pre class="line-numbers language-none"><code class="language-none">* 文本* 文本+ 文本+ 文本- 文本- 文本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下</p><ul><li>文本</li><li>文本</li></ul><ul><li>文本</li><li>文本</li></ul><ul><li>文本</li><li>文本</li></ul><h3 id="5-2-Markdown-有序列表"><a href="#5-2-Markdown-有序列表" class="headerlink" title="5.2 Markdown 有序列表"></a>5.2 Markdown 有序列表</h3><pre class="line-numbers language-none"><code class="language-none">1. 第一项2. 第二项3. 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="5-3-列表嵌套"><a href="#5-3-列表嵌套" class="headerlink" title="5.3 列表嵌套"></a>5.3 列表嵌套</h3><pre class="line-numbers language-none"><code class="language-none">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="6、Markdown区块"><a href="#6、Markdown区块" class="headerlink" title="6、Markdown区块"></a>6、Markdown区块</h2><pre class="line-numbers language-none"><code class="language-none">&gt; 最外层&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>当然，这些是可以互相嵌套的</p><pre class="line-numbers language-none"><code class="language-none">&gt; 列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt;&gt; + 第二项&gt; + 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><blockquote><p>列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li><p>第一项</p><blockquote><ul><li>第二项</li></ul></blockquote></li><li><p>第三项</p></li></ul></blockquote><h2 id="7、Markdown-代码"><a href="#7、Markdown-代码" class="headerlink" title="7、Markdown 代码"></a>7、Markdown 代码</h2><p><strong>单行代码：</strong></p><pre class="line-numbers language-none"><code class="language-none">`echo HelloWorld`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p><code>echo HelloWorld</code></p><p><strong>代码区块：</strong></p><pre class="line-numbers language-none"><code class="language-none">​```c#include &lt;stdio.h&gt;void main(){printf("Hello World\n");}//a.c​```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在第一行的<code>```</code>旁边指定语言，也可以不指定。效果如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void main(){printf("Hello World\n");}//a.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8、Markdown-链接"><a href="#8、Markdown-链接" class="headerlink" title="8、Markdown 链接"></a>8、Markdown 链接</h2><pre class="line-numbers language-none"><code class="language-none">这是一个链接 [拓佑豪的博客](tuoyou-hao.github.io)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p>这是一个链接 <a href="tuoyou-hao.github.io">拓佑豪的博客</a></p><p>在Typora，也可以直接打链接地址：<a href="https://tuoyou-hao.github.io/">https://tuoyou-hao.github.io</a></p><p><em><strong>高级链接</strong></em></p><pre class="line-numbers language-none"><code class="language-none">这个链接用 1 作为网址变量 [baidu][1]然后在文档的结尾为变量赋值（网址）[1]: https://www.baidu.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><p>这个链接用 1 作为网址变量 <a href="https://www.baidu.com/">baidu</a><br>然后在文档的结尾为变量赋值（网址）</p><h2 id="9、Markdown图片"><a href="#9、Markdown图片" class="headerlink" title="9、Markdown图片"></a>9、Markdown图片</h2><p>格式是 ![图片名称](图像地址)</p><p>如果你是在本地的图片，图像地址就可以用文件路径</p><p>如果你需要这个图像到哪儿都可以看，除了把图片的路径改为<code>相对路径</code>然后一并打包，还可以把图像放在<code>图床</code></p><p>效果如下：</p><p><img src="https://support.huaweicloud.com/productdesc-Atlas200DK1012/figure/zh-cn_image_0205566091.png" alt="atlas"></p><p>是不是感觉图像太大了？如果你的图像需要缩放，可以使用以下语句</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src=图片地址 style="zoom: 缩放比例;" /&gt;&lt;img src="https://support.huaweicloud.com/productdesc-Atlas200DK1012/figure/zh-cn_image_0205566091.png" style="zoom: 33%;" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://support.huaweicloud.com/productdesc-Atlas200DK1012/figure/zh-cn_image_0205566091.png" style="zoom: 33%;"><h2 id="10、Markdown表格"><a href="#10、Markdown表格" class="headerlink" title="10、Markdown表格"></a>10、Markdown表格</h2><p> Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。 </p><pre class="line-numbers language-none"><code class="language-none">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>文字对齐方式：</p><pre class="line-numbers language-none"><code class="language-none">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="11、Markdown其他技巧"><a href="#11、Markdown其他技巧" class="headerlink" title="11、Markdown其他技巧"></a>11、Markdown其他技巧</h2><h3 id="1、支持的-HTML-元素"><a href="#1、支持的-HTML-元素" class="headerlink" title="1、支持的 HTML 元素"></a>1、支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>kbd、b、i、em、sup 、ub、br</code>等 ，如：</p><pre class="line-numbers language-none"><code class="language-none">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;c&lt;/kbd&gt; 键复制文本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>c</kbd> 复制文本</p><h3 id="2、转义"><a href="#2、转义" class="headerlink" title="2、转义"></a>2、转义</h3><p>Markdown 使用了很多特殊符号来表示不同的符号，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： </p><pre class="line-numbers language-none"><code class="language-none">**文本加粗** \*\* 正常显示星号 \*\*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持在这些符号前面加上反斜杠，达到转义的目的：</p><pre class="line-numbers language-none"><code class="language-none">\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、Markdown表情"><a href="#3、Markdown表情" class="headerlink" title="3、Markdown表情"></a>3、Markdown表情</h3><p>可以使用各种emoji，<span class="github-emoji"><span>🔆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f506.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>或者<span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>等等都可以</p><p>想要使用这些emoji，可以前往这个链接<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji</a>，找到合适的emoji，点击一下就复制成功了，可以自由使用在Markdown里。</p><h3 id="4、数学公式、流程图等等"><a href="#4、数学公式、流程图等等" class="headerlink" title="4、数学公式、流程图等等"></a>4、数学公式、流程图等等</h3><p>markdown支持书写数学公式，代码建立流程图等等，后续会出专栏专门介绍。</p><ul><li>Latex数学矩阵表示：</li></ul><pre class="line-numbers language-none"><code class="language-none">$$\begin{Bmatrix}   a &amp; b \\\\   c &amp; d\end{Bmatrix}$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$$<br>\begin{Bmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{Bmatrix}<br>$$</p><ul><li>流程图：</li></ul><pre class="line-numbers language-none"><code class="language-none">​&lt;pre class="mermaid"&gt;graph LRA[方形] --&gt;B(圆角)    B --&gt; C{条件a}    C --&gt;|a=1| D[结果1]    C --&gt;|a=2| E[结果2]    F[横向流程图]​&lt;/pre&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">graph LRA[方形] --&gt;B(圆角)    B --&gt; C{条件a}    C --&gt;|a=1| D[结果1]    C --&gt;|a=2| E[结果2]    F[横向流程图]</pre>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新手 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述(2.1进程与线程)</title>
      <link href="/2022/04/12/operating_system2-1/"/>
      <url>/2022/04/12/operating_system2-1/</url>
      
        <content type="html"><![CDATA[<h1>操作系统——2.1 进程与线程</h1><h2 id="2-1-1-进程">2.1.1 进程</h2><ul><li><p>程序，是静态的，就是一系列的指令集合。</p></li><li><p>进程，是动态的，是程序的一次执行过程。</p></li><li><p>当进程被创建的时候，操作系统会给该进程分配一个<strong>唯一的、不重复的ID</strong>——PID(Process ID)，进程ID</p></li><li><p>每个进程，操作系统会记录：</p><ul><li>其PID，进程所属用户ID（UID）</li><li>还要记录给每个进程分配了多少资源（如内存，正在使用哪些IO设备，正在使用那些文件，可用于实现操作系统对资源的管理。）</li><li>记录进程的运行情况（CPU使用时间、磁盘使用情况、网络流量使用情况等等，可用于实现操作系统对进程的控制、调度）</li><li>这些信息都会同意保存在一个数据结构<strong>PCB</strong>（process control block）中，即进程控制块，存放管理时需要的信息。</li></ul></li></ul><pre class="mermaid">graph LRPCB(PCB) --&gt;A(进程描述信息)    A --&gt;A1(进程标识符PID)    A --&gt;A2(用户标识符UID)PCB --&gt;B(进程控制和管理信息)    B --&gt;B1(CPU/磁盘/网络流量 使用统计)    B --&gt;B2(进程当前状态 就绪/阻塞/运行)PCB --&gt;C(资源分配清单)    C --&gt;C1(正在使用的文件)    C --&gt;C2(正在使用的内存区域)    C --&gt;C3(正在使用的IO设备)PCB --&gt;D(处理机相关信息)D --&gt;D1(PSW/PC等 寄存器的值)</pre><ul><li>当进程被创建时，操作系统为期创建一个PCB。当进程运行结束，操作系统会将其收回。操作系统对进程进行管理工作所需信息都存在PCB中。</li></ul><pre class="mermaid">graph LRS(进程的组成) --&gt;PCBPCB --&gt;P1(进程描述信息)PCB --&gt;P2(进程控制和管理信息)PCB --&gt;P3(资源分配清单)PCB --&gt;P4(处理机相关信息)S --&gt;A(程序段)A --&gt;A1(程序的代码  指令序列)S --&gt;B(数据段)B --&gt;B1(运行过程中产生的各种数据)B --&gt;B2(如 程序中定义的变量)S1[准确来说, 应该是 进程实体的组成]</pre><p>PCB通常包含的内容：</p><table><thead><tr><th style="text-align:center">进程描述信息</th><th style="text-align:center">进程控制和管理信息</th><th style="text-align:center">资源分配清单</th><th style="text-align:center">处理机相关信息</th></tr></thead><tbody><tr><td style="text-align:center">进程标识符PID</td><td style="text-align:center">进程当前状态</td><td style="text-align:center">代码段指针</td><td style="text-align:center">通用寄存器值</td></tr><tr><td style="text-align:center">用户标识符UID</td><td style="text-align:center">进程优先级</td><td style="text-align:center">数据段指针</td><td style="text-align:center">地址寄存器值</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">代码运行入口地址</td><td style="text-align:center">堆栈段指针</td><td style="text-align:center">控制寄存器值</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">程序的外存地址</td><td style="text-align:center">文件描述符</td><td style="text-align:center">标志寄存器值</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">进入内存时间</td><td style="text-align:center">键盘</td><td style="text-align:center">状态字</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">处理机占用时间</td><td style="text-align:center">鼠标</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">信号量使用</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><ul><li>PCB是给操作系统用的。<strong>PCB是进程存在的唯一标志！</strong></li><li>程序段、数据段是给进程自己使用的。和自身的运行逻辑有关</li></ul><p>进程，是动态的，是程序进行资源分配和调度的一个独立个体。</p><p>进程实体（进程映像）：是静态的，是进程某一时刻运行时的快照（照片）。进程实体可以反映进程在某一时刻的状态。</p><ul><li>一个进程的调度，就是操作系统决定让这个进程上CPU运行。</li></ul><p><strong>进程的特征</strong>：</p><ul><li><p>动态性：</p><p>是进程的最基本特征。进程是程序的一次执行过程，动态产生、变化和消亡</p></li><li><p>并发性：</p><p>内存中有多个进程实体。各个进程可以并发执行。</p></li><li><p>独立性：</p><p>课接受独立运行、调度、获得资源的基本单位</p><p>各个进程拥有的内存地址空间相互独立</p></li><li><p>异步性：</p><p>各自独立，不可预知的速度运行。操作系统要提供 <strong>进程同步机制</strong> 来解决异步问题</p></li><li><p>结构性：</p><p>每个进程都配有一个PCB。</p></li></ul><h2 id="2-1-2-进程的状态">2.1.2 进程的状态</h2><p><strong>进程的状态</strong>：</p><ul><li><p>创建态：进程被创建时的状态。系统会为其分配资源，初始化PCB。</p></li><li><p>就绪态：进程创建完成的状态。<strong>但由于没有CPU，暂时不能运行</strong></p></li><li><p>运行态：进程正在CPU上运行。</p></li></ul><p>进程运行过程中，可能会请求等待某个时间的发生（如等待某种系统资源的分配，或者等待其他进程的响应）。所以还有：</p><ul><li>阻塞态：在这个事件发生之前，该进程无法继续运行。操作系统会将其设置为阻塞态。</li></ul><pre class="mermaid">graph LRA((新建)) --&gt; |创建|B(就绪)B --&gt;|调度|C(运行)C --&gt;|时间到|BC --&gt;|退出|E(终止)C --&gt;|事件等待|D(阻塞)D --&gt;|事件发生|B</pre><ul><li><p>就绪态 -&gt; 运行态：进程被调度</p></li><li><p>运行态 -&gt; 阻塞态：是一种主动行为，等待资源分配</p></li><li><p>阻塞态 -&gt; 就绪态：是一种被动行为，资源分配到位</p></li><li><p>运行态 -&gt; 就绪态：时间片结束时候会有适中中断，或者CPU被其他优先级更高的进程抢占</p></li><li><p>三种基本状态：运行态、就绪态、阻塞态。</p></li><li><p>PCB中会有个state表示进程的当前状态</p></li></ul><p><strong>进程的组织——链接方式</strong>：</p><ul><li>主要使用到了：执行指针、就绪队列指针、阻塞队列指针</li></ul><p>链式方式（系统管理一系列的队列，每个队列都会指向相应状态的PCB）大多数操作系统使用该方式</p><p>​执行指针指向当前运行态（执行态）的进程</p><p>索引方式</p><p>​给各个相应进程建立索引表，每个索引表的表项指向PCB</p><h2 id="2-1-3-进程控制">2.1.3 进程控制</h2><p>实现进程的状态转换。进程控制需要用<strong>原语</strong>来实现。</p><p>原语的执行具有原子性，即允许过程只能一气呵成，期间不允许被中断。</p><p>可以用“关中断指令“和”开中断指令“这两个特权指令来实现原子性。</p><ul><li>没有关闭中断指令的时候，CPU每执行一句话就会检查是否有中断信号，有的换就中断程序，去执行中断信号所对应的程序。</li><li>关闭了中断指令之后，即使有中断指令进来，CPU就不会理会，继续执行自己当前的指令。</li><li>执行了“开中断指令” ，才会检查刚才是否有中断信号。有的话，就马上转去中断处理程序。</li><li>在”关中断“与“开中断”之间的指令就是原子性的，不可被中断。</li></ul><h3 id="2-1-3-1-进程的创建：">2.1.3.1 进程的创建：</h3><ul><li>创建原语：<ul><li>申请空白的PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入 就绪队列</li></ul></li><li>引起进程创建的事件<ul><li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理这个请求</li><li>应用请求：由用户进程主动请求创建的一个子进程</li></ul></li></ul><h3 id="2-1-3-2-进程的摧毁：">2.1.3.2 进程的摧毁：</h3><ul><li>撤销原语：<ul><li>从PCB集合中找到终止进程的PCB</li><li>若该进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程（进程之间的关系是树形的结构）</li><li>将该进程拥有的所有资源归还给父进程或者操作系统</li><li>删除PCB</li></ul></li><li>引起进程终止的时间<ul><li>正常结束：进程自己请求终止（exit系统调用）</li><li>异常结束：整数除0、非法使用特权指令然后被操作系统强行杀掉</li><li>外接干预：命令行<kbd>ctrl</kbd>+<kbd>c</kbd>键直接中断代码运行</li></ul></li></ul><h3 id="2-1-3-3-进程的阻塞和唤醒：">2.1.3.3 进程的阻塞和唤醒：</h3><ul><li>进程的阻塞<ul><li>阻塞原语<ul><li>找到要阻塞的进程 对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为 “阻塞态” ，暂停进程的运行</li><li>将PCB插入相应事件的等待队列</li></ul></li><li>引起进程阻塞的事件<ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul></li></ul></li><li>进程的唤醒<ul><li>唤醒原语<ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列溢出，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul></li><li>引起进程唤醒的事件：等待的事件发生了。 <strong>一个进程因为什么事情被阻塞，就应该由这个事件来唤醒</strong> 。</li></ul></li></ul><h3 id="2-1-3-4进程的切换：">2.1.3.4进程的切换：</h3><ul><li>切换原语<ul><li>将运行环境信息存入PCB</li><li>PCB移入相应队列</li><li>选择另一个进程执行，更新其PCB</li><li>根据PCB恢复新进程所需的运行环境</li></ul></li><li>引起进程切换的时间<ul><li>当前进程的时间片计时结束</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ul><p>无论哪个进程要控制原语，要做的无非三类事情：</p><ol><li><p>更新PCB中的信息</p></li><li><p>将PCB插入合适的队列</p></li><li><p>分配/回收资源</p></li></ol><h2 id="2-1-4-进程通信">2.1.4 进程通信</h2><pre class="mermaid">graph LRA(进程通信) --&gt;B(共享存储)B --&gt;B1(基于数据结构的共享)B --&gt;B2(基于存储区的共享)A --&gt;C(消息传递)C --&gt;C1(直接通信)C --&gt;C2(间接通信)A --&gt;D(管道通信)</pre><h3 id="2-1-4-1进程通信">2.1.4.1进程通信</h3><p>进程之间的信息交换。为了保证安全，一个进程不能直接访问另一个进程的地址空间</p><ul><li><p>共享空间：<strong>两个进程对共享空间的访问必须是互斥的</strong>（互斥访问通过操作系统给的工具实现）。操作系统只提供共享空间和同步互斥工具（如P、V操作）</p><ul><li>基于数据结构共享：比如共享空间只能存放长度为10的数组，这种方式速度慢，限制多，是一种低级的通信方式</li><li>基于存储区的共享：在内存中划出一块共享存储区，数据的形式、存放的位置都是由进程来控制，而不是操作系统。该共享方式更快，是一种高级的通信方式。</li></ul></li><li><p>管道通信：</p><p>管道是指用于连接读写进程的一个共享文件，又叫做<strong>pipe</strong>文件。其实就是在内存中开辟一个大小固定的缓冲区。</p><ul><li>一个管道只能采用<code>半双工通信</code>，某一时间段内只能实现<strong>单向</strong>的传输。如果要实现<code>双向同时通信</code>，则需要设置两个管道。</li><li>各个进程要<strong>互斥</strong>地访问管道。</li><li>数据以字符流的形式进入管道。<ul><li>当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走</li><li>当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li></ul></li><li>如果没写满，就不允许读；如果没读空，就不允许写</li><li>数据一旦被读出，就会从管道中被抛弃。这就意味着读进程最多只能有一个。否则可能会出现读错数据的情况</li></ul></li></ul><h3 id="2-1-4-2-消息传递">2.1.4.2 消息传递</h3><p>进程之间的数据交换以**格式化的消息（message）**为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p><p>消息分为消息头和消息体两个板块</p><ul><li>消息头：包括发送进程ID、接受进程ID、消息类型、消息长度等等信息（计算机网络中发送的“报文”，就是一种格式化消息）</li><li>消息体：消息本体</li></ul><p>消息传递有两种方式：</p><ul><li>直接通信方式：消息直接挂到接受进程的消息缓冲队列上</li><li>间接通信方式：消息先发送到中间实体（信箱）中，也成为“信箱通信方式”，如：计算机网络中的电子邮件系统</li></ul><h2 id="2-1-5-线程的概念">2.1.5 线程的概念</h2><p>有的进程可能需要 “同时” 做很多事情，传统的进程只能串行执行一系列程序。所以引入了 “线程” ，来增加并发度。</p><p>可以把线程理解为“轻量级进程”</p><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等等都是分配给进程的）</p><p>带来的变化：</p><ul><li>资源分配、调度<ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul></li><li>并发性<ul><li>传统进程机制中，只能进程间并发</li><li>引入线程后，各个线程之间也能并发，提升了并发度</li></ul></li><li>系统开销<ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li><li>引入线程后，并发所带来的系统开销减小。</li><li>线程间并发，如果是统一进程内的线程切换，则不需要切换进程环境，系统开销小</li></ul></li></ul><p>线程的属性：</p><ul><li><p>线程是处理机调度的单位。</p><ul><li>同一个进程中线程切换，不引起进程切换。</li><li>不同的进程中线程切换，会引起进程切换。</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul></li><li><p>多CPU计算机中，各个线程可以占用不同CPU</p></li><li><p>每个线程都拥有一个线程ID，线程控制块TCB，TCB记录了线程执行的寄存器和栈等现场状态。</p><ul><li>线程也有就绪、阻塞、运行三种基本状态。</li><li>不同线程可以执行相同的程序</li></ul></li><li><p>线程几乎不拥有系统资源。但线程可以访问其隶属进程的系统资源。属于同一进程的所有线程都具有相同的地址空间</p></li><li><p>同一进程的不同线程间贡献进程的资源</p></li><li><p>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</p></li></ul><h2 id="2-1-6-多线程">2.1.6 多线程</h2><pre class="mermaid">graph LRA(线程) --&gt;B(实现方式)B --&gt;B1(用户级线程)B --&gt;B2(内核级线程)A --&gt;C(多线程模型)C --&gt;C1(一对一模型)C --&gt;C2(多对一模型)C --&gt;C3(多对多模型)</pre><h3 id="2-1-6-1用户级线程（User-Level-Thread，ULT）">2.1.6.1用户级线程（User-Level-Thread，ULT）</h3><ul><li><p>由应用程序在用户控件完成，用户才能感知到线程的存在，而内核意识不到线程的存在。</p><p>应用于早期操作系统，线程的实现是使用线程库实现的。</p><p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p></li><li><p>用户级线程有应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都有<strong>应用程序负责</strong>（包括线程切换）</p></li><li><p>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统干预</p></li><li><p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程” 就是 <strong>从用户视角看，能看到的线程</strong>。</p></li><li><p>优点：</p><ol><li>用户级线程的切换在用户控件即可完成，不需要切换到核心态。</li><li>线程管理的系统开销小，效率高。</li><li>调度算法可以是进程专用的，不同的进程可以根据自人需要，对自己的线程选择不同的调度算法。</li><li>用户级线程的实现与操作系统无关，对象池管理的代码是属于用户程序的一部分。</li></ol></li><li><p>缺点：</p><ol><li>当一个用户级线程被阻塞后，<strong>整个进程都会被阻塞</strong>，<strong>并发度不高</strong>。</li><li>多个线程不可在多核处理机上并行运行。不能发挥多处理机的优势，内核每次分配给一个进程的只有一个CPU，因此进程中仅有一个线程能执行。</li></ol></li></ul><pre class="mermaid">graph TBA1(用户级线程) ---|用户空间|S(线程库)A2(用户级线程) ---|用户空间|SA3(用户级线程) ---|用户空间|Ssubgraph kernel_area    P(内核级线程)endS ---|内核空间|PT((用户级方式))</pre><h3 id="2-1-6-2-内核级线程（KLT">2.1.6.2 内核级线程（KLT)</h3><ul><li><p>内核级线程的管理工作由操作系统内核完成</p></li><li><p>线程调度、切换等工作都由内核负责。因此<strong>内核级线程的切换必须在核心态下才能完成</strong>。</p></li><li><p>操作系统会为每个内核级线程创建TCB（Thread Control Bolck，线程控制块）</p></li><li><p>优点：</p><ol><li>能发挥多处理机的优势，并发能力强。多线程可以在多核处理机上并行执行。</li><li>如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机。</li><li>内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。</li><li>内核本身也可以采用多线程技术，提高系统的执行速度和效率。</li></ol></li><li><p>缺点：</p><p>同一进程中的线程切换，需要从用户态转为核心态，系统开销较大。</p><p>因为用户进程的线程在用户态执行，而线程调度和管理需要在内核实现</p></li></ul><pre class="mermaid">graph TBA1(用户级线程) ---|用户空间|P1A2(用户级线程) ---|用户空间|P2A3(用户级线程) ---|用户空间|P3subgraph kernel_area    P1 ---|内核空间|P(内核级线程)    P2 ---|内核空间|P    P3 ---|内核空间|PendT((内核级方式))</pre><h3 id="2-1-6-3-组合方式">2.1.6.3 组合方式</h3><p>同一个进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞，结合了ULT与KLT的优势，并克服了各自的不足</p><p>实现线程库主要方式有</p><ul><li>在用户空间中提供一个没有内核支持的库</li><li>实现由操作系统直接支持的内核级的库</li></ul><pre class="mermaid">graph TBA1(用户级线程) ---|用户空间|S1(线程库1)A2(用户级线程) ---|用户空间|S1A3(用户级线程) ---|用户空间|S1A4(用户级线程) ---|用户空间|S2(线程库2)subgraph kernel_area    P1(内核级线程)    P2(内核级线程)    P3(内核级线程)endS1 ---|内核空间|P1S1 ---|内核空间|P2S2 ---|内核空间|P3T((组合 方式))</pre><h3 id="2-1-6-4-多线程模型">2.1.6.4 多线程模型</h3><h4 id="1、一对一模型">1、一对一模型</h4><p>类比内核级线程图</p><p>一个用户级线程映射到一盒内核级线程。每个用户进程有和用户线程一样多的内核级线程。</p><ul><li><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，<strong>并发能力强</strong>。多线程可以在多核处理机上运行</p></li><li><p>缺点：一个用户进程会占用多个内核级线程，线程切换又需要操作系统来完成，需要切换到核心态。<strong>线程管理的成本高，开销大</strong>。</p></li></ul><h4 id="2、多对一模型">2、多对一模型</h4><p>类比用户级线程图</p><p>多个用户级线程映射到一个内核级线程，且一个进程只能被分配到一个内核级线程。</p><ul><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，系统管理的开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li><li><strong>！重点</strong>：操作系统只 “看得见” 内核级线程，因此只有内核级线程才是处理机分配的单位</li></ul><h4 id="3、多对多模型">3、多对多模型</h4><p>类比组合模型图</p><ul><li><p>n个用户级线程映射到m个内核级线程**（n&gt;=m）**。每个用户级进程对应m个内核级线程。</p></li><li><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞）</p></li><li><p>克服了一对一模型中一个用户占用太多线程，开销太大的缺点</p></li><li><p>可以理解为：</p><ul><li>用户级线程是 “代码逻辑”的载体</li><li>内核级线程是 “运行机会”的载体</li><li>内核级线程才是处理机分配的单位</li></ul></li><li><p>一段 “代码逻辑”只有获得 “运行机会”，才能被CPU执行</p><ul><li>内核级线程中可以运行任意一个有映射关系的用户级线程代码</li><li>只有两个内核级线程中正在运行的代码逻辑全都阻塞，这个进程才会阻塞。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机知识 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atlas 200DK 初步环境配置指南</title>
      <link href="/2022/04/09/Atlas_200DK_first_Environment_configuration/"/>
      <url>/2022/04/09/Atlas_200DK_first_Environment_configuration/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Atlas-200DK-初步环境配置指南"><a href="#Atlas-200DK-初步环境配置指南" class="headerlink" title="Atlas 200DK 初步环境配置指南"></a>Atlas 200DK 初步环境配置指南</h1><p>本教程教你如何搭建Atlas 200DK开发运行环境，快速预备Atlas 200DK的开发</p><h2 id="一、配置VMware虚拟机开发环境"><a href="#一、配置VMware虚拟机开发环境" class="headerlink" title="一、配置VMware虚拟机开发环境"></a>一、配置VMware虚拟机开发环境</h2><h3 id="第一步，设置root密码"><a href="#第一步，设置root密码" class="headerlink" title="第一步，设置root密码"></a>第一步，设置root密码</h3><p><code>sudo passwd root</code></p><p>然后显示屏会跳出一句</p><p><code>[sudo] password for pi: </code></p><ol><li><p>pi是我设置的账号名</p></li><li><p>在这里需要输入你一开始设置的账户密码，并且是<strong>不会显示在屏幕上</strong></p></li><li><p>输入完毕你的账户密码，就设置root账户密码:<code>sudo passwd root</code></p><p>Enter new UNIX password: </p><p>Retype new UNIX password: </p><p>passwd: password updated successfully</p></li></ol><p>如以上显示则说明密码设置成功，请记住你的root密码</p><h3 id="第二步，换源（可选）"><a href="#第二步，换源（可选）" class="headerlink" title="第二步，换源（可选）"></a>第二步，换源（可选）</h3><p>（内容参照<a href="https://www.cnblogs.com/huang-y-x/p/11082168.html%EF%BC%8C%E5%8F%AF%E5%9C%A8%E9%87%8C%E9%9D%A2%E9%80%89%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%BA%90%EF%BC%89">https://www.cnblogs.com/huang-y-x/p/11082168.html，可在里面选用不同的源）</a></p><p>1：备份原来的源</p><p><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p><p>2：进入root账户</p><p><code>su</code></p><p>3：进入设置源的文件</p><p><code>vi /etc/apt/sources.list</code></p><p>4：</p><p>本文使用中科大的源，粘贴以下内容</p><pre class="line-numbers language-none"><code class="language-none">##中科大源deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后按<kbd>esc</kbd>键，输入 :wq 回车，保存并退出</p><p>也可以选用清华源</p><pre class="line-numbers language-none"><code class="language-none">##清华源deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换完源之后，一定要更新一下软件列表</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt-get updateapt-get upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下载vim</p><p><code>apt-get install vim</code></p><ul><li><p>如果出现什么问题，可以试试 <code>apt-get -f install</code>，或者重复多跑几次</p></li><li><p>如果出现编辑一半就报错退出，请在root账户底下<code>rm /etc/apt/.sources.list.swp</code>，然后重新使用vi指令进入即可。</p></li></ul><h2 id="二、Atlas-200DK-初步制卡"><a href="#二、Atlas-200DK-初步制卡" class="headerlink" title="二、Atlas 200DK 初步制卡"></a>二、Atlas 200DK 初步制卡</h2><p>准备依赖环境</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install python3 python3-pip gitpip3 install pyyamlsudo apt-get install qemu-user-static binfmt-support python3-yaml squashfs-tools gcc-aarch64-linux-gnu g++-aarch64-linux-gnu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把以下文件整合进home目录下的<code>mksd</code>文件夹，比如说我的路径是<code>/home/pi/mksd</code>。</p><p>在home/pi目录下执行<code>mkdir mksd</code>，然后<code>cd mksd</code>进入mksd文件夹</p><ul><li>ubuntu-18.04-server-arm64.iso(在历史版本里面找，本教程选用的是18.04.4)</li></ul><p>  <a href="https://releases.ubuntu.com/?_ga=2.35892448.1525631547.1620916708-1630382698.1620537185">下载Ubuntu server arm 镜像</a></p><ul><li>200dk固件与驱动（本教程的版本号选用5.1.RC1.alpha002）</li></ul><p>  <a href="https://www.hiascend.com/hardware/firmware-drivers?tag=community">atlas 200dk 驱动</a></p><ul><li>获取软件包（主要下载run文件）</li></ul><p>  <a href="https://support.huaweicloud.com/environment-deployment-Atlas200DK202/atlased_04_0020.html">atlas 200 dk软件包</a></p><ul><li>制卡脚本（务必参考下列版本号说明）</li></ul><p><a href="https://gitee.com/ascend/tools/tree/master/makesd">atlas-tools</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># usb数据线连Ubuntu的脚本wget https://raw.githubusercontent.com/Huawei-Ascend/tools/master/configure_usb_ethernet/for_20.1/configure_usb_ethernet.sh# 下载python包（可选）wget https://www.python.org/ftp/python/3.7.5/Python-3.7.5.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>! 注意</strong>：<strong>制卡脚本</strong>版本号需要一一对应。不同版本的工具连接有可能已经更新，请前往<a href="https://gitee.com/ascend/tools/tree/master/makesd">https://gitee.com/ascend/tools/tree/master/makesd</a><br>参考下表给的版本号进行查询</p><p><strong>! 点击上述链接，参考下表选择对应版本号的文件夹，然后下载里面的<code>make_sd_card.py</code>和<code>make_ubuntu_sd.sh</code>两个工具。然后把工具放进mksd里。</strong></p><p><strong>如果你的各项文件版本和本教程使用的一致，本教程需要打开的文件夹是<code>generic_script</code></strong></p><table><thead><tr><th align="center"><strong>驱动与固件版本</strong></th><th align="center"><strong>CANN版本</strong></th></tr></thead><tbody><tr><td align="center">1.0.13.alpha</td><td align="center">5.1.RC1.alpha005</td></tr><tr><td align="center"><strong>1.0.12.alpha</strong></td><td align="center">5.1.RC1.alpha003</td></tr><tr><td align="center"></td><td align="center"><strong>5.1.RC1.alpha002</strong></td></tr><tr><td align="center"></td><td align="center">5.1.RC1.alpha001</td></tr><tr><td align="center"></td><td align="center">5.0.5.alpha001</td></tr><tr><td align="center">1.0.11.alpha</td><td align="center">5.0.3.alpha005</td></tr><tr><td align="center"></td><td align="center">5.0.2.alpha005</td></tr><tr><td align="center">1.0.10.alpha</td><td align="center">5.0.2.alpha003</td></tr><tr><td align="center">1.0.9.alpha</td><td align="center">5.0.2.alpha002</td></tr><tr><td align="center"></td><td align="center">5.0.2.alpha001</td></tr><tr><td align="center"></td><td align="center">3.3.0.alpha006</td></tr><tr><td align="center"></td><td align="center">3.3.0.alpha005</td></tr><tr><td align="center"></td><td align="center">3.3.0.alpha001</td></tr><tr><td align="center"></td><td align="center">3.2.0.alpha001 备注：曾用版本号“20.2.alpha001”</td></tr><tr><td align="center">1.0.8.alpha</td><td align="center">3.1.0.alpha001 备注：曾用版本号“20.1.alpha001”</td></tr><tr><td align="center">1.0.7.alpha</td><td align="center">20.0.0</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/04/09/fhin7djFQ51YGyJ.png" alt="atlas-mksd-file.png"></p><p>（请确保制卡的时候，对应版本号的文件是正确的，并且至少需要有上免图片中的文件）</p><p>用读卡器接入你需要制卡的sd卡，把读卡机接入VMware。在 虚拟机-&gt;可移动设备中 吧读卡器接入虚拟机</p><p>用这个指令搜索你的读卡器<code>sudo fdisk -l</code></p><p>我在输出的最后一栏找到这个输出</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Device     Boot Start       End   Sectors  Size Id Type/dev/sdb1       32768 124735487 124702720 59.5G  7 HPFS/NTFS/exFAT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的sdb1就是我的读卡器的标号</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">supython3 make_sd_card.py local /dev/sdb1   #自己选好路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后系统就会自己开始制卡，请耐心等待。</p><p>如果最终制卡成功，会显示<code>Make SD Card successfully!</code>。如果有报错，请检查<strong>制卡工具的版本号</strong>是否有问题。</p><p>制好卡之后把卡放在atlas-200dk上，通电，让atlas自己进行初始化。</p><p>请参考指示灯，从网线接口一端数起各个灯分别为：MINI_LED2、MINI_LED1、3559_ACT、3559_VEDIO</p><img src="https://support.huaweicloud.com/productdesc-Atlas200DK1012/figure/zh-cn_image_0205566091.png" style="zoom: 33%;"><p>通电后，等待一会儿，等四个灯常亮才算正常开机。如果出现问题，请参考下表排查问题：</p><table><thead><tr><th>MINI_LED2</th><th>MINI_LED1</th><th>当前Atlas 200 DK 开发者套件（型号 3000）开发者板状态</th><th>注意事项</th></tr></thead><tbody><tr><td>灭</td><td>灭</td><td>Atlas 200 DK 开发者套件（型号 3000）开发者板启动</td><td>可以对Atlas 200 DK 开发者套件（型号 3000）开发者板断电或重启。</td></tr><tr><td>灭</td><td>亮</td><td>Ascend 310启动</td><td>可以对Atlas 200 DK 开发者套件（型号 3000）开发者板断电或重启，新版本升级时建议不要断电或重启。</td></tr><tr><td>闪烁</td><td>闪烁</td><td>固件升级</td><td>不能执行Atlas 200 DK 开发者套件（型号 3000）开发者板断电或重启操作，否则会导致固件升级不完整，单板损坏。当新版本升级时才会有固件升级流程，升级时间比较久，预计在15分钟内，请您耐心等待。</td></tr><tr><td>亮</td><td>亮</td><td>Atlas 200 DK 开发者套件（型号 3000）开发者板启动完成</td><td>可以对Atlas 200 DK 开发者套件（型号 3000）开发者板断电或重启。</td></tr></tbody></table><table><thead><tr><th>3559_ACT</th><th>3559_VEDIO</th><th>当前Atlas 200 DK 开发者套件（型号 3000）开发者板状态</th><th>注意事项</th></tr></thead><tbody><tr><td>灭</td><td>灭</td><td>Hi3559C系统未启动</td><td>无</td></tr><tr><td>灭</td><td>亮</td><td>Hi3559C系统启动中</td><td>无</td></tr><tr><td>亮</td><td>亮</td><td>Hi3559C系统启动完成</td><td>无</td></tr></tbody></table><h2 id="三、USB线连接atlas"><a href="#三、USB线连接atlas" class="headerlink" title="三、USB线连接atlas"></a>三、USB线连接atlas</h2><p>我们还是在这个Ubuntu系统内。</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install net-toolsifconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>找到如下内容，这是没配置好的网卡：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ens35u1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        ether 4e:57:14:39:8b:22  txqueuelen 1000  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 88  bytes 20428 (20.4 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了能够让atlas和其他linux系统通过type-c线进行通信，我们在mksd目录下启动命令行，执行<code>sudo bash configure_usb_ethernet.sh</code></p><p>然后执行<code>ssh HwHiAiUser@192.168.1.2</code>即可正常使用ssh连接通信。默认密码<code>Mind@123</code>。</p><p>如果你在虚拟机Ubuntu执行<code>sudo vim /etc/netplan/01-network-manager-all.yaml</code>查看文件配置</p><p>你就会发现，实际上执行完脚本，里面会多出来这一部分语句：</p><pre class="line-numbers language-none"><code class="language-none">network:  version: 2  renderer: NetworkManager  ethernets:     ens35u1:       dhcp4: no       addresses: [192.168.1.166/8]       gateway4: 255.255.255.0       nameservers:         addresses: [114.114.114.114]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而你再输入<code>ipconfig -a</code>可以看到如下信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.112.142  netmask 255.255.255.0  broadcast 192.168.112.255        inet6 fe80::ffdf:db40:6e3a:7437  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:7d:50:10  txqueuelen 1000  (Ethernet)        RX packets 217214  bytes 312285559 (312.2 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 43731  bytes 3099983 (3.0 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens35u1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.1.166  netmask 255.0.0.0  broadcast 192.255.255.255        inet6 fe80::4c57:14ff:fe39:8b22  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 4e:57:14:39:8b:22  txqueuelen 1000  (Ethernet)        RX packets 138  bytes 19845 (19.8 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 472  bytes 80561 (80.5 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>证明已经配置好了。</p><p>在虚拟机Ubuntu进入管理员root用户，输入以下配置：</p><p>！其中，参数ens35u1输入的是上面那份输出内容中<strong>第二个网卡</strong>的名字，ens33输入的是<strong>第一个网卡</strong>的名字。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo "1" &gt; /proc/sys/net/ipv4/ip_forward #允许报文转换iptables -t nat -A POSTROUTING -o &lt;ens33&gt; -s 192.168.1.0/24 -j MASQUERADEiptables -A FORWARD -i &lt;ens35u1&gt; -o &lt;ens33&gt; -m state --state RELATED,ESTABLISHED -j ACCEPTiptables -A FORWARD -i &lt;ens35u1&gt; -o &lt;ens33&gt; -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在ssh连接atlas的终端进入管理员账户，输入以下指令</p><p>其中[192.168.1.166]对应的是第二个网卡（atlas的）对应ip</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">route add default gw [192.168.1.166] dev usb0vim /etc/systemd/resolved.conf# 按i进入编辑模式，加入DNS=114.114.114.114 :wqping baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后你就会发现，atlas可以通过usb线联网。</p><h2 id="四、路由器连Atlas"><a href="#四、路由器连Atlas" class="headerlink" title="四、路由器连Atlas"></a>四、路由器连Atlas</h2><p>在开发板root账户下，输入<code>vim /etc/netplan/01-netcfg.yaml</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">network:  version: 2  renderer: networkd  ethernets:    eth0:      dhcp4: no #改为yes，保存退出      addresses: [192.168.0.2/24]      gateway4: 192.168.0.1      nameservers:            addresses: [114.114.114.114]    usb0:      dhcp4: no      addresses: [192.168.1.2/24]      #gateway4: 192.168.1.1      nameservers:            addresses: [114.114.114.114]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用网线连接开发板到一个可以上网的路由器当中，这个路由器需要开启DHCP。</p><p>输入<code>netplan apply</code></p><p>在Ubuntu虚拟机里面执行<code>ssh HwHiAiUser@192.168.0.2</code>，即可连上atlas</p><h2 id="五、网线共享网络"><a href="#五、网线共享网络" class="headerlink" title="五、网线共享网络"></a>五、网线共享网络</h2><p><strong>此过程建议提前将type-c先和网线一并连接好</strong></p><p>进入*<em>\控制面板\网络和 Internet\网络连接\*</em></p><img src="https://bbs-img.huaweicloud.com/blogs/img/1609137121924096771.png"><p><img src="https://bbs-img.huaweicloud.com/blogs/img/1609137189933024388.png"></p><p>其余的配置和<strong>四、路由器连Atlas</strong>步骤是一致的，都需要修改/etc/netplan/01-netcfg.yaml，都需要<code>netplan apply</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atlas 200DK </tag>
            
            <tag> Linux </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述(第一部分)</title>
      <link href="/2022/04/05/operating_system1/"/>
      <url>/2022/04/05/operating_system1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="操作系统——第一章-系统概述"><a href="#操作系统——第一章-系统概述" class="headerlink" title="操作系统——第一章: 系统概述"></a>操作系统——第一章: 系统概述</h1><h2 id="1-1-基本概念（定义）"><a href="#1-1-基本概念（定义）" class="headerlink" title="1.1 基本概念（定义）"></a>1.1 基本概念（定义）</h2><ul><li>操作系统（operating system，os）是系统资源的<strong>管理者</strong>，管理<strong>软件、硬件资源</strong>，给用户和其他软件方便的接口和环境，是一个<strong>系统软件</strong>。</li></ul><h2 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2  操作系统特征"></a>1.2  操作系统特征</h2><h3 id="1-并发（concurrence）"><a href="#1-并发（concurrence）" class="headerlink" title="1. 并发（concurrence）"></a>1. 并发（concurrence）</h3><p>微观上交替进行，宏观上同时执行。（操作系统和程序并发是一起诞生的）</p><ul><li>重点：<ul><li>单核CPU：同一时刻只能执行一个程序，各个程序只能<strong>并发</strong>执行。</li><li>多核CPU：同一时刻可以同时执行多个程序，多个程序可以<strong>并行</strong>执行。</li></ul></li></ul><h3 id="2-共享（sharing）"><a href="#2-共享（sharing）" class="headerlink" title="2. 共享（sharing）"></a>2. 共享（sharing）</h3><p>系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>互斥：系统中某些资源，虽然可以给多进程使用，但一个时间段内只允许一个进程访问该资源。</p><p>同时：系统中某些资源，允许一个时间段内由多个进程 “同时” 对他们进行访问。（微观上可能是交替的）</p><pre class="mermaid">graph LRA(两种资源共享方式) --&gt;B(互斥共享方式)    B --&gt;C(一个时间段内只允许一个进程访问该资源)    A --&gt;D(同时共享模式)    D --&gt;E(一个时间段内由多个进程 同时 对他们进行访问)    F[sharing]</pre><p><strong>注意</strong>：并发和共享是操作系统两个最基本特征，<strong>两者互为存在条件</strong>：</p><ol><li>资源共享是一程序并发为条件的。（若系统不允许程序并发执行，自然不存在资源共享问题）</li><li>若系统不能对资源共享进行有效管理，一定影响到程序的并发执行。</li></ol><h3 id="3-虚拟（virtual）"><a href="#3-虚拟（virtual）" class="headerlink" title="3. 虚拟（virtual）"></a>3. 虚拟（virtual）</h3><ul><li>可归纳为：<ul><li>时分复用技术：如处理器的分时共享（微观：处理机在微小时间段为各个进程服务，大时间分成小时间）</li><li>空分复用技术：如虚拟存储器</li></ul></li></ul><p>详见第三章</p><h3 id="4-异步（asynchronism）"><a href="#4-异步（asynchronism）" class="headerlink" title="4. 异步（asynchronism）"></a>4. 异步（asynchronism）</h3><p>并发的程序不是从头走到底的，是“走走停停”，如果进程正在占用资源，其他进程需要先被阻塞，等待资源释放。</p><h2 id="1-3-操作系统运行机制"><a href="#1-3-操作系统运行机制" class="headerlink" title="1.3 操作系统运行机制"></a>1.3 操作系统运行机制</h2><ul><li><p>实现操作系统，需要写<strong>内核程序</strong>，很多个内核程序组成**操作系统内核(kernel)**，简称内核，是整个操作系统最核心的部分。</p><ul><li>操作系统有个内核就足够了 (eg. Docker容器 -&gt; 仅需linux内核)</li><li>操作系统的功能未必都在内核中，如GUI图形化界面</li></ul></li><li><p>CPU设计的时候就划分了特权指令和非特权指令</p><ul><li>应用程序只能运行非特权指令（如加法减法）</li><li>内核程序可以运行特权指令（如内存清0指令，这条指令影响重大，只允许“管理者”——即操作系统内核来使用）。</li></ul></li><li><p>但是CPU运行的时候，只会把一条一条指令（二进制指令）送进去运行，怎么判断运行的程序是应用程序指令还是内核程序的指令？</p><p>此时我们把CPU划分成为两种状态，<strong>”内核态“</strong>，<strong>“用户态”</strong></p><ul><li><p>内核态：说明此时运行的是<code>内核程序</code>，<strong>可以执行特权指令</strong></p></li><li><p>用户态：说明此时运行的是<code>应用程序</code>，<strong>只能执行非特权指令</strong></p></li><li><p>CPU中的寄存器**程序状态字寄存器（PSW)**，其中有一个二进制位，1表示内核态，0表示用户态</p><p>当需要交换状态，修改PSW值即可</p></li></ul></li></ul><h2 id="1-4-中断和异常"><a href="#1-4-中断和异常" class="headerlink" title="1.4 中断和异常"></a>1.4 中断和异常</h2><ul><li>中断的作用：如果应用程序运行的时候，发生了中断，就会让cpu立即停止此时运行的应用程序，转而执行相应的内核程序。中断是让管理者（操作系统内核）夺回使用权的唯一途径，而中断，会使CPU由用户态转变为内核态</li></ul><pre class="mermaid">graph LRA(内核态 -&gt; 用户态) --&gt;B(用特权指令 修改PSW的值)C(用户态 -&gt; 内核态) --&gt;D(引发 中断 硬件自动完成 CPU状态转换过程 强行夺回CPU使用权)</pre><ul><li><p>中断的类型：</p><ul><li><p>内中断（也叫做 <strong>异常</strong>）：与当前执行指令有关，中断信号来源于CPU内部</p><p>有时候应用程序想请求操作系统内核的服务，此时会执行一条<strong>特殊的指令——陷入指令</strong>。该指令会引发一个内部中断信号。应用程序主动吧使用权归还给操作系统，希望操作系统提供某项服务。（先传入所需的参数，再调用陷入指令）</p><ul><li>而<strong>系统调用</strong>就是利用陷入指令来完成</li><li><strong>陷入指令并不是特权指令</strong>,陷入指令在用户态执行，执行后立刻引发一个<strong>内中断</strong>，使CPU进入内核态。</li></ul><p>异常分三个种类：</p><ul><li><p>陷阱、陷入（trap）：</p><p>由陷入指令引发，是应用程序故意引发的</p></li><li><p>故障（fault）：</p><p>由错误条件引起，可能被内核程序修复。内核程序修复后会把CPU使用权还给应用程序，让他继续执行下去。如：缺页故障</p></li><li><p>终止（abort）：</p><p>由致命错误引起，内核程序无法修复，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0，非法使用特权指令</p></li></ul></li><li><p>外中断（狭义上统称 <strong>中断</strong>）：与当前执行指令无关，中断信号来源于CPU外部</p><p>例子：时钟中断。由时钟部件（在cpu的外部）发来中断信号，实现程序并发的重要前提。</p><p>​            io设备提供中断信号。这些中断信号让操作系统可以很好的调度各个进程。</p><p>外部中断又分可屏蔽中断<strong>INTR</strong>和不可屏蔽中断<strong>NMI</strong></p></li></ul></li><li><p>中断机制的基本原理：</p><p>  不同类型的中断信号，需要用不同的中断处理程序来处理。查询<strong>中断向量表</strong>，以此来找到相应的中断处理程序在内存中存放的位置。</p></li></ul><p>显然，中断处理程序一定是在内核态的，需要运行在内核态（涉及计算机组成原理）</p><h2 id="1-5-系统调用"><a href="#1-5-系统调用" class="headerlink" title="1.5 系统调用"></a>1.5 系统调用</h2><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单好用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p><pre class="mermaid">graph TDA[应用程序] --&gt; system(系统调用)    A --&gt; |高级语言| C(c库函数)    C --&gt; system(系统调用)    system(系统调用) --&gt; operating[操作系统]    F[系统调用与库函数的区别]</pre><pre class="mermaid">graph LRA(系统调用 按功能分类) --&gt;B(设备管理 完成对设备的 请求/释放/启动 等功能)A --&gt;C(文件管理 完成对文件的 读/写/创建/删除 等功能)A --&gt;D(进程控制 完成进程的 创建/撤销/阻塞/唤醒 等功能)A --&gt;E(进程通信 完成进程之间的 消息传送/信号传递 等功能)A --&gt;F(内存管理 完成内存的 分配/回收 等功能)</pre><p>*拓展链接：<a href="https://www.cnblogs.com/wanghuaijun/p/6548633.html">linux提供了哪些系统调用</a></p><ul><li><p>凡是与共享资源有关的操作（如存储分配、IO操作、文件管理等），都必须通过系统调用的方式向<strong>操作系统内核</strong>提出服务请求。由内核代为完成，保证系统的稳定性与安全性。（也防止用户非法操作）</p></li><li><p>总结：</p><ul><li><p>陷入指令是在用户态执行，执行陷入指令后立即引发一个内中断，使CPU进入内核态。</p></li><li><p>发出系统调用的请求是在用户态，而对系统调用的相应处理是在内核态下进行。</p></li></ul></li><li><p>别名：</p><ul><li><p><strong>内核态=核心态=管态</strong>  </p></li><li><p><strong>用户态=目态</strong>  </p></li><li><p><strong>陷入指令=trap指令=访管指令</strong></p></li></ul></li><li><p>访管指令的基本功能是让程序拥有 “自愿进管” 的手段。从而引起访管中断。访管中断处理程序将按照系统调用的操作数和参数转到相应的例行子程序<sup class="refplus-num"><a href="#ref-r">[1]</a></sup>。完成服务功能后，退出中断，返回到用户程序断点继续执行。</p><ul id="refplus" style="display:none;"><li id="ref-r" data-num="1">[1]   例行程序 (routine)亦称例程.一种计算机程序.是与一项计算任务相对应的处理对象和处理规则的描述.可以是一个主程序的一部分或一个专用程序，也可包含若干个子程序.它一般在一个程序或多个程序中多次使用.例行程序和子程序常常存放在程序库中，通常存储在外存储器上.</li></ul><p></p></li></ul><h2 id="1-6-操作系统的体系结构"><a href="#1-6-操作系统的体系结构" class="headerlink" title="1.6 操作系统的体系结构"></a>1.6 操作系统的体系结构</h2><h3 id="1-分层法"><a href="#1-分层法" class="headerlink" title="1 分层法"></a>1 分层法</h3><p>将操作系统分为若干层，最底层（层0）为硬件，最高层（层N）为用户接口。每层只能调用紧邻它的低层的功能与服务（单向依赖）</p><ul><li>优点：<ul><li>便于系统的调试和验证，简化了系统设计与实现。</li><li>易扩充、易维护：增加、修改或替换其中一层，只要不改变接口，就不会影响其它层。</li></ul></li><li>缺点：<ul><li>各层合理定义较难，依赖关系稳定之后，往往不够灵活。</li><li>效率较差，通常调用的时候需要自上而下地穿越多层，增加开销。</li></ul></li></ul><h3 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2 模块化"></a>2 模块化</h3><p>是将操作系统按功能分为若干个功能模块。每个模块具有某种功能，并规定好接口，使各个模块之间可以通信。然后细分下各个子模块，这种设计方法叫做<strong>模块-接口法</strong>。</p><p>划分模块的时候，如果分的太小，虽然可以降低模块本身的复杂性，但会使得模块之间的联系过多，造成系统比较混乱。如果模块分的过大，会增加模块内部复杂性。</p><p>而且，划分模块的时候，要充分考虑模块的独立性，独立性越高，各个模块之间交互就变少，系统结构也就越清晰。衡量模块的独立性主要有两个标准：</p><ul><li><p>内聚性：模块内部各个部分联系的紧密程度。内聚性越高，模块独立性越好。</p></li><li><p>耦合度：模块间相互联系和相互影响的程度。耦合性越高，模块独立性越好。</p></li><li><p>优点：</p><ul><li>提高了操作系统设计的正确性、可理解性、可维护性</li><li>增强了操作系统的课适应性</li><li>加速了操作系统的开发过程</li></ul></li><li><p>缺点：</p><ul><li>模块间的接口规定很难满足对接口的实际需求</li><li>各个模块规格的设计没有一个统一的好答案，没找到可靠的决定顺序</li></ul></li></ul><h3 id="3-内核架构"><a href="#3-内核架构" class="headerlink" title="3 内核架构"></a>3 内核架构</h3><p><strong>而操作系统从内核上分大致分为两点：</strong></p><ul><li><p>大内核/单内核/宏内核 </p><ul><li>操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码量庞大，结构混乱，难以维护</li><li>典型的大内核操作系统：Linux、Unix</li></ul></li><li><p>微内核</p><ul><li><p>只把最基本的功能留在内核</p></li><li><p>微内核基本功能：</p><ul><li><p>进程/线程管理</p></li><li><p>低级存储器管理</p><p>在微内核中，只配置了最基本的低级存储器管理机制。如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制，这一部分需要依赖于硬件，因此放入微内核。</p><p>而实现虚拟存储器管理的策略，则包含应采取何种页面置换算法，采用何种内存分配与回收的策略，应将这部分放在微内核外的存储器管理服务器中。</p></li><li><p>中断和陷入处理</p></li></ul></li><li><p>优点：内核功能少，结构清晰，方便维护</p></li><li><p>缺点：需要频繁地在内核态和用户态切换，容易降低CPU性能</p></li><li><p>典型的微内核操作系统：Windows NT</p></li><li><p>定义微内核结构OS的四个方面：</p><ul><li><p>足够小的内核</p></li><li><p>基于客户/服务器模式</p></li><li><p>应用<strong>机制与策略分离</strong>原理</p><ul><li><p>机制是指实现某一功能的具体执行机构</p></li><li><p>策略是指在机制的基础上借助于某些参数和算法来实现该功能的优化，或者达到不同的功能目标。</p><p>传统OS中，将机制放在OS内核的较低层中，把策略放在内核的较高层。而微内核OS中，通常将机制放在微内核里，才能把内核做的很小</p></li></ul></li><li><p>采用面向对象技术</p><p>基于面向对象技术中的<strong>抽象</strong>与<strong>隐蔽</strong>原则，能控制系统的复杂性。进一步利用<strong>对象、封装、继承</strong>等概念还能确保系统运行的正确、可靠、易扩展性。也是因为如此，面向对象技术被广泛应用在操作系统的设计中。</p></li></ul></li></ul></li></ul><p>操作系统主要分两个板块：</p><ul><li><p>非内核功能：如GUI</p></li><li><p>内核功能：</p><ul><li><p>与硬件管理较紧密的模块</p><ul><li>时钟管理（利用时钟中断实现计时功能）</li><li>中断处理</li><li>原语（设备驱动、CPU切换等）<ul><li>是一种特殊程序</li><li>处于操作系统最底层，是最接近硬件的部分</li><li>这种程序具有原子性，运行必须一气呵成，不可被中断。</li><li>运行时间短，调用频繁</li></ul></li></ul></li><li><p>这些管理工作更多是对数据结构的操作，不会直接涉及硬件。</p><ul><li><p>把这部分功能也写进内核的内核叫大内核。反之，只有时钟，中断，原语的内核称之为微内核，其进程管理等等内容将运行在用户态，对性能有一定的影响。</p></li><li><p>进程管理、存储器管理、设备管理等功能</p></li></ul></li><li><p>这些内核功能，必须运行在内核态</p></li><li><p>微内核相比大内核，CPU运行状态的转换（psw）的次数会变多。CPU运行状态的转换是有成本的，消耗不少时间。频繁转换运行状态会降低系统性能</p></li></ul></li><li><p>Ubuntu、centos的开发团队主要是实现了非内核功能，而内核功能都是用了Linux内核。</p></li></ul><h2 id="1-7-操作系统的发展与分类"><a href="#1-7-操作系统的发展与分类" class="headerlink" title="1.7 操作系统的发展与分类"></a>1.7 操作系统的发展与分类</h2><h3 id="1-手工操作阶段"><a href="#1-手工操作阶段" class="headerlink" title="1 手工操作阶段"></a>1 手工操作阶段</h3><ul><li><p>纸带机打孔</p></li><li><p>缺点：用户独占全集，”人机速度矛盾“ 导致资源利用率低。</p></li><li><p>人机速度矛盾:人需要很长时间写纸带代码，且一次只能由一名程序员使用计算机，不允许多人使用；而计算机很快就可以运行完纸带代码</p></li></ul><h3 id="2-单道批处理系统"><a href="#2-单道批处理系统" class="headerlink" title="2 单道批处理系统"></a>2 单道批处理系统</h3><ul><li><p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序（操作系统的雏形）</strong>负责控制作业的输入输出，磁带读取熟读比纸带快很多</p></li><li><p>主要优点：缓解一定程度的人及速度矛盾，资源利用率有一定的提升</p></li><li><p>主要缺点：内存中仅能有一道程序运行，运行结束才能进行下一道（串行执行）。而<strong>CPU有大量的时间在空闲等待IO完成</strong>，资源利用率还是不高</p></li></ul><h3 id="3-多道批处理系统"><a href="#3-多道批处理系统" class="headerlink" title="3 多道批处理系统"></a>3 多道批处理系统</h3><ul><li><p>每次往内存中读取多道程序</p></li><li><p>操作系统正式诞生，支持多道程序并发运行</p></li><li><p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源，<strong>资源利用率大幅度提升</strong>，CPU和其他组员更能保持 “忙碌” 状态，系统吞吐量增大</p></li><li><p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业指挥就只能等待计算机处理完毕，中间不能控制自己的作业执行</p><p>如：无法调试程序，无法在程序运行中输入参数）</p></li></ul><h3 id="4-分时操作系统"><a href="#4-分时操作系统" class="headerlink" title="4 分时操作系统"></a>4 分时操作系统</h3><ul><li><p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可以通过终端与计算机进行交互</p></li><li><p>主要优点：用户请求可以被即时响应，<strong>解决人机交互的问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</p></li><li><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是公平的，循环地为每个用户/作业服务一个时间片，不区分任务优先级/紧急性。</p></li></ul><h3 id="5-实时操作系统"><a href="#5-实时操作系统" class="headerlink" title="5 实时操作系统"></a>5 实时操作系统</h3><ul><li><p>计算机接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p><ul><li><p>硬实时系统：必须在绝对严格的时间内完成任务</p><ul><li>如：自动驾驶系统</li></ul></li><li><p>软实时系统：能够接受偶尔的违反时间规定</p><ul><li>如：订票系统（实时更新票数）</li></ul></li></ul></li><li><p>主要优点：能够及时响应一些紧急任务，某些优先级高的任务不需要时间片排队。</p><h3 id="6-其他操作系统"><a href="#6-其他操作系统" class="headerlink" title="*6 其他操作系统"></a>*6 其他操作系统</h3></li><li><p>网络操作系统：实现网络中各种资源的共享（文件共享）和各个计算机之间的通信</p></li><li><p>分布式操作系统：特点是分布性、并行性，任何任务都可以分布在这些计算机上，并行协同地完成任务</p></li><li><p>个人操作系统：Windows、macOS等等</p></li></ul><h2 id="1-8-操作系统引导"><a href="#1-8-操作系统引导" class="headerlink" title="1.8 操作系统引导"></a>1.8 操作系统引导</h2><p>常见的操作系统引导流程如下</p><ul><li><p>激活CPU：</p><p>激活的CPU读取[ROM]<sup class="refplus-num"><a href="#ref-ROM">[1]</a></sup>中的boot程序，将指令寄存器置为BIOS<sup class="refplus-num"><a href="#ref-BIOS">[2]</a></sup>的第一条指令，即开始执行BIOS的指令。  </p><ul id="refplus" style="display:none;"><li id="ref-ROM" data-num="1">[1]  只读存储器，即使切断电源，信息也不会丢失，又称为固定存储器。整机工作过程中只能读出，不能像随机存储器能快速方便地改写存储内容。</li><li id="ref-BIOS" data-num="2">[2]   基本输入输出系统</li></ul><p></p></li><li><p>硬件自检：</p><p>启动BIOS程序之后，先进行硬件自检，检测是否故障。如有故障，用蜂鸣器发出不同含义的蜂鸣；如无故障，屏幕会开始显示cpu，内存，硬盘等等信息。</p></li><li><p>加载带有操作系统的硬盘：</p><p>BIOS在自检结束后，开始读取Boot Sequence(通过CMOS里存的启动顺序，或者通过与用户交互的方式)，把控制权交给排序第一位的设备。然后CPU将该存储设备的<strong>引导扇区</strong>的内容存至内存中。</p></li><li><p>加载主引导记录<strong>MBR</strong>：</p><p>硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现该盘不是可引导盘，就换下一个。若没有课引导盘，会导致死机。<strong>主引导记录MBR的作用就是告诉CPU去硬盘的哪个分区去寻找操作系统</strong>。</p></li><li><p>扫描硬盘分区表，并加载硬盘活动分区：</p><p>MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘的活动分区之后，开始加载硬盘的活动分区，将控制权交给活动分区。</p></li><li><p>加载分区引导记录PBR：</p><p>读取活动分区的第一个扇区，这个扇区称为**分区引导记录(PBR)**，其作用是寻找并激活分区根目录下，用于引导操作系统的程序（启动管理器）。</p></li><li><p>加载启动管理器：</p><p>分区引导记录搜索活动分区中的启动管理器，并加载它。</p></li><li><p>加载操作系统</p></li></ul><h2 id="1-9-虚拟机"><a href="#1-9-虚拟机" class="headerlink" title="1.9 虚拟机"></a>1.9 虚拟机</h2><p>虚拟机是一台逻辑计算机。通过隐藏特点计算平台的实际物理特性，为用户提供抽象、统一、模拟的计算环境。有两种虚拟方法。</p><h3 id="1-第一类虚拟管理程序"><a href="#1-第一类虚拟管理程序" class="headerlink" title="1 第一类虚拟管理程序"></a>1 第一类虚拟管理程序</h3><p>该虚拟机作为用户态执行，不允许使用特权指令。而虚拟机上的操作系统认为自己是在内核态（实际上不是），成为虚拟内核态。</p><p>在支持虚拟化的CPU上，执行特权指令时，，虚拟机管理程序会检测是虚拟机中的操作系统执行的还是虚拟机中的用户程序执行的。前者，会安排正常执行；否则，虚拟机管理程序会模拟真实硬件，面对用户，模拟执行特权指令时的行为。</p><h3 id="2-第二类虚拟管理程序"><a href="#2-第二类虚拟管理程序" class="headerlink" title="2 第二类虚拟管理程序"></a>2 第二类虚拟管理程序</h3><p>是一类与操作系统分配和调度资源的程序，很像一个普通的进程。。这一类仍然伪装成具有CPU和各种资源的完备计算机。VMware是首个在x86上的第二类虚拟管理程序。</p><p>刚开始启动的时候，这一类虚拟管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（宿主操作系统中的一个文件）。安装完成后即可运行。</p><p>有的说法，把第一类成为<strong>裸金属架构</strong>，第二类称为<strong>寄居架构</strong>。</p>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机知识 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈搭建Matery的一些流程</title>
      <link href="/2022/04/02/build-matery/"/>
      <url>/2022/04/02/build-matery/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="浅谈搭建matery的一些流程"><a href="#浅谈搭建matery的一些流程" class="headerlink" title="浅谈搭建matery的一些流程"></a>浅谈搭建matery的一些流程</h1><p>好不容易完善了该matery，发现自己并没有记录如何真正搭建的流程。</p><p>乘着刚搭建不久，来记录一下搭建<code>hexo-theme-matery</code>的一些流程</p><h2 id="0，介绍开发环境"><a href="#0，介绍开发环境" class="headerlink" title="0，介绍开发环境"></a>0，介绍开发环境</h2><ul><li><p>长年未更新的老Win10，以及更新过的vscode</p></li><li><p>这里建议参考以下几个链接一起看</p><ul><li><a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></li><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/">https://godweiyang.com/2018/04/13/hexo-blog/</a></li><li><a href="https://www.matemaster.cn/posts/52745.html">https://www.matemaster.cn/posts/52745.html</a></li></ul></li></ul><h2 id="1，搭建node-js等等初步工作环境"><a href="#1，搭建node-js等等初步工作环境" class="headerlink" title="1，搭建node.js等等初步工作环境"></a>1，搭建node.js等等初步工作环境</h2><p>先去官网下载<a href="https://nodejs.org/en/">node.js</a>，选择稳定版即可</p><p><img src="https://s2.loli.net/2022/04/03/dOYo2q4nPvJhrcl.png"></p><p>一路默认安装即可。装完会有两个组件，一个是node.js本身，一个是npm组件。</p><ul><li>自己新建一个文件夹，以后的网页代码全放在里面，我的是在d:/tuoyou-hao</li><li>用vscode打开这个文件夹（或者你用命令行 cd 进去 也可以），在vscode打开终端，输入以下指令</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">&gt; node -vv16.14.2&gt; npm -v8.5.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于npm下载速度较慢，我们可以选用淘宝的源下载。我们用npm下载cnpm：</p><p><code> &gt; npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>下载完成后，输入<code>cnpm -v</code>检查一下，输出下列内容即为正常</p><p><img src="https://s2.loli.net/2022/04/03/WDuRxhQiZV1w9IN.png"></p><p>然后我们开始安装hexo</p><pre class="line-numbers language-none"><code class="language-none">&gt; cnpm install -g hexo-cli &gt; hexo -vINFO  Validating confighexo: 6.1.0hexo-cli: 4.3.0os: win32 10.0.17134node: 16.14.2v8: 9.4.146.24-node.20uv: 1.43.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1n+quiccldr: 40.0icu: 70.1tz: 2021a3unicode: 14.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV# 显示如上内容，hexo就是正常的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个文件夹里面 <code>hexo init</code></p><p>hexo会为你生成很多文件，然后下载并配置一个默认主题（在theme文件夹）</p><p>配置完成后，命令行输入<code>hexo s</code>即可在本地localhost:4000看到hexo给你生成的网页</p><p>进入\source\_posts文件夹底下，就是存放你的博客的地方，使用markdown格式编写。</p><p>确认完毕以后，先去申请一个新的GitHub仓库</p><p>会让你填写自己GitHub的地址。此时需要申请自己的GitHub，并将仓库命名为&lt;你的GitHub名字&gt;.github.io</p><ul><li><p>比如我的GitHub名字叫tuoyou-hao，创建的新仓库就叫做“tuoyou-hao.github.io”。<strong>必须符合该命名格式</strong>！</p><p>创建完该仓库即可，无需进行其他操作</p></li><li><p>去配置GitHub的ssh key，建立ssh链接，具体步骤参考：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account</a></p></li></ul><p>配置完毕后，执行该指令，下载GitHub推送工具</p><p><code>cnpm install --save hexo-deployer-git</code></p><p>然后修改根目录下<code>_config.yml</code>里头的配置，找到deploy选修</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git  repository: git@github.com:xxx/xxx.github.io.git #填你的仓库名  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行hexo指令。命令行常用以下指令：</p><pre class="line-numbers language-none"><code class="language-none">hexo clean #清理本地生成文件hexo g  # 生成博客网页文件hexo s  # 本地预览博客hexo d  # 上传网页文件到github<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>hexo d完毕以后，进入你xxx.gihub.io网站，即可查看到你部署的网页（会有几分钟的延迟）</p><h2 id="2，配置matery"><a href="#2，配置matery" class="headerlink" title="2，配置matery"></a>2，配置matery</h2><ul><li><p>git clone该链接到themes文件夹：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p></li><li><p>并把根目录下<code>_config.yml</code>文件里的theme参数改成你clone的文件夹名字（我自己重命名叫matery，theme参数也要叫matery）</p></li><li><p>在matery主题文件夹里面也有一个<code>_config.yml</code>文件，还有一个<code>README_CN.md</code>文件，请你一定要认真仔细看那份文件，需要根据那份文件下载各种依赖。下载完成后，根据自己的需要去配置</p></li><li><p>配置完成就发布到自己的GitHub仓库吧</p></li></ul><h2 id="3，百度推送"><a href="#3，百度推送" class="headerlink" title="3，百度推送"></a>3，百度推送</h2><p>在百度推送上，建议参考：<a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1</a></p><p>登录该网站：<a href="https://ziyuan.baidu.com/">https://ziyuan.baidu.com/</a></p><p>登录成功后，在用户中心-&gt;站点管理-&gt;添加网站操作 </p><p>然后如何寻找token呢，token=秘钥：</p><p><img src="https://s2.loli.net/2022/04/03/j4m8YTUfV29Dei3.jpg"></p><p>其中matery内置了推送功能，我们只需要写好参数即可。</p><pre class="line-numbers language-none"><code class="language-none">deploy:- type: git  repository: git@github.com:xxx/xxx.github.io.git  branch: master- type: baidu_url_submitter #记得在deploy下配置这一句baidu_url_submit:  count: 20 # 提交最新的一个链接  host: https://xxx.github.io # 在百度资源搜索平台中注册的域名  token: xxxxxxx # 请注意这是推送秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4，-配置评论控件"><a href="#4，-配置评论控件" class="headerlink" title="4， 配置评论控件"></a>4， 配置评论控件</h2><p>首先，在matery底下，将js底下的twikoo更新至最新版</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">js:twikoo: https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参考链接：<a href="https://twikoo.js.org/quick-start.html#%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2">https://twikoo.js.org/quick-start.html#%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2</a></p><ol><li><p>申请 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDB (opens new window)</a>账号</p></li><li><p>创建免费 MongoDB 数据库，区域推荐选择 <code>AWS / N. Virginia (us-east-1)</code></p></li><li><p>在 Clusters 页面点击 CONNECT，按步骤设置允许所有 IP 地址的连接（<a href="https://vercel.com/support/articles/how-to-allowlist-deployment-ip-address">为什么？ (opens new window)</a>），创建数据库用户，选择connect，一定要选择链接您的应用，那个数据库连接字符串才是我们需要的，请将连接字符串中的 <code>password</code> 修改为数据库密码</p><p><img src="https://s2.loli.net/2022/04/03/kLJfdnUmFrqZleC.png"></p><p><img src="https://s2.loli.net/2022/04/03/jmieJ9aAYcXLISO.png"></p></li><li><p>申请 <a href="https://vercel.com/signup">Vercel (opens new window)</a>账号</p></li><li><p>进入以下网址把 Twikoo 一键部署到 Vercel<br><a href="https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/dev/src/vercel-min">https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/dev/src/vercel-min</a></p></li><li><p>进入 Settings - Environment Variables，添加环境变量 <code>MONGODB_URI</code>，值为第 3 步的数据库连接字符串</p></li><li><p>进入 Overview，点击 Domains 下方的链接，如果环境配置正确，可以看到 “Twikoo 云函数运行正常” 的提示</p></li><li><p>Vercel Domains（包含 <code>https://</code> 前缀，例如 <code>https://xxx.vercel.app</code>）整个网址即为您的环境 id</p></li><li><p>把网址贴进主题的_config.yml里头对应的twikoo的envId，并启用twikoo功能。</p></li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">twikoo:  enable: true  visitor: true  envId: https://xxxx.app #搭建教程：https://twikoo.js.org/quick-start.html  # region: ap-guangzhou # 环境地域，默认为 ap-shanghai  path: 'window.location.pathname' # 自定义文章路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5，-配置图像上传"><a href="#5，-配置图像上传" class="headerlink" title="5， 配置图像上传"></a>5， 配置图像上传</h2><p>在写本篇博客的时候，当我推送上来的时候，意外的发现文章的图片迟迟读取不了，测试过以下指令，反而本地localhost也读取不了了<br><code>cnpm install https://github.com/CodeFalling/hexo-asset-image –save</code></p><p>由于我并非前端工作者，对这方面知识还是比较匮乏，你们可以参考这个教程的解决方法：<br><a href="https://www.cnblogs.com/hugochen1024/p/12570656.html">https://www.cnblogs.com/hugochen1024/p/12570656.html</a></p><p>我自己是注册<code>SM.MS</code>网站，链接：<a href="https://sm.ms/">https://sm.ms/</a><br>在该网站上传图片，网站会给你一个链接，导入该链接的图片即可。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Matrey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速入门Makefile(新手向)</title>
      <link href="/2022/03/31/Makefile-quick-get-start/"/>
      <url>/2022/03/31/Makefile-quick-get-start/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="快速入门Makefile-新手向"><a href="#快速入门Makefile-新手向" class="headerlink" title="快速入门Makefile(新手向)"></a>快速入门Makefile(新手向)</h1><h2 id="1、什么是Makefile"><a href="#1、什么是Makefile" class="headerlink" title="1、什么是Makefile"></a>1、什么是Makefile</h2><p>​        特别是在 Unix 下的软件编译，如果你正在开发一个大型的工程，你就不能不自己写Makefile了。</p><p>​        因为，Makefile关系到了整个代码工程的编译规则。一个工程中的源文件不计数，按类型、功能、模块分别放在若干个目录中，Makefile定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行其他更加复杂的操作。Makefile就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。</p><p>​        Makefile带来的好处就是——“自动化编译”，一旦你写好了Makefile，只需要一个<code>make </code>命令，整个工程就会完全自动编译，极大的提高了软件开发效率。</p><p>​        在我还刚接触Makefile的时候，我常常苦恼于找不到易读好懂的Makefile教程。本篇仅仅快速描述一个简单的Makefile应该是什么样子的，介绍一些基本的指令和语法，便于快速熟悉相关的指令。</p><h2 id="2、Makefile的一些基本规则"><a href="#2、Makefile的一些基本规则" class="headerlink" title="2、Makefile的一些基本规则"></a>2、Makefile的一些基本规则</h2><ul><li>本篇将以C语言的源码为基础，默认使用gcc编译器，需要有相关的前置知识</li></ul><p>make 命令执行时，需要一个Makefile文件，以告诉 make 命令需要怎么样的去编译和链接程序。 文件名只能用makefile、Makefile或者GNUmakefile 。最常用的是<code>makefile</code>、<code>Makefile</code>。</p><p>(如果你非要使用别的名字来命名Makefile，需要使用指令make后加参数<code>-f</code>/<code>--file</code>，如 <code>make -f your_makefile_name.md</code> )</p><ul><li>Makefile 的基本规则。<ul><li>如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。 </li><li>如果这个工程的某几个 C 文件被修改，那么我们只会编译被修改的 C 文件，并链接目标程序。 </li><li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件， 并链接目标程序。</li></ul></li></ul><h2 id="3、Makefile编写"><a href="#3、Makefile编写" class="headerlink" title="3、Makefile编写"></a>3、Makefile编写</h2><h3 id="3-1-来写一个最简单的Makefile"><a href="#3-1-来写一个最简单的Makefile" class="headerlink" title="3.1 来写一个最简单的Makefile"></a>3.1 来写一个最简单的Makefile</h3><p>我们来看这一段代码<code>a.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void main(){printf("Hello World\n");}//a.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常简单。加入我们要在Linux下编译运行，应该要怎么做</p><p>是的，在shell中使用gcc编译，生成一个可执行的二进制文件。直接执行这个文件就会显示“Hello Worrld”</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc a.c -o a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我要在Makefile里面编译这个a.c的代码，应该怎么写？</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a:a.cgcc a.c -o a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你查阅过和Makefile相关的资料，你可能会看到这段文字</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">target ... : prerequisites ...              command              ...              ...  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 你可以对照上面编译a.c的Makefile代码来看。</p><ul><li><p>target 也就是目标文件，可以是 Object File，也可以是执行文件（比如a.c生成的 a 可执行文件）。还可以是一个标签，标签本章暂不介绍，后续的博客再做介绍。 </p></li><li><p>prerequisites 就是，要生成那个 target 所需要的文件或是目标。 (a 可执行文件的生成需要依赖于 a.c)</p></li><li><p>command 也就是 make 需要执行的命令。（任意的 Shell 命令，比如调用gcc）</p></li></ul><p>而介绍完基本语句，我们就得回头来看一下make的工作方式。</p><h3 id="3-2-make的工作方式"><a href="#3-2-make的工作方式" class="headerlink" title="3.2 make的工作方式"></a>3.2 make的工作方式</h3><p>这段文字放在这里我认为才有便于理解</p><p>在默认的方式下，也就是我们只输入 make 命令。那么：</p><ol><li><p>make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。 </p></li><li><p>如果找到，它会找文件中的第一个目标文件（target）</p><p>比如下面这段Makefile，如果我们需要先把 *.c 文件先编译成 *.o 文件，而不是一步到位的编译成可执行文件，可以将上面<code>gcc a.c -o a</code>的步骤拆分成以下两句：</p></li></ol><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">a:a.ogcc a.o -o aa.o:a.cgcc -c a.c -o a.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Makefile会先找到 “a” 这个目标，并把这个文件作为最终的目标文件。其余的各项依赖文件得写在后面，也就是我们的要介绍的：</p><ol start="3"><li><p>如果 a 这个文件不存在，或是 a 所依赖的后面的 [*.o] 文件的文件修改时间要比 a 这个文件新，那么，他就会执行后面所定义的命令，以此生成 a 这个文件。 </p></li><li><p>如果 a 所依赖的 *.o 文件也存在，那么 make 会在当前文件中找目标为 *.o 文件的依赖性，如果找到则再根据那一个规则生成 *.o 文件。（有点像一个堆栈的过程） </p></li><li><p>当然，你的 C 文件和 H 文件等等依赖文件是存在的，于是 make 会生成 *.o 文件，然后再用 *.o  文件完成make 的终极任务，也就是生成执行文件 a 了。</p></li></ol><p>并且和上一次的单个语句编译不同，我们同时还能获得 a.o 的文件</p><h3 id="3-3-多个文件编译"><a href="#3-3-多个文件编译" class="headerlink" title="3.3 多个文件编译"></a>3.3 多个文件编译</h3><p>你现在有一个大工程代码的main代码，是一个计算器，假设你是这样编写的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int add(int, int);int sub(int, int);int mul(int, int);int main(){int a = 2, b = 1;printf("%d+%d=%d\n", a, b, add(a, b));printf("%d-%d=%d\n", a, b, sub(a, b));printf("%d*%d=%d\n", a, b, mul(a, b));return 0;}//main.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，加法，减法，乘法的函数写在其他的文件里面：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int add(int a, int b){return a + b;}//add.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sub(int a, int b){return a - b;}//sub.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int mul(int a, int b){return a*b}//mul.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时我们Makefile就可以这么写：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cal:main.o add.o sub.o mul.ogcc main.o add.o sub.o mul.o -o calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>其中 cal 文件需要<code>main.o add.o sub.o mul.o</code>，而我们各个 *.o 文件需要由各自的 *.c 文件编译而成。</p><p>记住上面这段makefile的样子。我们接下来会介绍很多种方法，简化上面这段makefile。</p><p>比如我们还可以写成这种形式，便于统一管理：</p></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.ocal:main.o add.o sub.o mul.ogcc main.o add.o sub.o mul.o -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果后续我需要加入一个除法功能，或者还要加入其他计算功能，就需要不断地重写Makefile，岂不是很麻烦，于是我们引入：</p><h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h3><p>在makefile中，变量声明的时候需要赋初值。使用的时候在变量名前面加上<code>$</code>号。用小括号或大括号括起来</p><p>(如果你要使用真实的“$”字符，那么你需要用 “$$” 来表示)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.oobjects=main.o add.o sub.o mul.ocal:$(objects)gcc main.o add.o sub.o mul.o -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面这个例子，我们把<code>main.o add.o sub.o mul.o</code>全部放在<code>objects</code>变量底下，使用的时候就可以用<code>$(objects)</code>把里面存的各种变量拿来编译了。变量是可以嵌套使用的，比如：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x = y y = z a := $($(x))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里 := 是赋值的意思，另一种用变量来定义变量的方法，和 = 的区别就是，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。这里的 a 里头存的就是 z 。</p><p>有了变量这个好东西，我们就可以使用：</p><h3 id="3-5-通配符"><a href="#3-5-通配符" class="headerlink" title="3.5 通配符"></a>3.5 通配符</h3><p>我们为了让Makefile自己找被我们更新过的代码，我们可以写成如下形式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))ALL:calmain.o:main.cgcc -c main.c -o main.oadd.o:add.cgcc -c add.c -o add.osub.o:sub.cgcc -c sub.c -o sub.omul.o:mul.cgcc -c mul.c -o mul.ocal:$(obj)gcc $(obj) -o cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>wildcard</code>，纸牌游戏中的 “百搭牌” ，计算机里称为 “通配符” 。会在当前目录自己搜索所有匹配 <code>*.c</code>的文件。（如果你需要使用到路径，碍于篇幅，需要自行了解notdir参数，用法为<code>file=$(notdir $(src))</code>）</li><li><code>patsubst</code>，模式字符串替换函数。<ul><li>里面的<code>%</code>是匹配符，假如说我们有<code>main.c add.c sub.c mul.c</code>这几个文件，使用<code>%</code>可以像使用for循环一样，挨个文件名遍历进去<code>*.c</code>里</li><li>后面<code>$(src)</code>表示：希望<code>patsubst</code>可以遍历哪些文件。我们就遍历当前目录<code>$(src)</code>底下的 *.c 文件</li></ul></li></ul><h3 id="3-6-更多便捷的书写方式"><a href="#3-6-更多便捷的书写方式" class="headerlink" title="3.6 更多便捷的书写方式"></a>3.6 更多便捷的书写方式</h3><p>如果我还想更改代码的名称，就需要自己重写makefile，未免有点太麻烦了。如果可以自己去寻找这些文件就好了。所以我们对上面的代码更新了一下，引入自动化变量，功能不变，写成如下形式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))ALL:calmain.o:main.cgcc -c $&lt; -o $@add.o:add.cgcc -c $&lt; -o $@sub.o:sub.cgcc -c $&lt; -o $@mul.o:mul.cgcc -c $&lt; -o $@cal:$(obj)gcc $^ -o $@clean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">符号</th><th align="center">解释</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">$@</td><td align="center">表示要生成的目标文件</td><td align="center">main.o:main.c中的main.o</td></tr><tr><td align="center">$^</td><td align="center">表示全部的依赖文件</td><td align="center">cal:$(obj)中的整个$(obj)</td></tr><tr><td align="center">$&lt;</td><td align="center">表示第一个依赖文件</td><td align="center">main.o:main.c中第一个依赖，也就是main.c</td></tr></tbody></table><p>还有很多其他的自动化变量，如$+,$*,$?等等，不在本篇博客详细解释，感兴趣的话可以自行查阅相关资料</p><p>上面这段代码还可以进一步简化。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))ALL:cal$(obj):%.o:%.cgcc -c $&lt; -o $@cal:$(obj)gcc $^ -o $@clean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的小伙伴会发现这两段代码多出来一个目标<code>clean</code>，如果你希望重新make一遍工程，那就需要先把生成的各项文件删除。用<code>make clean</code>指令就可以自己声明清理函数</p><p>如果你在想，我们又不打算生成clean目标文件，有没有别的书写方案？答案是有的，就需要用到标签中的 “伪目标“ <code>.PHONY</code>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">.PHONY : clean clean : -rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。)</p><p>当然，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。 </p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p><h3 id="3-7-引用文件"><a href="#3-7-引用文件" class="headerlink" title="3.7 引用文件"></a>3.7 引用文件</h3><p>如果我们整个工程的头文件全都在别的文件夹，比如说在<code>./inc</code>目录底下，我们有<code>add.h  mul.h  sub.h</code>三个头文件，应该怎么引用进来呢？</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">src = $(wildcard *.c)obj = $(patsubst %.c, %.o, $(src))ALL:cal$(obj):%.o:%.cgcc -c $&lt; -o $@ -I inccal:$(obj)gcc $^ -o $@ -I incclean:-rm -rf $(obj) cal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，我们使用<code>-I/</code>或者<code>--include-dir</code>参数，就可以指定头文件所在位置了</p><p>事实上，不只是头文件，有其他的makefile文件，也可以用这个参数导入。make 就会在这个参数所指定的目录下去寻找。如果目录prefix/include（一般是：/usr/local/bin 或/usr/include）存在的话，make 也会去找。</p><p>如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make 不理那些无法读取的文件，而继续执行，你可以像上面的<code>clean</code>目标一样，在 include 前加一个减号“-”。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站的第一篇博客</title>
      <link href="/2022/03/21/first/"/>
      <url>/2022/03/21/first/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="建站以来第一篇博客"><a href="#建站以来第一篇博客" class="headerlink" title="建站以来第一篇博客"></a>建站以来第一篇博客</h1><p>大家好，这里是拓佑豪的博客网站，也是我的第一篇博客。<br>这篇博客没什么营养，留个纪念，也是为了代码调试的时候，可以看看效果<br>就，在这里聊聊几句，简单立个flag。后续会在这个博客网站发布一些技术类文章</p><h1 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h1><p>几年前就有设计自己博客的想法。奈何当时我接触到这方面资讯太少，我就在<code>华为云博客</code>上发了几篇关于OpenCV和Atlas 200DK的文章。但发现对文章归类和修改等等方面我用着不是很习惯（主要也是因为我没坐下来好好整理资料写博客），遂停更了好长一段时间。直到前段时间对静态网站有了大致的了解，就计划从现在开始积累自己的博客，把文章分门别类整理好，来维护好这个博客网站。</p><h1 id="When？什么时候开始写的？"><a href="#When？什么时候开始写的？" class="headerlink" title="When？什么时候开始写的？"></a>When？什么时候开始写的？</h1><p>也没多久，2021年才开始。不过写博客这个计划我会持续坚持下去</p><h1 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h1><p>本博客主要整理和计算机相关的博客，内容会慢慢偏向于人工智能方面，细分下来各种类别的文章可能多多少少都会有点。</p><h1 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h1><p>我会从简单的技术内容开始写起，包括重新整理以前写过的OpenCV类博客，把一些我认为讲的不够清晰的内容再梳理一遍。主要内容还是面向人工智能领域。</p><h1 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h1><p>写博客其实还蛮花时间的，尤其是在任务量多起来的时候。金钱的话就没有开销了，托管在GitHub上，你看我是不是连个域名都没买(Ｔ▽Ｔ)。等博客有了一定的时间、积累一定量比较拿得出手的文章，或许那个时候我会买个域名。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
